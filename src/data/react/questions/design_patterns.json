{
  "default": [
    {
      "id": "dp-01",
      "stageId": "design_patterns",
      "type": "single",
      "options": [
        "To make components render 50% faster.",
        "To allow a group of components to work together and share implicit state without prop drilling.",
        "To combine React with other frameworks like Vue.",
        "To hide all logic inside a single monolithic component."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "dp-02",
      "stageId": "design_patterns",
      "type": "single",
      "code": "function Tabs({ children }) {\n  const [active, setActive] = useState(0);\n  return (\n    <TabsContext.Provider value={{ active, setActive }}>\n      {children}\n    </TabsContext.Provider>\n  );\n}",
      "options": [
        "By passing props manually to every child.",
        "By using React Context to provide state to all nested children.",
        "By using global window variables.",
        "By cloning each child and injecting props using React.cloneElement."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "dp-03",
      "stageId": "design_patterns",
      "type": "single",
      "options": [
        "A component that is rendered at the top of the page.",
        "A function that takes a component and returns a new component with added functionality.",
        "A hook that replaces the need for state.",
        "A component with more than 1000 lines of code."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "dp-04",
      "stageId": "design_patterns",
      "type": "single",
      "code": "<MouseTracker render={mouse => (\n  <p>The mouse position is {mouse.x}, {mouse.y}</p>\n)} />",
      "options": [
        "A static object.",
        "A function that tells the component what to render based on internal state.",
        "A direct reference to the DOM.",
        "A boolean flag."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "dp-05",
      "stageId": "design_patterns",
      "type": "multiple",
      "options": [
        "The component's data is stored in the React state.",
        "The component manages its own internal state via the DOM.",
        "Changes are handled by an onChange callback that updates the state.",
        "The value prop is set by the parent."
      ],
      "correct": [
        0,
        2,
        3
      ]
    },
    {
      "id": "dp-06",
      "stageId": "design_patterns",
      "type": "single",
      "code": "function Toggle({ value, onChange }) {\n  const [internalValue, setInternal] = useState(false);\n  const isControlled = value !== undefined;\n  const current = isControlled ? value : internalValue;\n  // ...\n}",
      "options": [
        "The code above shows the logic for a component that can be both controlled or uncontrolled.",
        "By always using a global Redux store.",
        "By deleting the internal state entirely.",
        "By forcing the user to pass all props."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "dp-07",
      "stageId": "design_patterns",
      "type": "single",
      "options": [
        "A pattern that separates data fetching (Container) from UI rendering (Presentational).",
        "A way to put all CSS in a container file.",
        "A method to group components by their size.",
        "A way to render React components inside a Docker container."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "dp-08",
      "stageId": "design_patterns",
      "type": "single",
      "code": "const EnhancedComponent = withAuth(withLogging(withTheme(MyComponent)));",
      "options": [
        "It makes the component render faster.",
        "It leads to 'Wrapper Hell', making it difficult to track where props are coming from.",
        "React doesn't allow more than two HOCs.",
        "The component will lose its state."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "dp-09",
      "stageId": "design_patterns",
      "type": "single",
      "code": "<Card header={<UserHeader />} footer={<SocialActions />} />",
      "options": [
        "It allows you to pass JSX elements as props to be placed in specific locations.",
        "It is used to save data in a slot on the server.",
        "It generates random IDs for components.",
        "It is a way to use 3D models in React."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "dp-10",
      "stageId": "design_patterns",
      "type": "single",
      "options": [
        "By using the Render Prop pattern at the top level.",
        "By using the Compound Components pattern with React Context.",
        "By copying the data to the clipboard.",
        "By using a for-loop to inject props."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "dp-11",
      "stageId": "design_patterns",
      "type": "multiple",
      "options": [
        "Mixins.",
        "Higher-Order Components (partially).",
        "Compound Components.",
        "Render Props (partially)."
      ],
      "correct": [
        0,
        1,
        3
      ]
    },
    {
      "id": "dp-12",
      "stageId": "design_patterns",
      "type": "single",
      "code": "const { getButtonProps, getInputProps } = useForm();\nreturn <button {...getButtonProps()}>Submit</button>;",
      "options": [
        "A way to delete unused props.",
        "A pattern where a hook returns a function that provides all necessary props for a specific element.",
        "A collection of all CSS classes in the app.",
        "A way to store props in a database."
      ],
      "correct": [
        1
      ]
    }
  ]
}
