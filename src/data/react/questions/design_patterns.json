{
  "default": [
    {
      "id": "dp-01",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "What is the primary goal of the 'Compound Components' pattern?",
      "options": [
        "To make components render 50% faster.",
        "To allow a group of components to work together and share implicit state without prop drilling.",
        "To combine React with other frameworks like Vue.",
        "To hide all logic inside a single monolithic component."
      ],
      "correct": [1],
      "explanation": "Compound components (like <Select> and <Option>) share state behind the scenes, giving the consumer more control over the rendered structure while keeping logic encapsulated.",
      "interviewTip": "Think of the HTML <select> and <option> tags. They work together as a unit; that is a native compound component."
    },
    {
      "id": "dp-02",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "In the Compound Component pattern, how is the internal state usually shared among children?",
      "code": "function Tabs({ children }) {\n  const [active, setActive] = useState(0);\n  return (\n    <TabsContext.Provider value={{ active, setActive }}>\n      {children}\n    </TabsContext.Provider>\n  );\n}",
      "options": [
        "By passing props manually to every child.",
        "By using React Context to provide state to all nested children.",
        "By using global window variables.",
        "By cloning each child and injecting props using React.cloneElement."
      ],
      "correct": [1],
      "explanation": "While cloneElement was used in the past, React Context is now the preferred way to share state within a compound component group.",
      "interviewTip": "Mention that Context is safer and more flexible than cloneElement because it works even if children are wrapped in other divs."
    },
    {
      "id": "dp-03",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "What is a 'Higher-Order Component' (HOC)?",
      "options": [
        "A component that is rendered at the top of the page.",
        "A function that takes a component and returns a new component with added functionality.",
        "A hook that replaces the need for state.",
        "A component with more than 1000 lines of code."
      ],
      "correct": [1],
      "explanation": "HOCs are a pattern for reusing component logic. They act as wrappers that 'enhance' the original component with new props or behaviors.",
      "interviewTip": "While HOCs are less common since Hooks were introduced, they are still used for Cross-Cutting Concerns like Authentication or Logging."
    },
    {
      "id": "dp-04",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "Analyze the 'Render Prop' pattern. What is being passed to the Child?",
      "code": "<MouseTracker render={mouse => (\n  <p>The mouse position is {mouse.x}, {mouse.y}</p>\n)} />",
      "options": [
        "A static object.",
        "A function that tells the component what to render based on internal state.",
        "A direct reference to the DOM.",
        "A boolean flag."
      ],
      "correct": [1],
      "explanation": "A render prop is a prop that is a function which a component uses to know what to render. It 'shares' its internal state with the function.",
      "interviewTip": "Render props are highly flexible but can sometimes lead to 'wrapper hell' if over-nested."
    },
    {
      "id": "dp-05",
      "stageId": "design_patterns",
      "type": "multiple",
      "prompt": "Which of the following are characteristics of a 'Controlled Component'?",
      "options": [
        "The component's data is stored in the React state.",
        "The component manages its own internal state via the DOM.",
        "Changes are handled by an onChange callback that updates the state.",
        "The value prop is set by the parent."
      ],
      "correct": [0, 2, 3],
      "explanation": "Controlled components allow React to be the 'Single Source of Truth'. Uncontrolled components rely on the DOM (and Refs) to hold the data.",
      "interviewTip": "Use controlled components for almost everything unless you have a specific performance reason to use a Ref."
    },
    {
      "id": "dp-06",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "How do you implement the 'Controlled Props' pattern to allow a user to 'take over' a component's internal state?",
      "code": "function Toggle({ value, onChange }) {\n  const [internalValue, setInternal] = useState(false);\n  const isControlled = value !== undefined;\n  const current = isControlled ? value : internalValue;\n  // ...\n}",
      "options": [
        "The code above shows the logic for a component that can be both controlled or uncontrolled.",
        "By always using a global Redux store.",
        "By deleting the internal state entirely.",
        "By forcing the user to pass all props."
      ],
      "correct": [0],
      "explanation": "This pattern allows a component to manage its own state by default, but gives the parent the option to 'control' it if a prop is provided.",
      "interviewTip": "This is a common pattern in advanced UI libraries like Downshift or Material UI."
    },
    {
      "id": "dp-07",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "What is the 'Container/Presentational' pattern?",
      "options": [
        "A pattern that separates data fetching (Container) from UI rendering (Presentational).",
        "A way to put all CSS in a container file.",
        "A method to group components by their size.",
        "A way to render React components inside a Docker container."
      ],
      "correct": [0],
      "explanation": "Presentational components are 'dumb' and only care about how things look. Containers are 'smart' and care about how things work (API calls, state logic).",
      "interviewTip": "Hooks have largely replaced this pattern because you can now put 'smart' logic in a custom hook instead of a wrapper component."
    },
    {
      "id": "dp-08",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "Identify the issue when using HOCs:",
      "code": "const EnhancedComponent = withAuth(withLogging(withTheme(MyComponent)));",
      "options": [
        "It makes the component render faster.",
        "It leads to 'Wrapper Hell', making it difficult to track where props are coming from.",
        "React doesn't allow more than two HOCs.",
        "The component will lose its state."
      ],
      "correct": [1],
      "explanation": "Heavily nested HOCs make debugging difficult because it's unclear which HOC is passing which prop. Hooks solve this by providing a flat structure.",
      "interviewTip": "This is one of the main reasons the React community shifted from HOCs to Hooks."
    },
    {
      "id": "dp-09",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "What does the 'Slot' pattern achieve in React?",
      "code": "<Card header={<UserHeader />} footer={<SocialActions />} />",
      "options": [
        "It allows you to pass JSX elements as props to be placed in specific locations.",
        "It is used to save data in a slot on the server.",
        "It generates random IDs for components.",
        "It is a way to use 3D models in React."
      ],
      "correct": [0],
      "explanation": "Slots are a form of composition that allows a parent to define specific UI 'holes' that a child component fills.",
      "interviewTip": "Slots are often easier to manage than complex boolean flags within a component."
    },
    {
      "id": "dp-10",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "How do you avoid 'prop drilling' in a deeply nested component tree using patterns?",
      "options": [
        "By using the Render Prop pattern at the top level.",
        "By using the Compound Components pattern with React Context.",
        "By copying the data to the clipboard.",
        "By using a for-loop to inject props."
      ],
      "correct": [1],
      "explanation": "Compound components use Context to broadcast state to all descendants, effectively ending the need for drilling.",
      "interviewTip": "Mention that this keeps the component API 'clean' as users don't see the state being passed."
    },
    {
      "id": "dp-11",
      "stageId": "design_patterns",
      "type": "multiple",
      "prompt": "Which patterns are considered 'Obsolete' or 'Legacy' due to the introduction of Hooks?",
      "options": [
        "Mixins.",
        "Higher-Order Components (partially).",
        "Compound Components.",
        "Render Props (partially)."
      ],
      "correct": [0, 1, 3],
      "explanation": "Mixins are completely obsolete. HOCs and Render Props are still valid but are much less common as Hooks solve the same problems with less nesting.",
      "interviewTip": "Compound Components are still very much alive and well because they solve a different problem (UI structure/API design)."
    },
    {
      "id": "dp-12",
      "stageId": "design_patterns",
      "type": "single",
      "prompt": "What is the 'Prop Collection' pattern?",
      "code": "const { getButtonProps, getInputProps } = useForm();\nreturn <button {...getButtonProps()}>Submit</button>;",
      "options": [
        "A way to delete unused props.",
        "A pattern where a hook returns a function that provides all necessary props for a specific element.",
        "A collection of all CSS classes in the app.",
        "A way to store props in a database."
      ],
      "correct": [1],
      "explanation": "This pattern simplifies the consumer's work by bundling accessibility, event handlers, and attributes into a single spreadable object.",
      "interviewTip": "This is widely used in 'Headless UI' libraries like Radix UI or Reach UI."
    }
  ]
}
