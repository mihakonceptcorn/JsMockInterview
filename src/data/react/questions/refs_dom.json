{
  "default": [
    {
      "id": "rd-01",
      "stageId": "refs_dom",
      "type": "single",
      "options": [
        "To trigger a re-render whenever the value changes.",
        "To store a mutable value that persists across renders without causing a re-render.",
        "To validate the types of props passed to a component.",
        "To create a global state accessible by all components."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-02",
      "stageId": "refs_dom",
      "type": "single",
      "code": "function App() {\n  const inputRef = useRef(null);\n  const focusInput = () => {\n    // How to focus?\n  };\n  return <input ref={inputRef} />;\n}",
      "options": [
        "inputRef.focus()",
        "inputRef.current.focus()",
        "inputRef.value.focus()",
        "document.getElementById('input').focus()"
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-03",
      "stageId": "refs_dom",
      "type": "single",
      "options": [
        "It is reset to the initial value provided in useRef(initial).",
        "It is preserved and stays exactly as it was before the render.",
        "It is cleared and becomes null.",
        "It causes an infinite render loop."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-04",
      "stageId": "refs_dom",
      "type": "multiple",
      "options": [
        "Managing focus, text selection, or media playback.",
        "Storing the current text of an input field to display it in the UI.",
        "Integrating with third-party DOM libraries.",
        "Triggering an animation that depends on state changes."
      ],
      "correct": [
        0,
        2
      ]
    },
    {
      "id": "rd-05",
      "stageId": "refs_dom",
      "type": "single",
      "code": "const MyInput = forwardRef((props, ref) => (\n  <input ref={ref} {...props} />\n));",
      "options": [
        "To allow a parent component to access a DOM ref inside a child component.",
        "To speed up the rendering of functional components.",
        "To prevent a component from re-rendering when props change.",
        "To automatically focus the first input in a component."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "rd-06",
      "stageId": "refs_dom",
      "type": "single",
      "options": [
        "During the render phase.",
        "Before the DOM elements are created.",
        "After the component is committed to the screen (during mount/update).",
        "Only when the developer calls ref.update()."
      ],
      "correct": [
        2
      ]
    },
    {
      "id": "rd-07",
      "stageId": "refs_dom",
      "type": "single",
      "code": "function App() {\n  const renderCount = useRef(0);\n  renderCount.current++;\n  return <button onClick={() => console.log(renderCount.current)}>Log</button>;\n}",
      "options": [
        "It will always log 0.",
        "It will log the number of times the component has rendered.",
        "It will cause a 'Max depth exceeded' error.",
        "The button text will change to the count."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-08",
      "stageId": "refs_dom",
      "type": "single",
      "code": "const timerRef = useRef();\nuseEffect(() => {\n  timerRef.current = setInterval(() => {}, 1000);\n  return () => clearInterval(timerRef.current);\n}, []);",
      "options": [
        "Using a local variable: let timer = setInterval(...)",
        "Using useState: const [timer, setTimer] = useState(...)",
        "Using useRef as shown in the code.",
        "Intervals are not supported in functional components."
      ],
      "correct": [
        2
      ]
    },
    {
      "id": "rd-09",
      "stageId": "refs_dom",
      "type": "single",
      "options": [
        "No, it's only for HTML elements.",
        "Yes, it can store any JavaScript value (strings, objects, functions).",
        "Only if the value is a number.",
        "Only if you use the useMemo hook instead."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-10",
      "stageId": "refs_dom",
      "type": "multiple",
      "options": [
        "createRef is primarily used in Class components.",
        "useRef always returns the same object; createRef creates a new object every render.",
        "createRef is faster than useRef.",
        "useRef only works with DOM nodes."
      ],
      "correct": [
        0,
        1
      ]
    },
    {
      "id": "rd-11",
      "stageId": "refs_dom",
      "type": "single",
      "code": "function App() {\n  const myRef = useRef();\n  const val = myRef.current.innerText;\n  return <div ref={myRef}>Hello</div>;\n}",
      "options": [
        "The div tag is missing a key.",
        "myRef.current is null during the first render, leading to a crash.",
        "useRef cannot access innerText.",
        "Refs must be initialized with a string."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-12",
      "stageId": "refs_dom",
      "type": "single",
      "options": [
        "Create an array of refs using a single useRef([]).",
        "Call useRef inside the .map() callback.",
        "Pass the index as the ref name: ref={index}.",
        "React doesn't support multiple refs in a loop."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "rd-13",
      "stageId": "refs_dom",
      "type": "single",
      "options": [
        "It makes the component render faster.",
        "It allows a child component to customize the instance value that is exposed to a parent using a ref.",
        "It forces React to update the DOM immediately.",
        "It replaces the useState hook for complex forms."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "rd-14",
      "stageId": "refs_dom",
      "type": "single",
      "code": "function App() {\n  const [count, setCount] = useState(0);\n  const myRef = useRef(0);\n  const increment = () => {\n    myRef.current++;\n    setCount(c => c + 1);\n    console.log(myRef.current);\n  };\n  return <button onClick={increment}>Click</button>;\n}",
      "options": [
        "0",
        "1",
        "The previous count.",
        "undefined"
      ],
      "correct": [
        1
      ]
    }
  ]
}
