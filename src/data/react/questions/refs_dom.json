{
  "default": [
    {
      "id": "rd-01",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "What is the primary purpose of the 'useRef' hook in React?",
      "options": [
        "To trigger a re-render whenever the value changes.",
        "To store a mutable value that persists across renders without causing a re-render.",
        "To validate the types of props passed to a component.",
        "To create a global state accessible by all components."
      ],
      "correct": [1],
      "explanation": "useRef returns a plain JavaScript object that persists for the full lifetime of the component. Changing the .current property does not trigger a re-render.",
      "interviewTip": "Think of useRef as a 'box' that can hold any value, but most commonly it holds a DOM element."
    },
    {
      "id": "rd-02",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "How do you access a DOM node using a ref in a functional component?",
      "code": "function App() {\n  const inputRef = useRef(null);\n  const focusInput = () => {\n    // How to focus?\n  };\n  return <input ref={inputRef} />;\n}",
      "options": [
        "inputRef.focus()",
        "inputRef.current.focus()",
        "inputRef.value.focus()",
        "document.getElementById('input').focus()"
      ],
      "correct": [1],
      "explanation": "When you pass a ref to a JSX element, React sets the '.current' property of that ref object to the corresponding DOM node.",
      "interviewTip": "Always check if inputRef.current exists before calling methods on it to avoid null errors."
    },
    {
      "id": "rd-03",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "What happens to the value stored in 'useRef' when the component re-renders?",
      "options": [
        "It is reset to the initial value provided in useRef(initial).",
        "It is preserved and stays exactly as it was before the render.",
        "It is cleared and becomes null.",
        "It causes an infinite render loop."
      ],
      "correct": [1],
      "explanation": "Unlike local variables, which are recreated every render, useRef values are kept by React throughout the component's lifecycle.",
      "interviewTip": "This makes refs perfect for storing timers, interval IDs, or previous prop values."
    },
    {
      "id": "rd-04",
      "stageId": "refs_dom",
      "type": "multiple",
      "prompt": "In which scenarios is it appropriate to use a Ref?",
      "options": [
        "Managing focus, text selection, or media playback.",
        "Storing the current text of an input field to display it in the UI.",
        "Integrating with third-party DOM libraries.",
        "Triggering an animation that depends on state changes."
      ],
      "correct": [0, 2],
      "explanation": "If something can be done 'declaratively' with state, use state. Use refs only for 'imperative' actions like focusing or measuring.",
      "interviewTip": "The React docs call refs an 'escape hatch'—use them only when state isn't enough."
    },
    {
      "id": "rd-05",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "What is the purpose of 'forwardRef'?",
      "code": "const MyInput = forwardRef((props, ref) => (\n  <input ref={ref} {...props} />\n));",
      "options": [
        "To allow a parent component to access a DOM ref inside a child component.",
        "To speed up the rendering of functional components.",
        "To prevent a component from re-rendering when props change.",
        "To automatically focus the first input in a component."
      ],
      "correct": [0],
      "explanation": "By default, you cannot pass a 'ref' prop to a functional component. forwardRef 'forwards' the ref from the parent down to a specific element in the child.",
      "interviewTip": "This is a common pattern for design system components like Inputs or Buttons."
    },
    {
      "id": "rd-06",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "When does React update the 'ref.current' property?",
      "options": [
        "During the render phase.",
        "Before the DOM elements are created.",
        "After the component is committed to the screen (during mount/update).",
        "Only when the developer calls ref.update()."
      ],
      "correct": [2],
      "explanation": "React assigns the DOM node to .current when the component mounts and sets it to null when it unmounts.",
      "interviewTip": "Because of this timing, you should only access DOM refs inside useEffect or event handlers."
    },
    {
      "id": "rd-07",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "What is the result of the following code after clicking 'Log'?",
      "code": "function App() {\n  const renderCount = useRef(0);\n  renderCount.current++;\n  return <button onClick={() => console.log(renderCount.current)}>Log</button>;\n}",
      "options": [
        "It will always log 0.",
        "It will log the number of times the component has rendered.",
        "It will cause a 'Max depth exceeded' error.",
        "The button text will change to the count."
      ],
      "correct": [1],
      "explanation": "Every time the component renders, the count increments. Since it's a ref, it persists, but it doesn't *trigger* a render itself.",
      "interviewTip": "This is a great way to track how many times a component is re-rendering for performance debugging."
    },
    {
      "id": "rd-08",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "How do you store an interval ID in a functional component correctly?",
      "code": "const timerRef = useRef();\nuseEffect(() => {\n  timerRef.current = setInterval(() => {}, 1000);\n  return () => clearInterval(timerRef.current);\n}, []);",
      "options": [
        "Using a local variable: let timer = setInterval(...)",
        "Using useState: const [timer, setTimer] = useState(...)",
        "Using useRef as shown in the code.",
        "Intervals are not supported in functional components."
      ],
      "correct": [2],
      "explanation": "A local variable would be reset on every render. useState would trigger a re-render when the ID is set. useRef is the perfect middle ground.",
      "interviewTip": "Always clear your intervals in the cleanup function of useEffect to avoid memory leaks."
    },
    {
      "id": "rd-09",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "Can you use 'useRef' to store a value that isn't a DOM element?",
      "options": [
        "No, it's only for HTML elements.",
        "Yes, it can store any JavaScript value (strings, objects, functions).",
        "Only if the value is a number.",
        "Only if you use the useMemo hook instead."
      ],
      "correct": [1],
      "explanation": "useRef is essentially a generic container for any mutable value you want to keep between renders.",
      "interviewTip": "This is often used to store 'previousProps' for comparison logic."
    },
    {
      "id": "rd-10",
      "stageId": "refs_dom",
      "type": "multiple",
      "prompt": "What is the difference between 'useRef' and 'createRef'?",
      "options": [
        "createRef is primarily used in Class components.",
        "useRef always returns the same object; createRef creates a new object every render.",
        "createRef is faster than useRef.",
        "useRef only works with DOM nodes."
      ],
      "correct": [0, 1],
      "explanation": "In functional components, createRef would lose its value on every re-render. useRef is designed to 'hook' into React's persistent storage.",
      "interviewTip": "If you use createRef inside a function component, it will be reset every time the function runs."
    },
    {
      "id": "rd-11",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "Identify the issue in this code:",
      "code": "function App() {\n  const myRef = useRef();\n  const val = myRef.current.innerText;\n  return <div ref={myRef}>Hello</div>;\n}",
      "options": [
        "The div tag is missing a key.",
        "myRef.current is null during the first render, leading to a crash.",
        "useRef cannot access innerText.",
        "Refs must be initialized with a string."
      ],
      "correct": [1],
      "explanation": "During the first render, the DOM hasn't been created yet, so myRef.current is undefined/null. You should only access it in a useEffect or an event.",
      "interviewTip": "This is a very common 'TypeError: Cannot read property of null' bug."
    },
    {
      "id": "rd-12",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "How do you handle multiple refs in a list generated by .map()?",
      "options": [
        "Create an array of refs using a single useRef([]).",
        "Call useRef inside the .map() callback.",
        "Pass the index as the ref name: ref={index}.",
        "React doesn't support multiple refs in a loop."
      ],
      "correct": [0],
      "explanation": "You cannot call hooks inside loops. Instead, create a single ref to an array or a Map and assign each element to an index/key.",
      "interviewTip": "Pattern: `<li ref={el => (itemsRef.current[i] = el)} />` (this is called a callback ref)."
    },
    {
      "id": "rd-13",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "What does 'useImperativeHandle' do?",
      "options": [
        "It makes the component render faster.",
        "It allows a child component to customize the instance value that is exposed to a parent using a ref.",
        "It forces React to update the DOM immediately.",
        "It replaces the useState hook for complex forms."
      ],
      "correct": [1],
      "explanation": "Used with forwardRef, it lets you hide the raw DOM node and instead expose only specific methods (like .focus() or .scrollTo()) to the parent.",
      "interviewTip": "This is helpful for encapsulation—don't let the parent mess with the child's internals."
    },
    {
      "id": "rd-14",
      "stageId": "refs_dom",
      "type": "single",
      "prompt": "What will be printed to the console?",
      "code": "function App() {\n  const [count, setCount] = useState(0);\n  const myRef = useRef(0);\n  const increment = () => {\n    myRef.current++;\n    setCount(c => c + 1);\n    console.log(myRef.current);\n  };\n  return <button onClick={increment}>Click</button>;\n}",
      "options": ["0", "1", "The previous count.", "undefined"],
      "correct": [1],
      "explanation": "Unlike state updates which are async, updates to ref.current happen instantly. The incremented value is available immediately.",
      "interviewTip": "This is a key distinction: State is for data that the UI depends on; Refs are for data the UI *doesn't* directly render."
    }
  ]
}
