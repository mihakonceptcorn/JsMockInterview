{
  "default": [
    {
      "id": "mem-01",
      "stageId": "memoization",
      "type": "single",
      "options": [
        "useMemo is for Class components; useCallback is for Functional components.",
        "useMemo caches the result of a function; useCallback caches the function definition itself.",
        "useCallback is faster than useMemo.",
        "useMemo triggers a re-render; useCallback prevents it."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "mem-02",
      "stageId": "memoization",
      "type": "single",
      "code": "const value = useMemo(() => {\n  console.log('Calculating...');\n  return count * 2;\n}, [count]);",
      "options": [
        "Once (only on the initial render).",
        "Zero times.",
        "On every single re-render.",
        "Every time the parent component renders."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "mem-03",
      "stageId": "memoization",
      "type": "single",
      "options": [
        "It automatically saves the component's state to a database.",
        "It prevents the component from re-rendering if its props have not changed.",
        "It makes the component invisible until it is fully loaded.",
        "It allows the component to bypass the Virtual DOM."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "mem-04",
      "stageId": "memoization",
      "type": "multiple",
      "options": [
        "Passing a new object literal as a prop: <Child data={{}} />.",
        "Passing a numeric prop: <Child count={5} />.",
        "Passing an inline arrow function: <Child onClick={() => {}} />.",
        "Passing a string prop: <Child name='Alice' />."
      ],
      "correct": [
        0,
        2
      ]
    },
    {
      "id": "mem-05",
      "stageId": "memoization",
      "type": "single",
      "options": [
        "When two variables have the same string name.",
        "When React checks if two variables point to the exact same memory address.",
        "When the HTML structure of two components matches.",
        "When two components share the same key prop."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "mem-06",
      "stageId": "memoization",
      "type": "single",
      "code": "const handleClick = useCallback(() => {\n  console.log(text);\n}, []); // Missing 'text' in dependencies",
      "options": [
        "It will cause an infinite loop.",
        "It will always log the value of 'text' from the very first render (Stale Closure).",
        "The component will crash.",
        "useCallback cannot log to the console."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "mem-07",
      "stageId": "memoization",
      "type": "single",
      "options": [
        "In small components with simple logic.",
        "When passing props to a memoized child component.",
        "When performing expensive array filtering.",
        "When the dependency array is very large."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "mem-08",
      "stageId": "memoization",
      "type": "single",
      "code": "function Parent() {\n  const [count, setCount] = useState(0);\n  const data = [1, 2, 3]; // No useMemo\n  return <MemoizedChild list={data} />;\n}",
      "options": [
        "MemoizedChild will not re-render because the array content is identical.",
        "MemoizedChild will re-render because 'data' is a new array reference every time.",
        "React will throw an error.",
        "Only the first item in the list will re-render."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "mem-09",
      "stageId": "memoization",
      "type": "single",
      "options": [
        "It allows you to manually define the comparison logic for props.",
        "It sets the time-to-live for the cache.",
        "It allows you to pass a custom key to the component.",
        "It lets you decide which state changes to ignore."
      ],
      "correct": [
        0
      ]
    },
    {
      "id": "mem-10",
      "stageId": "memoization",
      "type": "multiple",
      "options": [
        "useEffect (when functions/objects are in the dependency array).",
        "useState.",
        "useContext (to avoid re-rendering all consumers).",
        "useRef."
      ],
      "correct": [
        0,
        2
      ]
    },
    {
      "id": "mem-11",
      "stageId": "memoization",
      "type": "single",
      "options": [
        "const val = useMemo(calculate(a, b), [a, b]);",
        "const val = useMemo(() => calculate(a, b), [a, b]);",
        "const val = useCallback(() => calculate(a, b), [a, b]);",
        "const val = React.memo(calculate(a, b));"
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "mem-12",
      "stageId": "memoization",
      "type": "single",
      "code": "const val = useMemo(() => useState(0), []);",
      "options": [
        "It creates a local state for the memoized value.",
        "It is invalid; hooks cannot be called inside useMemo.",
        "It works only in React 18.",
        "It returns a setter function."
      ],
      "correct": [
        1
      ]
    }
  ]
}
