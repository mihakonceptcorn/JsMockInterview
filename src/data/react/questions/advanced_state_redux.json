{
  "default": [
    {
      "id": "rdx-01",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is the primary benefit of Redux Toolkit over 'plain' Redux?",
      "options": [
        "It makes Redux faster",
        "It significantly reduces boilerplate code and simplifies store setup",
        "It replaces the need for React Context entirely",
        "It is only for mobile applications"
      ],
      "correct": [1],
      "explanation": "RTK provides a set of tools (like createSlice and configureStore) that automate standard Redux tasks that used to require manual code.",
      "interviewTip": "Mention that RTK is now the 'official, recommended way to write Redux logic'."
    },
    {
      "id": "rdx-02",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What does 'createSlice' combine into one single place?",
      "options": [
        "Actions, Reducers, and the initial state",
        "State, Effects, and Refs",
        "The Store and the Provider",
        "HTML, CSS, and JS"
      ],
      "correct": [0],
      "explanation": "A slice allows you to define your state, your reducer logic, and it automatically generates the action creators for you.",
      "interviewTip": "This pattern helps in 'feature-based' folder structures."
    },
    {
      "id": "rdx-03",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "How does Redux Toolkit allow 'mutating' logic inside reducers (e.g., state.push())?",
      "options": [
        "It actually mutates the real state",
        "It uses the Immer library to handle immutable updates automatically",
        "It converts the code to class-based logic",
        "Mutating logic is actually not allowed even in RTK"
      ],
      "correct": [1],
      "explanation": "RTK uses Immer, which tracks 'mutations' to a draft state and returns a brand new immutable state object based on those changes.",
      "interviewTip": "Crucial: This only works inside createSlice and createReducer."
    },
    {
      "id": "rdx-04",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "Which hook is used to access data from the Redux store?",
      "options": ["useDispatch", "useStore", "useSelector", "useContext"],
      "correct": [2],
      "explanation": "useSelector takes a selector function that extracts specifically what you need from the global state tree.",
      "interviewTip": "Selectors should be fine-grained. Selecting the whole state causes the component to re-render on every tiny change."
    },
    {
      "id": "rdx-05",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "Which hook is used to send an action to the Redux store?",
      "options": ["useDispatch", "useAction", "useSelector", "useReducer"],
      "correct": [0],
      "explanation": "useDispatch returns the dispatch function from the Redux store, which you use to trigger actions.",
      "interviewTip": "Dispatching an action is the only way to trigger a state update in Redux."
    },
    {
      "id": "rdx-06",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is the purpose of 'configureStore'?",
      "options": [
        "To create a new React component",
        "To set up the store with sensible defaults like Redux DevTools and Middleware",
        "To configure the API endpoints",
        "To replace the <Provider>"
      ],
      "correct": [1],
      "explanation": "configureStore automatically adds the Thunk middleware and enables the Redux DevTools extension for you.",
      "interviewTip": "In 'vanilla' Redux, you had to manually combineReducers and applyMiddleware; RTK does this in one step."
    },
    {
      "id": "rdx-07",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is an 'Async Thunk' used for?",
      "options": [
        "To style components dynamically",
        "To handle asynchronous logic like API calls",
        "To speed up the rendering of components",
        "To synchronize the store with LocalStorage"
      ],
      "correct": [1],
      "explanation": "createAsyncThunk handles the lifecycle of an async request (pending, fulfilled, rejected) and dispatches actions accordingly.",
      "interviewTip": "Thunks are the standard way to perform side effects in Redux."
    },
    {
      "id": "rdx-08",
      "stageId": "advanced_state_redux",
      "type": "multiple",
      "prompt": "What are the three action types automatically generated by createAsyncThunk?",
      "options": ["pending", "fulfilled", "rejected", "started"],
      "correct": [0, 1, 2],
      "explanation": "When the thunk is dispatched, it immediately goes to 'pending'. Upon success, 'fulfilled' is fired; on error, 'rejected' is fired.",
      "interviewTip": "You handle these in the 'extraReducers' section of your slice."
    },
    {
      "id": "rdx-09",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is 'extraReducers' used for in createSlice?",
      "options": [
        "To handle actions that weren't defined in the slice (like Thunks)",
        "To create extra state variables",
        "To debug the reducer logic",
        "To add CSS to the slice"
      ],
      "correct": [0],
      "explanation": "extraReducers allows a slice to respond to actions generated by other slices or createAsyncThunk.",
      "interviewTip": "This is how you keep slices independent while allowing them to react to global events."
    },
    {
      "id": "rdx-10",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is a 'PayloadAction' type used for in TypeScript with RTK?",
      "options": [
        "To define the type of the state",
        "To define the type of the data being sent with an action",
        "To define the return type of a selector",
        "To define the middleware types"
      ],
      "correct": [1],
      "explanation": "In TS, PayloadAction<T> ensures that the 'action.payload' has the correct structure throughout your reducers.",
      "interviewTip": "Typed Redux code prevents 'undefined is not an object' errors in production."
    },
    {
      "id": "rdx-11",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "Where should business logic ideally live in a Redux app?",
      "options": [
        "Inside the React component",
        "Inside the Reducers or Thunks",
        "In the CSS files",
        "Inside the useSelector hook"
      ],
      "correct": [1],
      "explanation": "Keeping logic in Redux (specifically Thunks/Reducers) makes it testable and independent of the UI layer.",
      "interviewTip": "Components should be 'thin' (mostly UI), and Redux should be 'thick' (logic)."
    },
    {
      "id": "rdx-12",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is the Redux DevTools 'Time Travel' feature?",
      "options": [
        "A way to see the history of state changes and jump back to any previous state",
        "A way to predict future user clicks",
        "A feature that tracks how long a user stays on a page",
        "A method to speed up JavaScript execution"
      ],
      "correct": [0],
      "explanation": "Because Redux state is immutable and actions are logged, you can 'replay' the state history to debug exactly where things went wrong.",
      "interviewTip": "This is the most powerful debugging tool in the React ecosystem."
    },
    {
      "id": "rdx-13",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is Redux Middleware?",
      "options": [
        "A way to style components",
        "A function that intercepts actions before they reach the reducer",
        "A database for Redux",
        "The bridge between React and the Browser"
      ],
      "correct": [1],
      "explanation": "Middleware provides a third-party extension point between dispatching an action and the moment it reaches the reducer (e.g., logging, crash reporting, async logic).",
      "interviewTip": "Thunk and Logger are two of the most popular middlewares."
    },
    {
      "id": "rdx-14",
      "stageId": "advanced_state_redux",
      "type": "multiple",
      "prompt": "Which of these are core principles of Redux?",
      "options": [
        "Single source of truth (one store)",
        "State is read-only (immutable)",
        "Changes are made with pure functions (reducers)",
        "Every component must have its own store"
      ],
      "correct": [0, 1, 2],
      "explanation": "Redux relies on a single global object, strictly immutable updates, and pure reducers to ensure predictable state changes.",
      "interviewTip": "Predictability is the 'keyword' for Redux."
    },
    {
      "id": "rdx-15",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is 'State Normalization' in Redux?",
      "options": [
        "Making sure the state is not too large",
        "Organizing data as a 'database' with IDs as keys to avoid duplication",
        "Converting state to a string",
        "Using useState instead of Redux"
      ],
      "correct": [1],
      "explanation": "Normalization involves storing items as an object of IDs (like a lookup table) instead of deeply nested arrays, making updates much easier.",
      "interviewTip": "RTK provides `createEntityAdapter` to help with this automatically."
    },
    {
      "id": "rdx-16",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What does RTK Query (a part of Redux Toolkit) solve?",
      "options": [
        "It generates CSS based on Redux state",
        "It simplifies data fetching and caching (server state management)",
        "It replaces the need for React Router",
        "It manages local storage automatically"
      ],
      "correct": [1],
      "explanation": "RTK Query is an optional addon that handles fetching, caching, and synchronizing server data, similar to React Query.",
      "interviewTip": "It's built on top of the RTK core, so it works perfectly with your existing store."
    },
    {
      "id": "rdx-17",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "When should you NOT use Redux?",
      "options": [
        "When the app is very large",
        "When data needs to be shared across many unrelated components",
        "When the state is simple and only needed by a single component or its children",
        "When you need to debug state changes"
      ],
      "correct": [2],
      "explanation": "Local state (`useState`) is perfectly fine and often preferred for UI-specific data (like 'is modal open'). Don't put everything in Redux just because you can.",
      "interviewTip": "Rule of thumb: 'Use Redux for global data; use local state for local data'."
    }
  ]
}
