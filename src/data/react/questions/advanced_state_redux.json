{
  "default": [
    {
      "id": "rtk-01",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is the primary purpose of a 'Slice' in Redux Toolkit?",
      "options": [
        "To divide the UI into smaller components.",
        "To bundle the initial state, reducers, and actions for a specific feature in one place.",
        "To split the database into multiple tables.",
        "To handle API calls exclusively."
      ],
      "correct": [1],
      "explanation": "createSlice automatically generates action creators and action types based on the reducers you provide, drastically reducing boilerplate code.",
      "interviewTip": "In legacy Redux, you had to write actions and reducers in separate files. Slices make it modular and concise."
    },
    {
      "id": "rtk-02",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "How does Redux Toolkit allow you to 'mutate' state safely inside a reducer?",
      "code": "const counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) => {\n      state.value += 1; // Is this allowed?\n    }\n  }\n});",
      "options": [
        "It uses a special compiler that changes the code to CSS.",
        "It uses the Immer library under the hood to turn 'mutations' into immutable updates.",
        "It actually mutates the global state, but React doesn't mind.",
        "It only works if you use the 'mutable' keyword."
      ],
      "correct": [1],
      "explanation": "RTK uses Immer, which tracks changes to a 'draft' state and produces a brand new immutable state object for you.",
      "interviewTip": "This is a key benefit: you get the simplicity of mutation syntax with the safety of immutability."
    },
    {
      "id": "rtk-03",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "Which hook is used to extract data from the Redux store state?",
      "options": ["useStore", "useDispatch", "useSelector", "useContext"],
      "correct": [2],
      "explanation": "useSelector takes a selector function that receives the entire store state and returns the specific part you need.",
      "interviewTip": "useSelector also creates a subscription to the store and re-renders the component when the selected data changes."
    },
    {
      "id": "rtk-04",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is the correct way to trigger a state change from a component?",
      "code": "const ____ = useDispatch();\nreturn <button onClick={() => ____(increment())}>Add</button>;",
      "options": ["trigger", "dispatch", "send", "action"],
      "correct": [1],
      "explanation": "The useDispatch hook returns the dispatch function from the Redux store. You call it with an action object to trigger a reducer.",
      "interviewTip": "Dispatching is the *only* way to trigger a state change in Redux, following the 'Single Source of Truth' principle."
    },
    {
      "id": "rtk-05",
      "stageId": "advanced_state_redux",
      "type": "multiple",
      "prompt": "What are the core principles of Redux?",
      "options": [
        "Single source of truth (one store).",
        "State is read-only (changes only via actions).",
        "State can be modified by any component directly.",
        "Changes are made with pure functions (reducers)."
      ],
      "correct": [0, 1, 3],
      "explanation": "Redux relies on predictability. The global state is stored in a single tree, and reducers must be pure functions that take (state, action) and return a new state.",
      "interviewTip": "Predictability makes features like 'Time Travel Debugging' possible."
    },
    {
      "id": "rtk-06",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is 'createAsyncThunk' used for in Redux Toolkit?",
      "options": [
        "To synchronize state with localStorage.",
        "To handle asynchronous logic like API requests.",
        "To create custom UI animations.",
        "To combine multiple slices into one."
      ],
      "correct": [1],
      "explanation": "createAsyncThunk generates promise lifecycle action types (pending, fulfilled, rejected) and handles the dispatching logic for you.",
      "interviewTip": "Handle the results of a thunk in the 'extraReducers' section of your slice."
    },
    {
      "id": "rtk-07",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "Where do you combine all your slices to create the global store?",
      "code": "export const store = configureStore({\n  reducer: {\n    counter: counterReducer,\n    user: userReducer\n  }\n});",
      "options": [
        "Inside the App.js file.",
        "Using the configureStore function.",
        "Inside a custom hook.",
        "In the index.html file."
      ],
      "correct": [1],
      "explanation": "configureStore simplifies store setup. It automatically adds the Redux DevTools extension and the 'thunk' middleware.",
      "interviewTip": "configureStore is the RTK replacement for the legacy createStore function."
    },
    {
      "id": "rtk-08",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What happens if a reducer is not a 'pure function' (e.g., it uses Math.random() or calls an API)?",
      "options": [
        "The code will fail to compile.",
        "State changes become unpredictable and debugging tools like DevTools will break.",
        "React will automatically fix the function.",
        "Redux will run the function in a separate thread."
      ],
      "correct": [1],
      "explanation": "Reducers must be deterministic. Given the same state and action, they must always return the same result. Side effects belong in thunks or middleware.",
      "interviewTip": "Reducers = 'Logic/Calculation'; Thunks = 'Side Effects/Asynchronous work'."
    },
    {
      "id": "rtk-09",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "How do you access the 'payload' of an action inside a reducer?",
      "code": "incrementByAmount: (state, action) => {\n  state.value += ________;\n}",
      "options": [
        "action.data",
        "action.payload",
        "action.value",
        "action.params"
      ],
      "correct": [1],
      "explanation": "In Redux Toolkit, the data sent with an action is automatically placed in the 'payload' property of the action object.",
      "interviewTip": "Example call: dispatch(incrementByAmount(10)) results in action.payload being 10."
    },
    {
      "id": "rtk-10",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "What is the purpose of the <Provider> component in Redux?",
      "options": [
        "To fetch data from the server.",
        "To wrap the React app and make the Redux store available to all components.",
        "To encrypt the state before it is saved.",
        "To manage the component's local state."
      ],
      "correct": [1],
      "explanation": "Just like Context API, the Redux Provider uses React's context mechanism to pass the store down to hooks like useSelector.",
      "interviewTip": "Usually, you wrap the <Provider> around the <App /> in your main entry file (index.js)."
    },
    {
      "id": "rtk-11",
      "stageId": "advanced_state_redux",
      "type": "multiple",
      "prompt": "Which of these are benefits of using Redux DevTools?",
      "options": [
        "Inspecting the history of every action dispatched.",
        "Editing the state in real-time to test UI changes.",
        "Automatically writing CSS for your components.",
        "Time-traveling to previous states."
      ],
      "correct": [0, 1, 3],
      "explanation": "DevTools provides a visual dashboard to see exactly how actions change the state, making debugging much easier.",
      "interviewTip": "Itâ€™s one of the strongest reasons to choose Redux for complex apps."
    },
    {
      "id": "rtk-12",
      "stageId": "advanced_state_redux",
      "type": "single",
      "prompt": "Identify the error in this selector usage:",
      "code": "const user = useSelector(state => state.users[0]);",
      "options": [
        "Selectors must be defined in a separate file.",
        "If state.users is undefined (e.g., during loading), the app will crash.",
        "useSelector cannot access arrays.",
        "The return value must be a string."
      ],
      "correct": [1],
      "explanation": "Always consider the initial state. If the data hasn't loaded yet, accessing an index of an empty/undefined list will throw an error.",
      "interviewTip": "Use optional chaining: state.users?.[0]."
    }
  ]
}
