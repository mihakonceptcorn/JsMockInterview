{
  "default": [
    {
      "id": "gh-01",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "Why is 'react-native-gesture-handler' preferred over the built-in PanResponder?",
      "options": [
        "It supports more colors",
        "It runs gesture logic on the native thread, ensuring smoothness even when JS is busy",
        "It is easier to install",
        "It works only on iOS"
      ],
      "correct": [1],
      "explanation": "PanResponder runs on the JS thread. If the JS thread lags, your gesture will 'stutter'. RNGH moves that logic to the native side.",
      "interviewTip": "Always mention 'Native Thread execution' as the key performance benefit."
    },
    {
      "id": "gh-02",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "Which component is used to detect a simple tap gesture in RNGH?",
      "options": [
        "<TapGestureHandler>",
        "<TouchDetector>",
        "<PressHandler>",
        "<ClickEvent>"
      ],
      "correct": [0],
      "explanation": "TapGestureHandler is the specific component for detecting discrete taps.",
      "interviewTip": "You can configure 'numberOfTaps' to detect double or triple taps easily."
    },
    {
      "id": "gh-03",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "Which handler would you use to build a 'draggable' component or a swipeable drawer?",
      "options": [
        "<FlingGestureHandler>",
        "<PanGestureHandler>",
        "<RotationGestureHandler>",
        "<LongPressGestureHandler>"
      ],
      "correct": [1],
      "explanation": "PanGestureHandler tracks the movement of a finger across the screen (panning/dragging).",
      "interviewTip": "It provides translationX and translationY values, which represent how far the finger has moved from the start point."
    },
    {
      "id": "gh-04",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What does the 'State' object in Gesture Handler represent?",
      "options": [
        "The React component state",
        "The current lifecycle of a gesture (e.g., BEGAN, ACTIVE, ENDED)",
        "The battery level of the device",
        "The navigation state"
      ],
      "correct": [1],
      "explanation": "Gestures move through states. Understanding when a gesture is 'ACTIVE' vs 'ENDED' is crucial for triggering the right logic.",
      "interviewTip": "Use State.END to trigger a 'snap back' animation or a final action after a swipe."
    },
    {
      "id": "gh-05",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "How do you handle 'Pinch-to-Zoom' functionality?",
      "options": [
        "<ZoomHandler>",
        "<PinchGestureHandler>",
        "<ScaleDetector>",
        "<TwoFingerHandler>"
      ],
      "correct": [1],
      "explanation": "PinchGestureHandler tracks the distance between two fingers to calculate a 'scale' factor.",
      "interviewTip": "This is typically combined with a transform style to zoom into images or maps."
    },
    {
      "id": "gh-06",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What is the purpose of the <GestureHandlerRootView>?",
      "options": [
        "To provide a background color",
        "To wrap the app and ensure gestures are captured correctly on Android",
        "To speed up images",
        "To manage the status bar"
      ],
      "correct": [1],
      "explanation": "On Android, RNGH requires the root of your app (or the interactive area) to be wrapped in this component to intercept touch events.",
      "interviewTip": "If your gestures aren't working on Android, checking for this root wrapper is the first step."
    },
    {
      "id": "gh-07",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "How do you handle a conflict where two gestures are detected at once (e.g., a Swipe inside a ScrollView)?",
      "options": [
        "React Native handles this automatically",
        "Use 'simultaneousHandlers' or 'waitFor' props to define priority",
        "Delete one of the gestures",
        "It is impossible to have two gestures together"
      ],
      "correct": [1],
      "explanation": "RNGH allows you to explicitly state that one gesture should wait for another to fail, or that they should work at the same time.",
      "interviewTip": "This is called 'Gesture Orchestration'."
    },
    {
      "id": "gh-08",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What is 'Velocity' in a Pan gesture?",
      "options": [
        "The distance moved",
        "The speed at which the finger is moving at a specific moment",
        "The total time the finger was on screen",
        "The pressure of the touch"
      ],
      "correct": [1],
      "explanation": "Velocity is useful for 'flinging' animationsâ€”if a user swipes quickly, the object should keep moving after they let go.",
      "interviewTip": "Combining velocity with a 'decay' animation makes the UI feel very realistic."
    },
    {
      "id": "gh-09",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "Which RNGH component is a 'native' drop-in replacement for ScrollView that works better with gestures?",
      "options": [
        "<NativeScrollView>",
        "<GestureScrollView>",
        "<NativeViewGestureHandler> wrapping a ScrollView",
        "<FastScroll>"
      ],
      "correct": [2],
      "explanation": "NativeViewGestureHandler allows standard native components (like ScrollView) to play nicely with other RNGH handlers.",
      "interviewTip": "Often used when you want a 'bottom sheet' to scroll only when it has reached the top of the screen."
    },
    {
      "id": "gh-10",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What does 'failOffsetX' prop do in a PanGestureHandler?",
      "options": [
        "Calculates the error margin",
        "Defines how far a finger can move horizontally before the gesture fails",
        "Sets the coordinate to 0",
        "Makes the gesture slower"
      ],
      "correct": [1],
      "explanation": "This allows you to 'fine-tune' sensitivity. For example, if you have a vertical list, you might want a horizontal pan to 'fail' immediately so it doesn't block the scroll.",
      "interviewTip": "This is vital for UX to ensure 'accidental' tiny movements don't trigger the wrong actions."
    },
    {
      "id": "gh-11",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "In the new 'Gesture' API (RNGH v2), what is the function that defines a gesture?",
      "options": [
        "Gesture.Create()",
        "Gesture.Pan()",
        "Gesture.Detect()",
        "new PanGesture()"
      ],
      "correct": [1],
      "explanation": "V2 introduced a more declarative 'Builder' pattern, starting with Gesture object types like .Pan(), .Tap(), or .Pinch().",
      "interviewTip": "Mention that V2 is now the recommended way to write RNGH code as it is more readable and type-safe."
    },
    {
      "id": "gh-12",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What is a 'Fling' gesture?",
      "options": [
        "A long press",
        "A fast, short swipe in a specific direction",
        "Rotating two fingers",
        "A double tap"
      ],
      "correct": [1],
      "explanation": "FlingGestureHandler detects rapid movements in one of the four cardinal directions (up, down, left, right).",
      "interviewTip": "Great for 'Tinder-style' card swipes or dismissing photos."
    },
    {
      "id": "gh-13",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "How do you apply gesture data to a component's position using the old API?",
      "options": [
        "By updating a standard useState",
        "By using Animated.event with useNativeDriver",
        "By changing the props manually",
        "By calling re-render()"
      ],
      "correct": [1],
      "explanation": "You map the gesture's translation values to an Animated.Value using Animated.event to keep the interaction on the native thread.",
      "interviewTip": "This is why RNGH and Animated API are usually studied together."
    },
    {
      "id": "gh-14",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What does 'enabled' prop do?",
      "options": [
        "Changes the color of the handler",
        "Turns the gesture detection on or off",
        "Starts the animation",
        "Logs the gesture data"
      ],
      "correct": [1],
      "explanation": "You can dynamically enable/disable gestures based on app state (e.g., disable swiping when a modal is open).",
      "interviewTip": "Useful for preventing 'ghost touches' in complex UIs."
    },
    {
      "id": "gh-15",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "Which RNGH component provides a cross-platform way to handle 'Rectangular' buttons with native ripple/highlight effects?",
      "options": [
        "<RectButton>",
        "<NativeButton>",
        "<GestureButton>",
        "<TouchableHandler>"
      ],
      "correct": [0],
      "explanation": "RectButton and BorderlessButton are optimized buttons provided by RNGH that automatically use the best native feedback for each platform.",
      "interviewTip": "Use BorderlessButton for icons and RectButton for rows/standard buttons."
    },
    {
      "id": "gh-16",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What is the 'activeOffsetX' prop used for?",
      "options": [
        "To set the width of the component",
        "To define the horizontal distance the finger must travel before the gesture becomes 'ACTIVE'",
        "To offset the image",
        "To move the component to the X coordinate"
      ],
      "correct": [1],
      "explanation": "This prevents 'jitter'. The gesture won't start until the user has moved their finger significantly (e.g., 10-20 pixels).",
      "interviewTip": "This distinguishes between a 'tap' (stationary) and a 'pan' (movement)."
    },
    {
      "id": "gh-17",
      "stageId": "gesture_handler",
      "type": "single",
      "prompt": "What is the 'GestureDetector' in RNGH v2?",
      "options": [
        "A component that wraps your UI and applies the gesture configuration",
        "A tool for debugging touches",
        "A native module for Android",
        "A hook to access touch coordinates"
      ],
      "correct": [0],
      "explanation": "GestureDetector is the main component in the new API that takes a gesture object and applies it to its children.",
      "interviewTip": "One GestureDetector can handle multiple composed gestures (e.g., Pan AND Pinch simultaneously)."
    }
  ]
}
