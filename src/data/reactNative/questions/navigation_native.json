{
  "default": [
    {
      "id": "nav-01",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is the industry-standard library for handling navigation in React Native?",
      "options": [
        "React Router Native",
        "React Navigation",
        "Native Router",
        "Expo Router (built on React Navigation)"
      ],
      "correct": [1],
      "explanation": "React Navigation is the most widely used community-led library for routing and navigation in React Native apps.",
      "interviewTip": "Mention that while React Navigation is the standard, Expo Router is a newer file-based alternative built on top of it."
    },
    {
      "id": "nav-02",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which component must wrap your entire app to manage the navigation tree?",
      "options": [
        "<NavigationProvider>",
        "<NavigationContainer>",
        "<BrowserRouter>",
        "<AppRouter>"
      ],
      "correct": [1],
      "explanation": "NavigationContainer manages the navigation state and links the top-level navigator to the app environment.",
      "interviewTip": "This component is usually placed at the root of the app, just like a Redux Provider."
    },
    {
      "id": "nav-03",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which navigator pattern mimics a deck of cards, where new screens are pushed on top?",
      "options": [
        "Bottom Tab Navigator",
        "Drawer Navigator",
        "Stack Navigator",
        "Switch Navigator"
      ],
      "correct": [2],
      "explanation": "Stack Navigator provides a way for your app to transition between screens where each new screen is placed on top of a stack.",
      "interviewTip": "Native behavior (like the back button or swipe-to-go-back) is handled automatically by the Stack Navigator."
    },
    {
      "id": "nav-04",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you move to a new screen programmatically using the navigation prop?",
      "options": [
        "navigation.push('ScreenName')",
        "navigation.navigate('ScreenName')",
        "navigation.goTo('ScreenName')",
        "navigation.link('ScreenName')"
      ],
      "correct": [1],
      "explanation": "The navigate method is the primary way to move between screens. It intelligently decides whether to push a new screen or go back to an existing one.",
      "interviewTip": "If you want to force a new screen onto the stack even if it's already there (like a profile within a profile), use .push()."
    },
    {
      "id": "nav-05",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you pass data (parameters) to a screen when navigating?",
      "options": [
        "navigation.navigate('Details', { id: 123 })",
        "navigation.navigate('Details', id=123)",
        "Pass it via Redux only",
        "navigation.setParams({ id: 123 })"
      ],
      "correct": [0],
      "explanation": "The second argument of the navigate function is an object containing 'params' that the destination screen can access.",
      "interviewTip": "Keep params small. Pass an ID, not a whole user object, to avoid performance and synchronization issues."
    },
    {
      "id": "nav-06",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which hook is used to access the parameters passed to a screen?",
      "options": [
        "useNavigation",
        "useParams",
        "useRoute",
        "useNavigationState"
      ],
      "correct": [2],
      "explanation": "useRoute returns the route object for the current screen, which contains the 'params' object.",
      "interviewTip": "Example: const { id } = route.params;"
    },
    {
      "id": "nav-07",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is the purpose of 'Bottom Tab Navigation'?",
      "options": [
        "To show a sidebar menu",
        "To provide a persistent menu at the bottom of the screen for top-level navigation",
        "To handle the back button",
        "To show a popup modal"
      ],
      "correct": [1],
      "explanation": "Tab navigation is the most common pattern for switching between main app sections (Home, Search, Profile).",
      "interviewTip": "Tabs usually persist their state, so switching back and forth doesn't 'reset' the screen."
    },
    {
      "id": "nav-08",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you go back to the previous screen?",
      "options": [
        "navigation.back()",
        "navigation.goBack()",
        "navigation.pop()",
        "navigation.previous()"
      ],
      "correct": [1],
      "explanation": "goBack() is the standard method to remove the current screen from the stack and return to the previous one.",
      "interviewTip": "Stack-specific navigators also offer .pop() to remove a specific number of screens."
    },
    {
      "id": "nav-09",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What does 'navigation.reset()' do?",
      "options": [
        "Clears the app cache",
        "Wipes the entire navigation state and replaces it with a new one",
        "Restarts the app",
        "Goes back to the Home screen"
      ],
      "correct": [1],
      "explanation": "Resetting the state is useful after a login or logout, where you want to prevent the user from going 'back' to the auth screen.",
      "interviewTip": "Always use reset() for login/logout flows for better security and UX."
    },
    {
      "id": "nav-10",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which prop is used to customize the header title or back button style in a screen?",
      "options": ["headerConfig", "options", "screenProps", "layout"],
      "correct": [1],
      "explanation": "The 'options' prop on a Screen or Navigator defines visual elements like titles, colors, and custom buttons.",
      "interviewTip": "You can define options statically or dynamically based on the screen's props."
    },
    {
      "id": "nav-11",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is 'Nested Navigation'?",
      "options": [
        "Rendering a navigator inside the screen of another navigator",
        "Passing a navigator as a prop",
        "Creating a loop of screens",
        "Navigation within a single view"
      ],
      "correct": [0],
      "explanation": "A common pattern is having a Stack Navigator inside a Tab Navigator (or vice versa) to build complex app structures.",
      "interviewTip": "Keep nesting shallow. Deep nesting (more than 2-3 levels) can make state management and debugging difficult."
    },
    {
      "id": "nav-12",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is the purpose of 'Deep Linking' in mobile apps?",
      "options": [
        "To link two different databases",
        "To open the app to a specific screen via a URL (e.g., from an email)",
        "To perform deep data analysis",
        "To connect to a VPN"
      ],
      "correct": [1],
      "explanation": "Deep linking allows external URLs to trigger the app to open and navigate to a specific path/resource.",
      "interviewTip": "React Navigation handles this through a 'linking' configuration object passed to NavigationContainer."
    },
    {
      "id": "nav-13",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which hook provides the navigation object to any nested component without passing it through props?",
      "options": ["useRoute", "useNavigation", "useLink", "useAppState"],
      "correct": [1],
      "explanation": "useNavigation is a hook that gives access to the navigation object in any functional component inside the NavigationContainer.",
      "interviewTip": "This is perfect for custom Header components or utility buttons."
    },
    {
      "id": "nav-14",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you handle a physical back button press on Android in React Navigation?",
      "options": [
        "It is handled automatically by the Stack Navigator",
        "You must write a manual listener for every screen",
        "Use the useBackHandler hook",
        "Android doesn't have a back button anymore"
      ],
      "correct": [0],
      "explanation": "React Navigation integrates with the platform's back button behavior by default, popping the stack as expected.",
      "interviewTip": "If you need to *prevent* the user from going back (like in a form), you can use the 'beforeRemove' event."
    },
    {
      "id": "nav-15",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is the difference between @react-navigation/native-stack and @react-navigation/stack?",
      "options": [
        "native-stack uses native OS components for higher performance",
        "stack is newer and better",
        "native-stack only works on iOS",
        "There is no difference"
      ],
      "correct": [0],
      "explanation": "native-stack leverages the native APIs for transitions (UINavigationController on iOS and Fragment on Android), making it more performant and 'native-feeling'.",
      "interviewTip": "Always prefer native-stack unless you need high customization that native APIs don't support."
    },
    {
      "id": "nav-16",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which life-cycle hook/event is triggered when a screen comes into focus?",
      "options": ["useEffect", "useFocusEffect", "onAppear", "onMount"],
      "correct": [1],
      "explanation": "useFocusEffect runs every time the screen is focused, which is useful for refreshing data. Standard useEffect only runs on mount.",
      "interviewTip": "This is critical because in Tabs, screens don't unmount when you switch away; they just lose focus."
    },
    {
      "id": "nav-17",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you open a Modal screen using React Navigation?",
      "options": [
        "Set the 'presentation' option to 'modal' in a Stack Navigator",
        "Use the <Modal> component from React Native",
        "Modals are not supported in navigation",
        "Use a separate Navigator just for modals"
      ],
      "correct": [0],
      "explanation": "In v6+, you can set 'presentation: \"modal\"' in the screen options to make it slide up from the bottom (iOS style).",
      "interviewTip": "This is preferred over the RN <Modal> because it integrates with the navigation history."
    }
  ]
}
