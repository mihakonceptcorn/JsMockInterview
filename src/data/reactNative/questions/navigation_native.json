{
  "default": [
    {
      "id": "nav-01",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which navigator should you use for a standard 'push/pop' transition where a new screen slides over the previous one?",
      "options": [
        "Tab Navigator",
        "Stack Navigator",
        "Drawer Navigator",
        "Switch Navigator"
      ],
      "correct": [1],
      "explanation": "Stack Navigator provides a way for your app to transition between screens where each new screen is placed on top of a stack.",
      "interviewTip": "In modern React Navigation, use '@react-navigation/native-stack' for better performance as it uses native OS primitives."
    },
    {
      "id": "nav-02",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you navigate to a specific screen named 'Details' and pass a parameter 'itemId'?",
      "code": "const navigation = useNavigation();\n\n// Which call is correct?\nnavigation.________('Details', { itemId: 42 });",
      "options": ["push", "navigate", "jumpTo", "goTo"],
      "correct": [1],
      "explanation": "The 'navigate' function is the most common way to move between screens. The second argument is an object containing 'params'.",
      "interviewTip": "Note the difference: 'navigate' will go back to an existing screen in the stack, while 'push' will always add a new instance even if it's the same screen."
    },
    {
      "id": "nav-03",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you retrieve the 'itemId' parameter in the 'Details' screen component?",
      "code": "function DetailsScreen({ ________ }) {\n  const { itemId } = ________.params;\n  return <Text>{itemId}</Text>;\n}",
      "options": ["navigation", "route", "params", "props"],
      "correct": [1],
      "explanation": "Every screen component in a navigator receives a 'route' prop containing information about the current route, including 'params'.",
      "interviewTip": "You can also use the 'useRoute' hook to access this information anywhere in the component tree."
    },
    {
      "id": "nav-04",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is the purpose of the <NavigationContainer> component?",
      "options": [
        "It acts as a wrapper for the entire app to manage the navigation state and link your app to the device's environment.",
        "It is used to create a sidebar menu.",
        "It automatically handles API calls between screens.",
        "It is only required for Tab navigation."
      ],
      "correct": [0],
      "explanation": "NavigationContainer must wrap your entire application structure. It manages the app state and handles deep linking.",
      "interviewTip": "You should only have one NavigationContainer in your entire app."
    },
    {
      "id": "nav-05",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which hook is used to perform a 'go back' action programmatically?",
      "code": "const navigation = ________();\nreturn <Button onPress={() => navigation.goBack()} />;",
      "options": ["useRoute", "useNavigation", "useHistory", "useStack"],
      "correct": [1],
      "explanation": "useNavigation provides access to the navigation object within any nested component, allowing actions like 'goBack' or 'navigate'.",
      "interviewTip": "This is much cleaner than passing the navigation prop manually through several layers of components."
    },
    {
      "id": "nav-06",
      "stageId": "navigation_native",
      "type": "multiple",
      "prompt": "Which of the following are common types of navigators in the React Navigation ecosystem?",
      "options": [
        "createNativeStackNavigator",
        "createBottomTabNavigator",
        "createDrawerNavigator",
        "createModalNavigator"
      ],
      "correct": [0, 1, 2],
      "explanation": "React Navigation provides specific packages for Stack, Tabs, and Drawers. Modals are typically handled as a 'presentation' mode within a Stack.",
      "interviewTip": "Mention 'createNativeStackNavigator' specifically for its performance benefits on iOS and Android."
    },
    {
      "id": "nav-07",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What does 'navigation.replace('Home')' do?",
      "options": [
        "It adds 'Home' on top of the current screen.",
        "It removes the current screen from the stack and adds 'Home' in its place.",
        "It refreshes the current screen.",
        "It closes the app and reopens the Home screen."
      ],
      "correct": [1],
      "explanation": "Replace is useful for login flows; once a user logs in, you replace the Login screen with Home so they can't 'go back' to the login form.",
      "interviewTip": "Use this to prevent 'infinite' back loops in your app's history."
    },
    {
      "id": "nav-08",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you change the title of a screen in the navigation header?",
      "code": "<Stack.Screen \n  name='Profile' \n  component={Profile} \n  options={{ ________: 'My Profile' }}\n/>",
      "options": ["header", "label", "title", "name"],
      "correct": [2],
      "explanation": "The 'options' prop (specifically the 'title' field) controls how the screen appears in the UI of the navigator (header text, tab label).",
      "interviewTip": "You can also set these dynamically from within the component using 'navigation.setOptions'."
    },
    {
      "id": "nav-09",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is 'Deep Linking' in the context of mobile navigation?",
      "options": [
        "Linking the app to a deep database.",
        "A way to open a specific screen in your app using a URL (e.g., myapp://details/42).",
        "A method to link two components deeply in the tree.",
        "Connecting the app to the device's file system."
      ],
      "correct": [1],
      "explanation": "Deep linking allows external sources (websites, emails, notifications) to trigger navigation to a specific nested screen within your app.",
      "interviewTip": "Implementing deep linking requires configuring a 'linking' object and passing it to the <NavigationContainer>."
    },
    {
      "id": "nav-10",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you detect when a screen has come into focus (becomes visible to the user)?",
      "options": [
        "Using useEffect with no dependencies.",
        "Using the 'useFocusEffect' hook or the 'focus' event listener.",
        "Checking window.isVisible.",
        "React Native handles this automatically with 'onFocus' prop."
      ],
      "correct": [1],
      "explanation": "Since screens in a stack stay 'mounted' even when hidden, standard useEffect doesn't trigger when you return to a screen. 'useFocusEffect' is the React Navigation solution.",
      "interviewTip": "This is essential for refreshing data when a user navigates back to a screen."
    },
    {
      "id": "nav-11",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What happens if you call 'navigation.popToTop()'?",
      "options": [
        "It reloads the current screen.",
        "It goes back one screen.",
        "It dismisses all screens in the stack except the very first one (the root).",
        "It takes the user to the phone's home screen."
      ],
      "correct": [2],
      "explanation": "This is a convenience method in Stack navigators to instantly 'reset' the navigation history and return to the starting screen.",
      "interviewTip": "This is commonly used for 'Home' buttons or finishing a multi-step checkout process."
    },
    {
      "id": "nav-12",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "How do you hide the header for a specific screen?",
      "code": "<Stack.Screen \n  name='Home' \n  component={HomeScreen} \n  options={{ ________: false }}\n/>",
      "options": ["headerShown", "hideHeader", "noHeader", "displayHeader"],
      "correct": [0],
      "explanation": "headerShown: false is the standard option to remove the default navigation bar for that specific screen.",
      "interviewTip": "You might do this if you are building a custom header or for a splash screen."
    },
    {
      "id": "nav-13",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "What is 'Tab Nesting'?",
      "options": [
        "Putting a Stack Navigator inside a Tab of a Tab Navigator.",
        "Putting two Tab Navigators on the same screen.",
        "Creating multiple navigation containers.",
        "Using Tabs only on iOS."
      ],
      "correct": [0],
      "explanation": "Nesting allows you to have a Bottom Tab bar globally, but each tab can have its own independent history stack (e.g., Home -> Product Details).",
      "interviewTip": "Be careful with deep nesting; it can make the navigation state complex and harder to debug."
    },
    {
      "id": "nav-14",
      "stageId": "navigation_native",
      "type": "single",
      "prompt": "Which prop allows you to customize the icon in a Bottom Tab Navigator?",
      "options": ["tabIcon", "tabBarIcon", "iconName", "renderIcon"],
      "correct": [1],
      "explanation": "tabBarIcon is a function that returns a component (usually an icon) to be displayed in the tab bar.",
      "interviewTip": "The function receives { focused, color, size } as arguments to help you style the active vs inactive state."
    }
  ]
}
