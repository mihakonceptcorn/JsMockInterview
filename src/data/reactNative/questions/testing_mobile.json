{
  "default": [
    {
      "id": "tm-01",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "Which testing framework is the default choice for React Native projects (and used by Jest)?",
      "options": ["Mocha", "Jest", "Cypress", "Jasmine"],
      "correct": [1],
      "explanation": "Jest is the most popular testing framework for React and React Native, offering built-in mocking, assertions, and code coverage.",
      "interviewTip": "Mention that Jest is maintained by Meta, just like React Native, ensuring great compatibility."
    },
    {
      "id": "tm-02",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is the primary library used for testing React Native components in an isolated way?",
      "options": [
        "Enzyme",
        "React Native Testing Library (RNTL)",
        "Appium",
        "Selenium"
      ],
      "correct": [1],
      "explanation": "RNTL is the standard for component testing, encouraging tests that simulate how a user interacts with the app rather than implementation details.",
      "interviewTip": "The core philosophy is: 'The more your tests resemble the way your software is used, the more confidence they can give you.'"
    },
    {
      "id": "tm-03",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is a 'Snapshot Test'?",
      "options": [
        "A photo of the developer",
        "A test that compares the rendered component tree to a stored reference file to detect UI changes",
        "A quick performance check",
        "A test for the app's camera features"
      ],
      "correct": [1],
      "explanation": "Jest captures the structure of your component and saves it. If the UI changes later, the test fails, prompting you to either fix the code or update the snapshot.",
      "interviewTip": "Snapshots are great for catching accidental UI regressions but can be brittle if overused."
    },
    {
      "id": "tm-04",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is 'Detox' in the context of React Native?",
      "options": [
        "A way to clean the app's code",
        "A gray-box End-to-End (E2E) testing framework specifically for mobile",
        "A tool for removing unused dependencies",
        "An animation library"
      ],
      "correct": [1],
      "explanation": "Detox runs your app on a real simulator/emulator and interacts with it like a user, verifying that the entire flow (JS + Native) works.",
      "interviewTip": "Detox is faster and more stable than Appium for RN because it is 'synchronized' with the app's internal state."
    },
    {
      "id": "tm-05",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "How do you simulate a button press in React Native Testing Library?",
      "options": [
        "button.click()",
        "fireEvent.press(button)",
        "button.trigger('tap')",
        "simulate(button, 'press')"
      ],
      "correct": [1],
      "explanation": "The fireEvent utility is used to trigger events like press, changeText, or scroll on components.",
      "interviewTip": "Always prefer fireEvent over calling the prop (e.g., onPress) directly, as it better simulates real interaction."
    },
    {
      "id": "tm-06",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What does 'Mocking' an API mean?",
      "options": [
        "Making fun of a bad API",
        "Replacing a real API call with a fake function that returns predictable data",
        "Encrypting the API request",
        "Running the API on a local server"
      ],
      "correct": [1],
      "explanation": "Mocking ensures your tests are fast, don't require internet, and don't change real data on the server.",
      "interviewTip": "Use `jest.mock()` for modules or `msw` (Mock Service Worker) for network-level mocking."
    },
    {
      "id": "tm-07",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "Which RNTL query should be used to find an element by the text it displays?",
      "options": ["getByTestId", "getByText", "getById", "findViewById"],
      "correct": [1],
      "explanation": "getByText is preferred because it tests what the user actually sees on the screen.",
      "interviewTip": "If text is dynamic or hard to find, 'testID' (getByTestId) is the second-best option for mobile."
    },
    {
      "id": "tm-08",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is the 'testID' prop used for?",
      "options": [
        "Storing the user's ID",
        "Providing a unique identifier for components to be easily found by testing tools like Detox or RNTL",
        "Debugging CSS styles",
        "A required prop for all View components"
      ],
      "correct": [1],
      "explanation": "It's a non-visual prop that acts like a 'hook' for automation and testing scripts.",
      "interviewTip": "Ensure you strip testIDs from production builds to keep the bundle size smaller and cleaner."
    },
    {
      "id": "tm-09",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is the 'Act' warning in React Native tests?",
      "options": [
        "A warning that the developer is acting too much",
        "A warning that a state update happened outside of the expected testing flow",
        "An error when the app crashes",
        "A performance warning"
      ],
      "correct": [1],
      "explanation": "It tells you that something happened (like an async update) that your test didn't account for. You usually need to wrap the interaction in `act()` or use `waitFor`.",
      "interviewTip": "This is often fixed by using the asynchronous 'find' queries (e.g., `findByText`) instead of 'get' queries."
    },
    {
      "id": "tm-10",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "How do you test a component that uses a Hook like 'useNavigation'?",
      "options": [
        "Hooks cannot be tested",
        "By mocking the navigation library or using a Mock Navigation Wrapper",
        "By running the test on a real phone",
        "By rewriting the hook as a class"
      ],
      "correct": [1],
      "explanation": "Since the component depends on a Navigation Context, you must provide a mock of that context so the component doesn't crash during the test.",
      "interviewTip": "Creating a 'renderWithProviders' utility function is a standard practice for apps with Navigation, Redux, and Themes."
    },
    {
      "id": "tm-11",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is 'Code Coverage'?",
      "options": [
        "The number of lines of code in the app",
        "A metric that shows what percentage of your code is exercised by tests",
        "A way to hide code from others",
        "A security feature"
      ],
      "correct": [1],
      "explanation": "It helps you find 'dark corners' of your app that aren't being tested. Aim for high coverage in business logic.",
      "interviewTip": "100% coverage doesn't mean 0% bugs. Focus on 'Quality' of tests over 'Quantity'."
    },
    {
      "id": "tm-12",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is the difference between 'queryBy', 'getBy', and 'findBy' in RNTL?",
      "options": [
        "They are the same",
        "getBy fails if not found; queryBy returns null; findBy is asynchronous",
        "findBy is for images only",
        "queryBy is faster than getBy"
      ],
      "correct": [1],
      "explanation": "Use 'getBy' for things that should be there; 'queryBy' for checking that something *isn't* there; and 'findBy' for things that appear after an API call.",
      "interviewTip": "Understanding these three is the key to writing stable, non-flaky tests."
    },
    {
      "id": "tm-13",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "Why is 'Appium' different from 'Detox'?",
      "options": [
        "Appium is only for web",
        "Appium is a black-box tester (no access to app internals); Detox is gray-box (synchronized with the app)",
        "Appium is faster",
        "Detox doesn't work on Android"
      ],
      "correct": [1],
      "explanation": "Appium works by sending commands to the OS. Detox 'waits' for the app to be idle (no active timers or network calls), making it much less flaky.",
      "interviewTip": "Appium is better if you need to test 'Cross-App' flows (e.g., opening a link in Safari and coming back)."
    },
    {
      "id": "tm-14",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "How do you test a 'useEffect' that triggers on mount?",
      "options": [
        "It is tested automatically by render()",
        "You must call the effect manually",
        "Using a setTimeout",
        "By checking if the cleanup function runs"
      ],
      "correct": [0],
      "explanation": "The render function from RNTL triggers the mounting phase, which naturally executes the useEffect hook.",
      "interviewTip": "If the effect is asynchronous, you'll need to use `waitFor` or `findBy` to assert the final state."
    },
    {
      "id": "tm-15",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is 'Regression Testing'?",
      "options": [
        "Testing the app on older phones",
        "Re-running tests to ensure that new code hasn't broken existing functionality",
        "A way to delete old code",
        "Testing the app in different languages"
      ],
      "correct": [1],
      "explanation": "It's the main reason for having an automated test suiteâ€”so you can change code with confidence.",
      "interviewTip": "A good CI/CD pipeline runs regression tests on every Pull Request."
    },
    {
      "id": "tm-16",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What is 'Manual Testing' and why is it still needed?",
      "options": [
        "It is no longer needed",
        "Testing by a human to check for UX feel, visual glitches, and real-world edge cases",
        "A way to write tests by hand",
        "Testing the physical phone buttons only"
      ],
      "correct": [1],
      "explanation": "Automation is great for logic, but a human is best at judging if an animation feels 'smooth' or if a button is too small to tap easily.",
      "interviewTip": "Automation covers 'Correctness'; Manual covers 'Experience'."
    },
    {
      "id": "tm-17",
      "stageId": "testing_mobile",
      "type": "single",
      "prompt": "What does `jest.useFakeTimers()` do?",
      "options": [
        "Speeds up the clock on the phone",
        "Allows you to control and 'fast-forward' time to test things like `setTimeout` or `setInterval` without waiting",
        "Creates a fake clock on the screen",
        "Stops all timers in the app"
      ],
      "correct": [1],
      "explanation": "If you have a 10-second timer, your test shouldn't wait 10 seconds. Fake timers let you 'skip' ahead instantly.",
      "interviewTip": "Always remember to `jest.useRealTimers()` after the test if needed to avoid affecting other tests."
    }
  ]
}
