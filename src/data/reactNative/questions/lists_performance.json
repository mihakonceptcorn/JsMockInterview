{
  "default": [
    {
      "id": "lp-01",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "Why is using .map() to render a long list of items problematic in React Native?",
      "options": [
        "It doesn't support styling",
        "It renders all items at once, which can lead to high memory usage and crashes",
        "It only works with Text components",
        "It is deprecated in React Native"
      ],
      "correct": [1],
      "explanation": "Standard mapping renders everything immediately. If you have 1,000 items, 1,000 native views are created, overwhelming the UI thread.",
      "interviewTip": "Always mention 'Virtualization' as the solution to this problem."
    },
    {
      "id": "lp-02",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What is the primary function of the 'renderItem' prop in FlatList?",
      "options": [
        "To define the overall style of the list",
        "A function that takes an item from data and returns a component to render",
        "To filter the data before showing it",
        "To handle the pull-to-refresh logic"
      ],
      "correct": [1],
      "explanation": "renderItem is the callback where you define what each individual row in your list looks like.",
      "interviewTip": "For better performance, define this function outside of the component or use useCallback to prevent re-creating it on every render."
    },
    {
      "id": "lp-03",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What does 'keyExtractor' do in a FlatList?",
      "options": [
        "It extracts the text from each item",
        "It provides a unique ID for each item to help React identify changes efficiently",
        "It unlocks the list for editing",
        "It is used for searching through the list"
      ],
      "correct": [1],
      "explanation": "Similar to the 'key' prop in React Web, keyExtractor helps FlatList track which items are added, removed, or changed.",
      "interviewTip": "If your data has an 'id' or 'uuid', use that. Avoid using the index as a key if the list can be reordered."
    },
    {
      "id": "lp-04",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "Which prop should you use to add a gap between list items without adding margins to the items themselves?",
      "options": [
        "ItemSeparatorComponent",
        "ListHeaderComponent",
        "spacer",
        "divider"
      ],
      "correct": [0],
      "explanation": "ItemSeparatorComponent renders a component between every item, but importantly, NOT at the top or bottom of the list.",
      "interviewTip": "This is cleaner than using margins because it avoids extra space at the very start or end of the scrollable area."
    },
    {
      "id": "lp-05",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What is the benefit of providing the 'getItemLayout' prop?",
      "options": [
        "It makes the list items look prettier",
        "It allows FlatList to skip dynamic measurement of items, significantly improving scroll performance",
        "It is required for horizontal lists",
        "It enables multi-column layouts"
      ],
      "correct": [1],
      "explanation": "If you know the height of your items beforehand, getItemLayout lets the list calculate positions instantly instead of measuring them as they appear.",
      "interviewTip": "This is one of the biggest performance wins for lists with fixed-height rows."
    },
    {
      "id": "lp-06",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "How do you implement 'Pull-to-Refresh' in a FlatList?",
      "options": [
        "By adding a Button at the top",
        "Using the 'onRefresh' and 'refreshing' props",
        "By shaking the phone",
        "React Native handles this automatically"
      ],
      "correct": [1],
      "explanation": "You pass a boolean to 'refreshing' (to show the spinner) and a function to 'onRefresh' to fetch new data.",
      "interviewTip": "The native 'RefreshControl' component is what actually powers this behind the scenes."
    },
    {
      "id": "lp-07",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What is the 'windowSize' prop used for?",
      "options": [
        "To set the width of the list",
        "To control the number of items rendered outside of the visible area (off-screen)",
        "To change the font size of the list",
        "To limit the total number of items in the list"
      ],
      "correct": [1],
      "explanation": "A larger windowSize renders more items ahead of time, reducing 'white flashes' during fast scrolling, but uses more memory.",
      "interviewTip": "The default is 21 (10 screen heights above, 10 below, and 1 for the current screen)."
    },
    {
      "id": "lp-08",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "Which component is better suited for a list that needs to show group headers (e.g., Contacts by letter)?",
      "options": ["<FlatList>", "<ScrollView>", "<SectionList>", "<GroupList>"],
      "correct": [2],
      "explanation": "SectionList is designed for categorized data and supports 'sticky' section headers that stay at the top as you scroll.",
      "interviewTip": "SectionList requires a 'sections' prop with an array of objects like { title: 'A', data: [...] }."
    },
    {
      "id": "lp-09",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "How do you render a list in multiple columns (like a photo grid)?",
      "options": [
        "Wrap the list in a View with flexDirection: 'row'",
        "Use the 'numColumns' prop in FlatList",
        "Use a SectionList with columns: 2",
        "FlatList doesn't support columns"
      ],
      "correct": [1],
      "explanation": "Setting 'numColumns={2}' will automatically arrange the items in a grid.",
      "interviewTip": "Note that numColumns cannot be changed dynamically without re-mounting the list (changing the 'key' prop of the FlatList)."
    },
    {
      "id": "lp-10",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What does the 'initialNumToRender' prop do?",
      "options": [
        "Sets the total number of items the list can ever hold",
        "Determines how many items are rendered in the first batch to improve perceived load time",
        "Changes the index of the first item shown",
        "Limits the list to only show X items"
      ],
      "correct": [1],
      "explanation": "It helps the list appear faster by rendering just enough items to fill the screen initially.",
      "interviewTip": "Set this to exactly enough items to fill the initial screen for the best balance of speed and memory."
    },
    {
      "id": "lp-11",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What happens if you use a very complex component as a list item?",
      "options": [
        "The list will look better",
        "Frame rates may drop during scrolling because the JS thread is busy rendering",
        "React Native will automatically optimize it",
        "It will use less battery"
      ],
      "correct": [1],
      "explanation": "Scrolling requires fast rendering. If each item is 'heavy,' the app won't be able to render them fast enough to maintain 60 FPS.",
      "interviewTip": "Keep list items 'thin' and use React.memo to prevent unnecessary re-renders of rows."
    },
    {
      "id": "lp-12",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What is the purpose of 'onEndReached'?",
      "options": [
        "To show a 'The End' message",
        "To trigger a function (like fetching more data) when the user scrolls near the bottom",
        "To stop the user from scrolling further",
        "To scroll back to the top"
      ],
      "correct": [1],
      "explanation": "This is the core of 'Infinite Scroll.' It allows you to load more data as the user reaches the end of the existing list.",
      "interviewTip": "Use 'onEndReachedThreshold' to define how far from the bottom (in screen heights) the event should fire."
    },
    {
      "id": "lp-13",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "How do you show a message when the list is completely empty?",
      "options": [
        "Check data.length and return a separate View",
        "Use the 'ListEmptyComponent' prop",
        "FlatList does this automatically",
        "Use the 'placeholder' prop"
      ],
      "correct": [1],
      "explanation": "ListEmptyComponent is a convenient prop that renders only when the 'data' array is empty.",
      "interviewTip": "This is better than manual ternary operators because it keeps the FlatList configuration self-contained."
    },
    {
      "id": "lp-14",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What is the 'removeClippedSubviews' prop used for?",
      "options": [
        "To delete items that are too long",
        "To unmount components that are far outside of the viewport to save memory",
        "To crop images in the list",
        "To hide the scroll bar"
      ],
      "correct": [1],
      "explanation": "It's a performance optimization that frees up native resources by not maintaining views for items far off-screen.",
      "interviewTip": "While powerful, use it carefully as it can occasionally cause bugs with certain component states."
    },
    {
      "id": "lp-15",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "In a SectionList, how do you make headers stay at the top as you scroll through that section?",
      "options": [
        "Set position: 'sticky' in CSS",
        "Use the 'stickySectionHeadersEnabled' prop",
        "It is the default behavior on all platforms",
        "SectionList doesn't support this"
      ],
      "correct": [1],
      "explanation": "On iOS, this is true by default. On Android, you may need to explicitly enable it or check version compatibility.",
      "interviewTip": "This UI pattern is often called 'Sticky Headers'."
    },
    {
      "id": "lp-16",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "Which 3rd-party library is often recommended for even better performance than FlatList for massive datasets?",
      "options": [
        "Redux List",
        "FlashList (by Shopify)",
        "FastList",
        "TurboList"
      ],
      "correct": [1],
      "explanation": "FlashList uses 'recycling' instead of unmounting, making it significantly faster and smoother than the core FlatList for large data sets.",
      "interviewTip": "If an interviewer asks about list performance bottlenecks, mentioning FlashList shows you are up-to-date with the ecosystem."
    },
    {
      "id": "lp-17",
      "stageId": "lists_performance",
      "type": "single",
      "prompt": "What is the function of the 'extraData' prop?",
      "options": [
        "To provide more data to the list",
        "To tell the list to re-render when something outside of the 'data' prop changes",
        "To store metadata about the list",
        "To enable multi-selection"
      ],
      "correct": [1],
      "explanation": "FlatList is a PureComponent. If your rows depend on state outside of the 'data' array (like a 'selectedId'), you must pass that state to extraData.",
      "interviewTip": "Without extraData, the list won't know it needs to re-render items when that external state changes."
    }
  ]
}
