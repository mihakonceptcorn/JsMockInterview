{
  "default": [
    {
      "id": "ab-01",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is the primary core API for creating animations in React Native?",
      "options": ["React.Animate", "Animated", "LayoutAnimation", "Reanimated"],
      "correct": [1],
      "explanation": "The 'Animated' library is built into React Native and designed to handle fluid, interactive animations efficiently.",
      "interviewTip": "Mention that while 'Reanimated' is a popular 3rd-party choice, 'Animated' is the standard built-in way to start."
    },
    {
      "id": "ab-02",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What does the 'useNativeDriver' prop do?",
      "options": [
        "It uses the phone's GPS for animations",
        "It offloads animation execution from the JS thread to the Native (UI) thread",
        "It makes the code easier to read",
        "It only works on Android"
      ],
      "correct": [1],
      "explanation": "By setting useNativeDriver: true, the JS thread sends the animation config to the native side once, preventing 'jank' if the JS thread gets busy.",
      "interviewTip": "Always use the Native Driver for non-layout properties like opacity and transform to ensure 60 FPS."
    },
    {
      "id": "ab-03",
      "stageId": "native_animations_basics",
      "type": "multiple",
      "prompt": "Which properties can be animated using the Native Driver?",
      "options": [
        "opacity",
        "transform (scale, rotate, translate)",
        "width and height",
        "backgroundColor"
      ],
      "correct": [0, 1],
      "explanation": "The Native Driver only supports properties that don't affect layout. Width, height, and flexbox properties require the JS thread.",
      "interviewTip": "If you need to animate width/height smoothly, consider using a 'scale' transform instead."
    },
    {
      "id": "ab-04",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is 'interpolation' in the Animated API?",
      "options": [
        "A way to calculate mathematical formulas",
        "Mapping input ranges (like 0 to 1) to output ranges (like 0 to 360 degrees or colors)",
        "A method to combine two different animations",
        "The process of loading assets"
      ],
      "correct": [1],
      "explanation": "Interpolation allows one animated value to drive multiple different styles (e.g., as a user scrolls, an image both fades out and shrinks).",
      "interviewTip": "Example: animValue.interpolate({ inputRange: [0, 1], outputRange: ['0deg', '180deg'] })."
    },
    {
      "id": "ab-05",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "Which component type must you use to apply animated styles?",
      "options": [
        "Standard <View> or <Text>",
        "Animated versions like <Animated.View> or <Animated.Image>",
        "Any component wrapped in useMemo",
        "Only <Canvas>"
      ],
      "correct": [1],
      "explanation": "Standard components cannot handle Animated.Value objects. You must use the 'Animated' prefixed versions.",
      "interviewTip": "You can create your own using Animated.createAnimatedComponent(MyComponent)."
    },
    {
      "id": "ab-06",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is the purpose of 'Animated.timing'?",
      "options": [
        "To record how long an animation takes",
        "To animate a value over a specific duration using an easing function",
        "To schedule background tasks",
        "To sync the app with the system clock"
      ],
      "correct": [1],
      "explanation": "timing() is the most common animation type, used for transitions with a fixed start, end, and duration.",
      "interviewTip": "It defaults to an 'easeInOut' curve if no easing is specified."
    },
    {
      "id": "ab-07",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "Which animation type mimics real-world physics (mass, tension, friction)?",
      "options": [
        "Animated.timing",
        "Animated.spring",
        "Animated.decay",
        "Animated.physics"
      ],
      "correct": [1],
      "explanation": "spring() provides a more 'organic' feel by calculating movement based on physical properties rather than fixed time.",
      "interviewTip": "Springs are great for UI elements like buttons or modals to make them feel bouncy and responsive."
    },
    {
      "id": "ab-08",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "How do you run multiple animations at the exact same time?",
      "options": [
        "Animated.sequence()",
        "Animated.parallel()",
        "Animated.stagger()",
        "By calling .start() on each one separately"
      ],
      "correct": [1],
      "explanation": "Animated.parallel() takes an array of animations and starts them all simultaneously.",
      "interviewTip": "Use parallel() when you want an object to fade in and slide up at once."
    },
    {
      "id": "ab-09",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What does 'Animated.stagger()' do?",
      "options": [
        "It runs animations one after another",
        "It starts animations in a sequence with a specific time delay between each",
        "It creates a random animation effect",
        "It stops all running animations"
      ],
      "correct": [1],
      "explanation": "Stagger is perfect for 'list entrance' animations where each item appears 100ms after the previous one.",
      "interviewTip": "This creates a professional 'wave' effect in your UI."
    },
    {
      "id": "ab-10",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "How do you repeat an animation indefinitely?",
      "options": [
        "Use a while(true) loop",
        "Animated.loop()",
        "Set the duration to Infinity",
        "Call .start() inside the completion callback"
      ],
      "correct": [1],
      "explanation": "Animated.loop() takes an animation and restarts it whenever it finishes.",
      "interviewTip": "Common for loading spinners or 'pulse' effects on buttons."
    },
    {
      "id": "ab-11",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is 'Animated.ValueXY' used for?",
      "options": [
        "Animating 3D objects",
        "Handling 2D coordinates (like dragging an element)",
        "Calculating the math for charts",
        "Mapping values to the Z-axis"
      ],
      "correct": [1],
      "explanation": "ValueXY is a specialized class for handling both x and y animated values, often used with PanResponder for dragging logic.",
      "interviewTip": "It provides helper methods like getLayout() to easily apply styles to a component."
    },
    {
      "id": "ab-12",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is the purpose of 'Animated.event'?",
      "options": [
        "To trigger a custom JS event",
        "To map native events (like scrolling or gestures) directly to an animated value",
        "To debug animation performance",
        "To listen for app state changes"
      ],
      "correct": [1],
      "explanation": "This allows you to create high-performance scroll effects (like a collapsing header) where the scroll position drives the animation without crossing the bridge.",
      "interviewTip": "When used with 'useNativeDriver: true', these effects are buttery smooth even if the JS thread is slow."
    },
    {
      "id": "ab-13",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What happens if you try to animate a layout property (like 'width') with useNativeDriver: true?",
      "options": [
        "It works perfectly",
        "It throws an error and the animation doesn't start",
        "The animation runs on the JS thread instead",
        "The app crashes immediately"
      ],
      "correct": [1],
      "explanation": "React Native will throw an error saying that the property is not supported by the native driver.",
      "interviewTip": "This is a frequent pitfall. Always check which properties you are animating before enabling the native driver."
    },
    {
      "id": "ab-14",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "How can you stop a running animation?",
      "options": [
        "animValue.stop()",
        "Animated.stopAll()",
        "animValue.setValue(currentValue)",
        "Animations cannot be stopped"
      ],
      "correct": [0],
      "explanation": "You call .stop() on the animation object returned by timing, spring, etc.",
      "interviewTip": "Stopping an animation leaves the value exactly where it was at that moment."
    },
    {
      "id": "ab-15",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is 'LayoutAnimation'?",
      "options": [
        "An alternative to the Animated API for simple whole-screen layout changes",
        "A tool for designing mockups",
        "A component for 3D layouts",
        "A way to animate text only"
      ],
      "correct": [0],
      "explanation": "LayoutAnimation automatically animates all views to their new positions when the next render happens. It's great for 'expanding' or 'deleting' items in a list.",
      "interviewTip": "Itâ€™s very easy to use but provides less control than the Animated API."
    },
    {
      "id": "ab-16",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "What is 'easing' in a timing animation?",
      "options": [
        "Making the animation take less memory",
        "A mathematical function that controls the rate of change (e.g., accelerating or bouncing)",
        "Setting the transparency of an object",
        "Pausing an animation"
      ],
      "correct": [1],
      "explanation": "Easing determines if an animation starts slow, ends fast, or follows a custom cubic-bezier curve.",
      "interviewTip": "Use Easing.bounce or Easing.elastic for playful UI elements."
    },
    {
      "id": "ab-17",
      "stageId": "native_animations_basics",
      "type": "single",
      "prompt": "How do you get the current value of an Animated.Value in your JS code?",
      "options": [
        "console.log(animValue)",
        "animValue.addListener() or _value (not recommended)",
        "JSON.stringify(animValue)",
        "Animated.getCurrentValue(animValue)"
      ],
      "correct": [1],
      "explanation": "Because Animated values are asynchronous and often live on the native side, you can't just 'read' them. You must add a listener to track changes in JS.",
      "interviewTip": "Try to avoid reading animated values in JS as it requires bridge traffic. Let the native side handle the logic whenever possible."
    }
  ]
}
