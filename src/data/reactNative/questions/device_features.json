{
  "default": [
    {
      "id": "df-01",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is the mandatory first step before accessing any hardware feature like the Camera or Location?",
      "options": [
        "Importing the component",
        "Requesting and checking for user permissions",
        "Turning on the device Bluetooth",
        "Updating the app to the latest version"
      ],
      "correct": [1],
      "explanation": "Mobile operating systems (iOS and Android) require explicit user consent to access sensitive hardware for privacy reasons.",
      "interviewTip": "Mention that permissions are usually requested at 'runtime' rather than just at install time."
    },
    {
      "id": "df-02",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which library is the industry standard for accessing the Camera in a React Native CLI project?",
      "options": [
        "react-native-camera-vision",
        "react-native-vision-camera",
        "expo-camera",
        "react-native-photo"
      ],
      "correct": [1],
      "explanation": "react-native-vision-camera is highly regarded for its performance, support for frame processors, and multi-camera features.",
      "interviewTip": "In the Expo ecosystem, 'expo-camera' is the standard equivalent."
    },
    {
      "id": "df-03",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is the difference between 'Foreground' and 'Background' location tracking?",
      "options": [
        "Foreground is faster than Background",
        "Foreground works only when the app is visible; Background works even if the app is closed/minimized",
        "There is no difference in React Native",
        "Background location is only available on iOS"
      ],
      "correct": [1],
      "explanation": "Foreground location is easier to implement and requires less strict permissions. Background location is heavily restricted by Apple and Google to prevent battery drain.",
      "interviewTip": "Always request only the level of access your app strictly needs (Principle of Least Privilege)."
    },
    {
      "id": "df-04",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which API is used to detect if the device is connected to the internet?",
      "options": [
        "NetInfo",
        "ConnectivityManager",
        "NetworkStatus",
        "OnlineHook"
      ],
      "correct": [0],
      "explanation": "The @react-native-community/netinfo library provides the current state of network connectivity (Wi-Fi, Cellular, or none).",
      "interviewTip": "You can use the 'useNetInfo' hook to automatically update your UI when the user goes offline."
    },
    {
      "id": "df-05",
      "stageId": "device_features",
      "type": "single",
      "prompt": "How do you trigger a physical vibration on the phone?",
      "options": [
        "Shake.trigger()",
        "Vibration.vibrate()",
        "Haptics.buzz()",
        "Device.shake()"
      ],
      "correct": [1],
      "explanation": "The built-in Vibration module allows you to trigger a simple buzz or a pattern of vibrations.",
      "interviewTip": "For more subtle, 'premium' feeling feedback (Haptic Feedback), use libraries like 'expo-haptics' or 'react-native-haptic-feedback'."
    },
    {
      "id": "df-06",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What does the 'AppState' API allow you to detect?",
      "options": [
        "The current memory usage",
        "Whether the app is in the foreground, background, or inactive",
        "The remaining battery percentage",
        "The screen resolution"
      ],
      "correct": [1],
      "explanation": "AppState tells you if the user has minimized the app or switched back to it. This is useful for pausing timers or refreshing data.",
      "interviewTip": "Use this to 'stop' heavy hardware sensors (like GPS) when the user leaves the app to save battery."
    },
    {
      "id": "df-07",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which sensor would you use to build a step counter or a shake-to-report feature?",
      "options": ["Gyroscope", "Accelerometer", "Magnetometer", "Barometer"],
      "correct": [1],
      "explanation": "The Accelerometer measures the force of acceleration and can detect movement, orientation, and sudden shakes.",
      "interviewTip": "The Gyroscope is different; it measures the 'rotation' rate around the device axes."
    },
    {
      "id": "df-08",
      "stageId": "device_features",
      "type": "single",
      "prompt": "How do you access the user's Biometrics (FaceID or Fingerprint) for login?",
      "options": [
        "Using the <Biometrics> component",
        "Using 'expo-local-authentication' or 'react-native-biometrics'",
        "It's built into the <TextInput>",
        "React Native cannot access biometrics"
      ],
      "correct": [1],
      "explanation": "These libraries provide a bridge to the native security prompts of iOS and Android.",
      "interviewTip": "Biometrics should only be used to unlock a locally stored secure token, not as a replacement for server-side auth."
    },
    {
      "id": "df-09",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is the purpose of the 'Linking' module for hardware interactions?",
      "options": [
        "Connecting to Bluetooth devices",
        "Opening other apps (Phone, Email, Maps, Browser) using URL schemes",
        "Linking two phones via NFC",
        "Syncing data to the cloud"
      ],
      "correct": [1],
      "explanation": "Linking.openURL('tel:12345') opens the phone dialer, and 'mailto:...' opens the email client.",
      "interviewTip": "Use 'canOpenURL' first to check if a specific app or handler exists on the device."
    },
    {
      "id": "df-10",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which library is used to read and write NFC tags?",
      "options": [
        "react-native-nfc",
        "react-native-nfc-manager",
        "expo-nfc",
        "NFC only works on Android"
      ],
      "correct": [1],
      "explanation": "react-native-nfc-manager is the primary tool for interacting with NFC (Near Field Communication) on both mobile platforms.",
      "interviewTip": "Remember that iOS has stricter NFC limitations than Android (e.g., background scanning)."
    },
    {
      "id": "df-11",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is the 'Magnetometer' used for in a mobile app?",
      "options": [
        "Measuring the strength of the phone's magnet",
        "Building a compass or detecting magnetic north",
        "Checking the battery health",
        "Detecting nearby metallic objects only"
      ],
      "correct": [1],
      "explanation": "The magnetometer measures the ambient magnetic field, which is essential for navigation and compass apps.",
      "interviewTip": "Magnetometer data often requires 'calibration' (moving the phone in a figure-8) to be accurate."
    },
    {
      "id": "df-12",
      "stageId": "device_features",
      "type": "single",
      "prompt": "How do you keep the screen from turning off while the user is watching a long video or reading?",
      "options": [
        "Device.stayAwake()",
        "Using a library like 'expo-keep-awake' or 'react-native-keep-awake'",
        "Setting the brightness to 100%",
        "It is not possible for security reasons"
      ],
      "correct": [1],
      "explanation": "These libraries prevent the OS from dimming or locking the screen automatically.",
      "interviewTip": "Always remember to 'release' the keep-awake state when the user leaves that specific screen to save battery."
    },
    {
      "id": "df-13",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is 'Geofencing'?",
      "options": [
        "A game about building fences",
        "A feature that triggers a notification or action when a user enters or leaves a specific geographic area",
        "A way to block users from certain countries",
        "Measuring the altitude of a device"
      ],
      "correct": [1],
      "explanation": "Geofencing uses GPS and Cellular data to create a virtual boundary around a location.",
      "interviewTip": "This often requires 'Always' background location permissions on iOS."
    },
    {
      "id": "df-14",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which module allows you to check the current battery level and charging state?",
      "options": [
        "PowerManager",
        "expo-battery or react-native-device-info",
        "BatteryStatus",
        "SystemInfo"
      ],
      "correct": [1],
      "explanation": "These libraries give you the battery percentage and tell you if the device is plugged in.",
      "interviewTip": "You can use this to disable high-power features (like background sync) if the battery is below 20%."
    },
    {
      "id": "df-15",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is 'Info.plist' (iOS) and 'AndroidManifest.xml' (Android) in the context of hardware?",
      "options": [
        "Code files for the UI",
        "Configuration files where you must declare which hardware permissions the app uses",
        "Files that store the user's password",
        "Icons for the app store"
      ],
      "correct": [1],
      "explanation": "Declare your 'Usage Description' strings here. On iOS, if you don't provide a reason for using the camera in Info.plist, the app will crash instantly.",
      "interviewTip": "Modern Expo users handle this through 'config plugins' in app.json."
    },
    {
      "id": "df-16",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is the 'Dimensions' API NOT able to detect that 'useWindowDimensions' can?",
      "options": [
        "The screen width",
        "Real-time changes in screen size (like when rotating the device)",
        "The pixel density",
        "The OS version"
      ],
      "correct": [1],
      "explanation": "useWindowDimensions is a hook that automatically triggers a re-render when the screen dimensions change (e.g., Orientation change).",
      "interviewTip": "Always prefer the hook version for responsive layouts."
    },
    {
      "id": "df-17",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which library is used to play and record audio files?",
      "options": [
        "react-native-sound",
        "expo-av or react-native-audio-recorder-player",
        "Audio.play()",
        "MediaCenter"
      ],
      "correct": [1],
      "explanation": "These libraries provide a full interface for loading, playing, pausing, and recording audio buffers.",
      "interviewTip": "Handling 'Audio Ducks' (when another app plays a sound) is a critical part of a professional audio implementation."
    }
  ]
}
