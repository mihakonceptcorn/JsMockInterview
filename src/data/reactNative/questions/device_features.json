{
  "default": [
    {
      "id": "hf-01",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is the mandatory first step before accessing any hardware feature like the Camera or Location in a production app?",
      "options": [
        "Import the 'Hardware' module.",
        "Request and verify the user's permission at runtime.",
        "Turn on the sensor in the device settings manually.",
        "Check if the device has enough battery."
      ],
      "correct": [1],
      "explanation": "Modern OS (iOS and Android) require apps to explicitly ask the user for permission. Attempting to use a sensor without permission will cause a crash or a silent fail.",
      "interviewTip": "Distinguish between 'Ask once' and 'Always allowed' permissions, especially for Location."
    },
    {
      "id": "hf-02",
      "stageId": "device_features",
      "type": "single",
      "prompt": "In Expo, which library is the standard for accessing the device's camera?",
      "options": [
        "expo-video",
        "expo-camera",
        "expo-media-capture",
        "react-native-vision-camera"
      ],
      "correct": [1],
      "explanation": "expo-camera provides a high-level component that handles the viewfinder, taking photos, and recording videos.",
      "interviewTip": "Mention that for highly advanced needs (like frame processors for AI), 'react-native-vision-camera' is often used in the CLI workflow."
    },
    {
      "id": "hf-03",
      "stageId": "device_features",
      "type": "single",
      "prompt": "How do you handle the difference between 'Foreground' and 'Background' location permissions on Android?",
      "options": [
        "They are the same permission.",
        "Foreground allows tracking while the app is open; Background requires an extra, separate permission and strict Google Play review.",
        "Background location is only available on iOS.",
        "You only need to set a flag in the JavaScript code."
      ],
      "correct": [1],
      "explanation": "To protect privacy, Android 10+ requires users to specifically grant 'Allow all the time' for background access.",
      "interviewTip": "Always follow the 'Principle of Least Privilege'â€”only ask for background access if it is critical to the app's core function."
    },
    {
      "id": "hf-04",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Which library is used to implement FaceID or Fingerprint authentication in React Native?",
      "options": [
        "react-native-fingerprint",
        "expo-local-authentication",
        "react-native-biometrics-unlock",
        "expo-face-id"
      ],
      "correct": [1],
      "explanation": "expo-local-authentication (and react-native-local-auth for CLI) provides a unified API to trigger the device's native biometric prompt.",
      "interviewTip": "Always check 'hasHardwareAsync()' and 'isEnrolledAsync()' before showing the 'Login with FaceID' button."
    },
    {
      "id": "hf-05",
      "stageId": "device_features",
      "type": "single",
      "prompt": "Analyze the code. What happens if the user denies the permission?",
      "code": "const { status } = await Camera.requestCameraPermissionsAsync();\nif (status !== 'granted') {\n  alert('Permission denied');\n}",
      "options": [
        "The app will automatically ask again the next time this code runs.",
        "On iOS, the system prompt will only appear once; after that, you must guide the user to the device Settings app.",
        "The app will crash.",
        "The alert will be blocked by the system."
      ],
      "correct": [1],
      "explanation": "To prevent 'permission spamming,' iOS only shows the system dialog once. If the status is 'denied,' you must programmatically link to Settings using 'Linking.openSettings()'.",
      "interviewTip": "This is a critical UX detail for apps that rely on hardware."
    },
    {
      "id": "hf-06",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is 'Geofencing'?",
      "options": [
        "A way to encrypt GPS data.",
        "Triggering an action (like a notification) when a device enters or leaves a specific geographical boundary.",
        "Measuring the altitude of the device.",
        "Using Bluetooth to find nearby devices."
      ],
      "correct": [1],
      "explanation": "Geofencing allows apps to be notified by the OS when the user crosses a coordinate radius, even if the app isn't actively running.",
      "interviewTip": "This is very efficient for battery life compared to constantly polling the user's location."
    },
    {
      "id": "hf-07",
      "stageId": "device_features",
      "type": "multiple",
      "prompt": "Where must you declare the 'reason' for requesting a permission (e.g., CameraUsageDescription) for iOS?",
      "options": [
        "In the package.json file.",
        "In the Info.plist file.",
        "Directly in the JavaScript code.",
        "In the app.json / expo config."
      ],
      "correct": [1, 3],
      "explanation": "iOS requires a 'Purpose String' in the Info.plist. In Expo, you define these in the 'plugins' section of app.json and they are injected into the plist during build.",
      "interviewTip": "If you don't provide a clear, user-friendly reason, Apple will reject your app during review."
    },
    {
      "id": "hf-08",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What does the 'Accelerometer' sensor measure?",
      "options": [
        "The compass heading.",
        "The change in velocity (acceleration) along three axes (X, Y, Z).",
        "The distance to the nearest object.",
        "The brightness of the screen."
      ],
      "correct": [1],
      "explanation": "Accelerometers are used for shake detection, step counting, and controlling games by tilting the phone.",
      "interviewTip": "Mention that sensors like this produce data at high frequencies, so it's important to use a 'Subscription' model and clean it up in 'useEffect'."
    },
    {
      "id": "hf-09",
      "stageId": "device_features",
      "type": "single",
      "prompt": "How do you check if an Android device has a physical 'Back' button or is using gesture navigation?",
      "options": [
        "Using the BackHandler module.",
        "Using the DeviceInfo library.",
        "This is handled automatically by the OS; you don't need to check.",
        "Checking the screen height."
      ],
      "correct": [0],
      "explanation": "The BackHandler module lets you listen to the hardware back button press and prevent it or customize its behavior.",
      "interviewTip": "This is an Android-only concern; iOS users expect a 'Back' button in the navigation header or a swipe-back gesture."
    },
    {
      "id": "hf-10",
      "stageId": "device_features",
      "type": "single",
      "prompt": "What is 'Linking' used for in hardware access?",
      "options": [
        "To connect to a Wi-Fi network.",
        "To open other apps, websites, or system settings (e.g., tel: or mailto:).",
        "To link the Camera to the Image component.",
        "To download assets."
      ],
      "correct": [1],
      "explanation": "The Linking module is the bridge to other apps. For example, `Linking.openURL('tel:123456')` triggers the native dialer.",
      "interviewTip": "Use 'Linking.canOpenURL' first to ensure the device has a handler for that specific link (like an email client)."
    }
  ]
}
