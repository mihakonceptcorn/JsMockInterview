{
  "default": [
    {
      "id": "lh-01",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "Which lifecycle hook is the best place to perform an API call to fetch initial data for a component?",
      "options": ["onBeforeMount", "onMounted", "onCreated", "onBeforeUpdate"],
      "correct": [1],
      "explanation": "While you can initiate calls in setup(), onMounted ensures the component is already in the DOM. In Vue 3 Composition API, logic is often placed in setup/onMounted.",
      "interviewTip": "In SSR (Server-Side Rendering), onMounted does not run on the server, which is important for avoiding browser-only API errors."
    },
    {
      "id": "lh-02",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "Analyze the code. What will be the output in the console when the component first loads?",
      "code": "<script setup>\nimport { onMounted } from 'vue';\n\nconsole.log('A');\n\nonMounted(() => {\n  console.log('B');\n});\n\nconsole.log('C');\n</script>",
      "options": ["A, B, C", "B, A, C", "A, C, B", "C, B, A"],
      "correct": [2],
      "explanation": "The setup code (script setup) runs immediately. onMounted is a callback that waits until the component is mounted to the DOM, making it asynchronous relative to the script execution.",
      "interviewTip": "Understanding the execution order of 'setup' vs 'hooks' is a common junior-to-mid level interview check."
    },
    {
      "id": "lh-03",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "Which hook is triggered specifically after a reactive data change causes the Virtual DOM to re-render and patch the physical DOM?",
      "options": [
        "onUpdated",
        "onBeforeUpdate",
        "onRenderTracked",
        "onMounted"
      ],
      "correct": [0],
      "explanation": "onUpdated is called after the DOM has been patched. It is useful for DOM-dependent logic that must react to state changes.",
      "interviewTip": "Warning: Avoid changing state inside onUpdated, as it can lead to an infinite re-render loop."
    },
    {
      "id": "lh-04",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "Analyze the code. What is the correct way to clean up a timer to prevent memory leaks?",
      "code": "<script setup>\nimport { onUnmounted } from 'vue';\nconst timer = setInterval(() => { ... }, 1000);\n\n________(() => {\n  clearInterval(timer);\n});\n</script>",
      "options": ["onBeforeUnmount", "onUnmounted", "onDestroy", "onClose"],
      "correct": [1],
      "explanation": "onUnmounted is the ideal place to clean up side effects like intervals, event listeners, or manual DOM observers when the component is removed.",
      "interviewTip": "Always mention 'cleaning up global event listeners' (like window.addEventListener) when asked about onUnmounted."
    },
    {
      "id": "lh-05",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "For a component wrapped in <KeepAlive>, which hook triggers every time the component is brought back into view?",
      "options": ["onMounted", "onActivated", "onDeactivated", "onReMounted"],
      "correct": [1],
      "explanation": "KeepAlive components are cached and not unmounted. Therefore, onMounted only runs once. onActivated runs every time the cached component is inserted into the DOM.",
      "interviewTip": "KeepAlive is frequently used for tabbed interfaces to preserve user input or scroll position."
    },
    {
      "id": "lh-06",
      "stageId": "lifecycle_hooks",
      "type": "multiple",
      "prompt": "Which of these hooks are only used for debugging and performance tracking in development mode?",
      "options": [
        "onRenderTracked",
        "onRenderTriggered",
        "onMounted",
        "onErrorCaptured"
      ],
      "correct": [0, 1],
      "explanation": "onRenderTracked and onRenderTriggered allow you to inspect which dependency is causing a component to re-render. They do not run in production.",
      "interviewTip": "These are 'advanced' hooks. Knowing them shows you have experience optimizing complex Vue apps."
    },
    {
      "id": "lh-07",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "Why can't you access 'Template Refs' (elements marked with ref=\"...\") inside the 'setup()' body directly?",
      "options": [
        "Because setup() runs before the DOM is even created.",
        "Because template refs are only for Vue 2.",
        "Because you must use document.getElementById instead.",
        "Because refs are private by default."
      ],
      "correct": [0],
      "explanation": "Setup executes before the component is mounted. The DOM elements don't exist yet, so the ref will be null. You must wait for onMounted to access them.",
      "interviewTip": "This is why onMounted is mandatory for third-party library initialization (like Chart.js or D3.js) that requires a DOM node."
    },
    {
      "id": "lh-08",
      "stageId": "lifecycle_hooks",
      "type": "single",
      "prompt": "In the Composition API, where should you place the logic that was previously in the 'beforeCreate' and 'created' hooks of the Options API?",
      "options": [
        "Inside onBeforeMount",
        "Directly in the setup() function or <script setup>",
        "Inside onMounted",
        "Composition API doesn't support these stages"
      ],
      "correct": [1],
      "explanation": "Since setup() runs at the same time as the creation phase, there's no need for explicit beforeCreate/created hooks in the Composition API.",
      "interviewTip": "This simplifies the component logic significantly compared to the Options API."
    }
  ]
}
