{
  "default": [
    {
      "id": "vue-re-01",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "Object.defineProperty",
        "Virtual DOM Listeners",
        "ES6 Proxies",
        "Dirty Checking (as seen in Angular JS)"
      ],
      "correct": [
        2
      ]
    },
    {
      "id": "vue-re-02",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "code": "const vm = new Vue({\n  data: {\n    a: 1\n  }\n});\n// later in the code\nvm.b = 2;",
      "options": [
        "Yes, Vue automatically adds all new properties to the reactivity system.",
        "No, the property must be pre-declared in the data object for tracking in Vue 2.",
        "Yes, but only if you call vm.$forceUpdate() immediately after.",
        "No, in Vue 2 only arrays are reactive."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-03",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "Model-View-ViewManager",
        "Model-View-ViewModel",
        "Module-View-Variable-Mapper",
        "Mapping-Virtual-View-Model"
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-04",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "To compile templates into render functions.",
        "To collect dependencies and re-run functions (like rendering) when reactive data changes.",
        "To encrypt data before it is sent to a server.",
        "To handle user click events exclusively."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-05",
      "stageId": "vue_intro_reactivity",
      "type": "multiple",
      "options": [
        "Detecting property addition/deletion.",
        "Detecting array index modification (arr[0] = value).",
        "The need for an initial data object.",
        "Performance overhead of recursive observation for large datasets."
      ],
      "correct": [
        0,
        1,
        3
      ]
    },
    {
      "id": "vue-re-06",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "code": "import { ref } from 'vue';\n\nexport default {\n  setup() {\n    let count = 0;\n    const increment = () => { count++; };\n    return { count, increment };\n  }\n}",
      "options": [
        "The UI will update correctly because 'count' is inside setup.",
        "The UI will not update because 'count' is a plain variable, not a 'ref' or 'reactive' object.",
        "Vue will throw a compilation error.",
        "The count will increment in memory but 'setup' will re-run automatically."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-07",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "You see a standard JS object.",
        "You see a Proxy object containing the target and handlers.",
        "The browser console crashes.",
        "The object is automatically converted to a string."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-08",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "It limits the number of updates to 10 per second.",
        "It uses a 'scheduler' and tracking flags to prevent an effect from triggering itself recursively.",
        "It strictly forbids updating data inside watchers.",
        "It doesn't; it's the developer's responsibility to avoid loops."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-09",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "reactive() is for objects, readonly() is for primitives.",
        "readonly() creates a read-only proxy of an object, preventing any mutations while still tracking access for reactivity.",
        "readonly() is faster than reactive().",
        "There is no difference; they are aliases."
      ],
      "correct": [
        1
      ]
    },
    {
      "id": "vue-re-10",
      "stageId": "vue_intro_reactivity",
      "type": "single",
      "options": [
        "It only tracks the top-level properties.",
        "It recursively converts all nested objects into Proxies, but does so lazily (on-access) for better performance.",
        "You must manually call reactive() on each nested object.",
        "Deep reactivity is not supported in Vue 3."
      ],
      "correct": [
        1
      ]
    }
  ]
}
