{
  "default": [
    {
      "id": "pi-01",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "Why is Pinia preferred over Vuex for Vue 3 applications?",
      "options": [
        "It is the only way to use CSS in Vue.",
        "It is lighter, has better TypeScript support, and removes the need for 'mutations' (making code less verbose).",
        "It allows for direct DOM manipulation.",
        "It is built into the browser natively."
      ],
      "correct": [
        1
      ],
      "explanation": "Pinia simplifies state management by removing mutations. You simply update the state directly or via actions. It also offers excellent TypeScript autocompletion by default.",
      "interviewTip": "Mention that Pinia is modular by design; unlike Vuex's single giant store, Pinia encourages creating multiple small, focused stores."
    },
    {
      "id": "pi-02",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "Analyze the code. What will happen if you destructure the store's state directly in a component?",
      "code": "const store = useQuizStore();\nconst { score } = store;\n\n// Later...\nstore.score++;",
      "options": [
        "The 'score' variable will update automatically in the template.",
        "The 'score' variable will lose reactivity and stay at the initial value.",
        "Vue will throw a 'ReferenceError'.",
        "The store will be reset to zero."
      ],
      "correct": [
        1
      ],
      "explanation": "Just like reactive objects, destructuring a Pinia store breaks reactivity. To maintain the link, you must use 'storeToRefs(store)'.",
      "interviewTip": "This is a frequent 'gotcha'. Use 'storeToRefs' for state and getters, but you can destructure actions (functions) normally."
    },
    {
      "id": "pi-03",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "In Pinia, what is the equivalent of a 'Computed' property for a store?",
      "options": [
        "State",
        "Actions",
        "Getters",
        "Plugins"
      ],
      "correct": [
        2
      ],
      "explanation": "Getters are exactly like computed properties for the store state. They are cached and only re-calculate when their dependencies change.",
      "interviewTip": "Getters can also return a function that accepts arguments (though these are not cached)."
    },
    {
      "id": "pi-04",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "How do you reset a store back to its initial state in Pinia?",
      "code": "const store = useAuthStore();\n________();",
      "options": [
        "store.clear()",
        "store.$reset()",
        "store.state = null",
        "store.refresh()"
      ],
      "correct": [
        1
      ],
      "explanation": "The $reset() method is a built-in utility that reverts the entire state of the store to the values defined in the initial state object.",
      "interviewTip": "Note that $reset() only works in 'Option Stores'. If you use 'Setup Stores' (function syntax), you have to implement your own reset logic."
    },
    {
      "id": "pi-05",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "Analyze the code. Where should an API call (like fetching quiz questions) be placed in a Pinia store?",
      "code": "export const useQuizStore = defineStore('quiz', {\n  state: () => ({ questions: [] }),\n  ________: {\n    async fetchQuestions() {\n      this.questions = await api.get('/questions');\n    }\n  }\n});",
      "options": [
        "getters",
        "actions",
        "mutations",
        "effects"
      ],
      "correct": [
        1
      ],
      "explanation": "Actions are where logic and side effects (like API calls) live. Unlike Vuex, Pinia actions can be asynchronous and update the state directly.",
      "interviewTip": "In an interview, highlight that actions replace both 'actions' and 'mutations' from Vuex, simplifying the architecture."
    },
    {
      "id": "pi-06",
      "stageId": "state_management_pinia",
      "type": "multiple",
      "prompt": "Which of these are valid ways to update multiple state properties at once in Pinia?",
      "options": [
        "Updating them one by one: store.a = 1; store.b = 2;",
        "Using store.$patch({ a: 1, b: 2 })",
        "Using store.$patch((state) => { state.a = 1; state.b = 2; })",
        "Calling a mutation function"
      ],
      "correct": [
        0,
        1,
        2
      ],
      "explanation": "Pinia is flexible. Individual updates are fine, but $patch is more efficient for batching changes and allows complex logic within the function version of $patch.",
      "interviewTip": "$patch is useful when you want to group multiple changes into a single entry for the DevTools timeline."
    },
    {
      "id": "pi-07",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "What is the purpose of 'defineStore'?",
      "options": [
        "To connect the app to a database.",
        "To define a new store and its logical structure (state, getters, actions).",
        "To compile the CSS for the component.",
        "To register the app in the browser."
      ],
      "correct": [
        1
      ],
      "explanation": "defineStore creates a hook (like useUserStore) that components can call to access the store instance.",
      "interviewTip": "Always mention that the first argument is a unique 'id' used for DevTools and store identification."
    },
    {
      "id": "pi-08",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "How do you listen to state changes globally (e.g., for logging or persistence) in Pinia?",
      "options": [
        "Using a watch on the whole store.",
        "Using the store.$subscribe() method.",
        "Using a regular setInterval.",
        "Pinia does not support global subscriptions."
      ],
      "correct": [
        1
      ],
      "explanation": "$subscribe() triggers whenever the state changes. It is often used to sync the store state with LocalStorage.",
      "interviewTip": "Many developers use the 'pinia-plugin-persistedstate' instead of writing manual subscriptions for storage."
    },
    {
      "id": "smp-09",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "What is Pinia and how does it differ from Vuex?",
      "options": [
        "Pinia is a CSS framework.",
        "Pinia is the official Vue 3 state management library, offering better TypeScript support and a simpler API than Vuex.",
        "Pinia is slower than Vuex.",
        "Pinia only works with Vue 2."
      ],
      "correct": [
        1
      ],
      "explanation": "Pinia removes concepts like mutations and modules, provides better TypeScript inference, and has a more intuitive API with stores.",
      "interviewTip": "Pinia is now the recommended state management solution for Vue 3 applications."
    },
    {
      "id": "smp-10",
      "stageId": "state_management_pinia",
      "type": "single",
      "prompt": "How do you define a store in Pinia?",
      "options": [
        "Use createStore()",
        "Use defineStore() with a unique ID and state/getters/actions.",
        "Use new Store()",
        "Use useState()"
      ],
      "correct": [
        1
      ],
      "explanation": "defineStore accepts an ID and either an options object (like Options API) or a setup function (like Composition API).",
      "interviewTip": "The setup store syntax is more flexible and aligns with Composition API patterns."
    }
  ]
}
