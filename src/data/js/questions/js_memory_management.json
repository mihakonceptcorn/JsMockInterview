{
  "default": [
    {
      "id": "js-mm-01",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Where are primitive values stored?",
      "options": ["Stack", "Heap", "Call queue", "DOM tree"],
      "correct": [0],
      "explanation": "Primitives are stored on the stack.",
      "interviewTip": "Objects live on the heap."
    },
    {
      "id": "js-mm-02",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Where are objects stored?",
      "options": ["Heap", "Stack", "Call stack", "Registers"],
      "correct": [0],
      "explanation": "Objects are allocated on the heap.",
      "interviewTip": "References are stored on the stack."
    },
    {
      "id": "js-mm-03",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is garbage collection?",
      "options": [
        "Automatic memory cleanup",
        "Manual deallocation",
        "Heap compression",
        "Stack reset"
      ],
      "correct": [0],
      "explanation": "GC frees unreachable memory.",
      "interviewTip": "JS is GC-based."
    },
    {
      "id": "js-mm-04",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Which algorithm is commonly used by JS engines?",
      "options": [
        "Mark-and-sweep",
        "Reference counting only",
        "Manual GC",
        "Stop-and-copy only"
      ],
      "correct": [0],
      "explanation": "Modern engines use mark-and-sweep variants.",
      "interviewTip": "V8 uses generational GC."
    },
    {
      "id": "js-mm-05",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What makes an object eligible for GC?",
      "options": [
        "No reachable references",
        "Out of scope variable",
        "Null value",
        "Low memory"
      ],
      "correct": [0],
      "explanation": "Reachability determines GC.",
      "interviewTip": "Scope alone is not enough."
    },
    {
      "id": "js-mm-06",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is a memory leak?",
      "options": [
        "Unused memory not released",
        "Stack overflow",
        "Slow GC",
        "Heap fragmentation"
      ],
      "correct": [0],
      "explanation": "Leaked memory stays reachable.",
      "interviewTip": "Common in closures."
    },
    {
      "id": "js-mm-07",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Which is a common source of memory leaks?",
      "options": [
        "Detached DOM nodes",
        "Local variables",
        "Primitive values",
        "Function parameters"
      ],
      "correct": [0],
      "explanation": "Detached DOM nodes keep references.",
      "interviewTip": "Check event listeners."
    },
    {
      "id": "js-mm-08",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Why are global variables dangerous?",
      "options": [
        "They live for app lifetime",
        "They slow down GC",
        "They block rendering",
        "They use stack memory"
      ],
      "correct": [0],
      "explanation": "Globals are always reachable.",
      "interviewTip": "Avoid accidental globals."
    },
    {
      "id": "js-mm-09",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What happens during mark phase?",
      "options": [
        "Reachable objects are marked",
        "Memory is freed",
        "Heap is compacted",
        "Stack is cleared"
      ],
      "correct": [0],
      "explanation": "GC traverses object graph.",
      "interviewTip": "Starts from roots."
    },
    {
      "id": "js-mm-10",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What are GC roots?",
      "options": [
        "Global objects and stack references",
        "Heap objects",
        "DOM nodes",
        "Timers"
      ],
      "correct": [0],
      "explanation": "GC starts from roots.",
      "interviewTip": "window, stack, closures."
    },
    {
      "id": "js-mm-11",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is generational GC?",
      "options": [
        "Objects grouped by age",
        "GC by priority",
        "Manual generations",
        "Stack-based GC"
      ],
      "correct": [0],
      "explanation": "Young objects collected more often.",
      "interviewTip": "Most objects die young."
    },
    {
      "id": "js-mm-12",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is a closure-related leak?",
      "options": [
        "Closure holding unused references",
        "Function recursion",
        "Stack overflow",
        "Async execution"
      ],
      "correct": [0],
      "explanation": "Closures may retain memory.",
      "interviewTip": "Clear references."
    },
    {
      "id": "js-mm-13",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Which structure prevents GC?",
      "options": [
        "Strong references",
        "Weak references",
        "Null values",
        "Primitives"
      ],
      "correct": [0],
      "explanation": "Strong references keep objects alive.",
      "interviewTip": "WeakMap doesn't."
    },
    {
      "id": "js-mm-14",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Why use WeakMap?",
      "options": [
        "Avoid memory leaks",
        "Faster access",
        "More features",
        "Serialization"
      ],
      "correct": [0],
      "explanation": "Keys are weakly held.",
      "interviewTip": "Great for caching."
    },
    {
      "id": "js-mm-15",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Can WeakMap keys be primitives?",
      "options": ["No", "Yes", "Only strings", "Only numbers"],
      "correct": [0],
      "explanation": "Keys must be objects.",
      "interviewTip": "WeakSet too."
    },
    {
      "id": "js-mm-16",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is heap fragmentation?",
      "options": [
        "Scattered free memory blocks",
        "Stack corruption",
        "Memory leak",
        "Slow GC"
      ],
      "correct": [0],
      "explanation": "Impacts allocation performance.",
      "interviewTip": "Compaction fixes it."
    },
    {
      "id": "js-mm-17",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is stop-the-world GC?",
      "options": [
        "Pauses JS execution",
        "Runs in background",
        "Only for stack",
        "Only for DOM"
      ],
      "correct": [0],
      "explanation": "JS execution pauses.",
      "interviewTip": "Causes jank."
    },
    {
      "id": "js-mm-18",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Which tool helps detect memory leaks?",
      "options": [
        "Chrome DevTools Memory tab",
        "Console.log",
        "Network tab",
        "Lighthouse only"
      ],
      "correct": [0],
      "explanation": "Heap snapshots reveal leaks.",
      "interviewTip": "Compare snapshots."
    },
    {
      "id": "js-mm-19",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What causes excessive GC?",
      "options": [
        "Frequent allocations",
        "Async code",
        "Promises",
        "Event loop"
      ],
      "correct": [0],
      "explanation": "Short-lived objects increase GC pressure.",
      "interviewTip": "Reuse objects."
    },
    {
      "id": "js-mm-20",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What is object pooling?",
      "options": [
        "Reusing allocated objects",
        "Cloning objects",
        "Freezing objects",
        "Serializing objects"
      ],
      "correct": [0],
      "explanation": "Reduces allocations.",
      "interviewTip": "Use carefully."
    },
    {
      "id": "js-mm-21",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Why avoid large arrays kept globally?",
      "options": [
        "Memory stays allocated",
        "Slower loops",
        "Stack overflow",
        "Scope issues"
      ],
      "correct": [0],
      "explanation": "GC cannot free them.",
      "interviewTip": "Release references."
    },
    {
      "id": "js-mm-22",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "What does nulling a reference do?",
      "options": [
        "Allows GC if no other refs exist",
        "Immediately frees memory",
        "Deletes object",
        "Compacts heap"
      ],
      "correct": [0],
      "explanation": "GC still decides.",
      "interviewTip": "Common misconception."
    },
    {
      "id": "js-mm-23",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Which API allows weak references?",
      "options": ["WeakRef", "Map", "Set", "Object"],
      "correct": [0],
      "explanation": "Introduced for advanced cases.",
      "interviewTip": "Use with caution."
    },
    {
      "id": "js-mm-24",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Why is WeakRef dangerous?",
      "options": [
        "Object may disappear anytime",
        "It leaks memory",
        "It blocks GC",
        "It crashes browser"
      ],
      "correct": [0],
      "explanation": "Non-deterministic lifecycle.",
      "interviewTip": "Expert-level topic."
    },
    {
      "id": "js-mm-25",
      "stageId": "js_memory_management",
      "type": "single",
      "prompt": "Best rule for memory optimization?",
      "options": [
        "Measure before optimizing",
        "Avoid objects",
        "Disable GC",
        "Use primitives only"
      ],
      "correct": [0],
      "explanation": "Profiling is key.",
      "interviewTip": "Senior answer."
    }
  ]
}
