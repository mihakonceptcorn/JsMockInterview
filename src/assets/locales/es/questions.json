{
  "vr-01": {
    "prompt": "How do you define a dynamic route segment that captures a specific value, like a user ID?",
    "explanation": "Colons denote dynamic segments. The value passed in the URL (e.g., /user/123) will be accessible via 'route.params.id'.",
    "interviewTip": "You can use Regex in paths for more strict matching, like /user/:id(\\\\d+)."
  },
  "vr-02": {
    "prompt": "Analyze the code. What is the difference between these two navigation methods?",
    "explanation": "Replace is used when you don't want the user to be able to go 'back' to the previous screen (e.g., after a successful login).",
    "interviewTip": "Use 'replace' for redirects or transient states to keep the history stack clean."
  },
  "vr-03": {
    "prompt": "Which hook should you use inside a component to perform logic *before* a user leaves the current page?",
    "explanation": "onBeforeRouteLeave is a specialized router hook. It allows you to prevent navigation (e.g., if the user has unsaved changes in a form).",
    "interviewTip": "You can return 'false' from this hook to cancel the navigation."
  },
  "vr-04": {
    "prompt": "What is the primary benefit of 'Lazy Loading' routes in the router configuration?",
    "explanation": "Dynamic imports () => import(...) create a separate bundle for that route, significantly improving the initial load time of the app.",
    "interviewTip": "For large enterprise apps, lazy loading every non-critical route is a mandatory performance optimization."
  },
  "vr-05": {
    "prompt": "How do you access the current route's parameters inside a <script setup> block?",
    "explanation": "useRoute gives you access to the current state (params, query, path). useRouter gives you the ability to navigate (push, back).",
    "interviewTip": "Don't mix them up! UseRoute is for 'What is happening now'; UseRouter is for 'What should happen next'."
  },
  "vr-06": {
    "prompt": "Which of these are valid Global Navigation Guards?",
    "explanation": "Navigation guards are used to protect routes (e.g., checking for auth tokens).",
    "interviewTip": "Mention 'beforeEach' as the primary place for implementing authentication checks."
  },
  "vr-07": {
    "prompt": "What is the purpose of the <router-view> component?",
    "explanation": "RouterView is where the magic happens. Without it, you might change the URL, but the UI won't update to show the new component.",
    "interviewTip": "You can use multiple <router-view> components with names to create complex layouts."
  },
  "vr-08": {
    "prompt": "Analyze the code. What is the value of 'props' being set to true?",
    "explanation": "Setting 'props: true' decouples the component from the router. The User component can declare 'props: ['id']' and use it without knowing about 'this.$route'.",
    "interviewTip": "This makes components much easier to unit test because they don't depend on the global router state."
  },
  "vr-09": {
    "prompt": "How do you programmatically navigate to a different route in Vue Router?",
    "explanation": "$router is the router instance with navigation methods. $route is the current route information object.",
    "interviewTip": "In Composition API, use useRouter() to access the router instance."
  },
  "vr-10": {
    "prompt": "What is the purpose of route guards in Vue Router?",
    "explanation": "Navigation guards (beforeEach, beforeEnter, beforeRouteEnter, etc.) allow you to implement authentication, authorization, and other navigation logic.",
    "interviewTip": "Global guards run for all routes, per-route guards run for specific routes, and in-component guards run within components."
  },
  "vue-re-01": {
    "prompt": "What technology serves as the foundation for the Vue 3 reactivity system, allowing it to track changes in objects more effectively?",
    "explanation": "Vue 3 uses ES6 Proxies to intercept operations on objects. This solved Vue 2 limitations, such as the inability to automatically detect newly added properties or changes in arrays by index.",
    "interviewTip": "Expect to be asked about the difference: Vue 2 used getters/setters via defineProperty, whereas Vue 3 uses Proxies, which are more performant and flexible."
  },
  "vue-re-02": {
    "prompt": "Analyze the code below. Will the change to property 'b' be reactive in Vue 2?",
    "explanation": "In Vue 2, reactivity is injected during instance initialization. Properties added afterward (like vm.b) do not become reactive unless Vue.set() is used.",
    "interviewTip": "This is a classic Vue 2 'gotcha.' In Vue 3, this code would work perfectly due to Proxies."
  },
  "vue-re-03": {
    "prompt": "What does the MVVM acronym stand for in the context of Vue.js architecture?",
    "explanation": "Vue is inspired by the MVVM pattern. The View is the DOM, the Model is the plain JavaScript data, and the ViewModel is the Vue instance that syncs the two.",
    "interviewTip": "If asked how Vue relates to MVVM, explain that the 'ViewModel' handles the data binding, so you don't have to manipulate the DOM manually."
  },
  "vue-re-04": {
    "prompt": "What is the primary role of the 'Effect' (Watcher) in Vue's reactivity system?",
    "explanation": "When a reactive property is accessed, the current 'effect' is recorded as a subscriber. When the property is mutated, all its subscribers are notified to re-run.",
    "interviewTip": "This is the 'Observer' pattern. Understanding that 'Dependency Tracking' happens during 'Getter' access is a sign of a senior developer."
  },
  "vue-re-05": {
    "prompt": "Which of the following limitations of Vue 2 reactivity were eliminated in Vue 3?",
    "explanation": "Proxies allow Vue to track additions/deletions and array indices. Vue 3 also uses 'lazy' observation, only making nested objects reactive when they are actually accessed.",
    "interviewTip": "Vue 3 is significantly more memory-efficient for large, nested data structures because of this lazy observation."
  },
  "vue-re-06": {
    "prompt": "Analyze the Vue 3 Composition API code. What will happen to the UI when 'increment' is called?",
    "explanation": "In Vue 3, variables must be explicitly made reactive using 'ref()' or 'reactive()'. A plain 'let' variable is not tracked by the reactivity system.",
    "interviewTip": "Remember that 'ref' creates an object with a '.value' property. Accessing 'count.value' is how you mutate the data in JS."
  },
  "vue-re-07": {
    "prompt": "What happens when you pass a reactive object to 'console.log' in Vue 3?",
    "explanation": "Because Vue 3 uses Proxies, the console will show the Proxy wrapper. To see the raw data, you can use the 'toRaw()' utility or log 'JSON.parse(JSON.stringify(obj))'.",
    "interviewTip": "Mentioning 'toRaw' shows you've worked with debugging complex reactive states in production."
  },
  "vue-re-08": {
    "prompt": "How does Vue's reactivity system avoid infinite loops when an effect updates the same data it depends on?",
    "explanation": "Vue's internal scheduler checks if the effect being triggered is the same as the one currently running, preventing immediate recursive loops.",
    "interviewTip": "Understanding the 'Scheduler' demonstrates a deep knowledge of Vue internals beyond just surface-level syntax."
  },
  "vue-re-09": {
    "prompt": "What is the difference between 'reactive()' and 'readonly()' in Vue 3?",
    "explanation": "readonly() is useful when you want to pass data to child components but prevent them from modifying it. The original object can still be mutated, but the readonly proxy will throw warnings in development.",
    "interviewTip": "Mention readonly() when discussing prop immutability patterns or state management best practices."
  },
  "vue-re-10": {
    "prompt": "How does Vue 3 handle reactivity for deeply nested objects?",
    "explanation": "Vue 3 uses lazy reactive conversion. When you access a nested object for the first time, Vue wraps it in a Proxy. This avoids the upfront cost of converting large data structures.",
    "interviewTip": "This lazy approach is one of the key performance improvements over Vue 2's eager recursive observation."
  },
  "int-01": {
    "prompt": "What are 'Patch Flags' in the Vue 3 rendering engine?",
    "explanation": "During the compilation phase, Vue marks elements with flags. For example, if only the text is dynamic, Vue marks it with a TEXT flag, so the diffing algorithm doesn't waste time checking attributes or classes.",
    "interviewTip": "This is why Vue 3 is often called 'Compiler-Informed'. It moves the work from runtime to compile-time."
  },
  "int-02": {
    "prompt": "What is 'Static Hoisting' in Vue 3?",
    "explanation": "If a piece of your template is purely static (no variables), Vue hoists it. Instead of creating a new Virtual Node on every render, it simply points to the same pre-created node, saving memory and CPU.",
    "interviewTip": "Static Hoisting is one of the main reasons Vue 3 templates have near-zero overhead for static content."
  },
  "int-03": {
    "prompt": "Analyze the code snippet from a compiled Vue render function. What does the '1 /* TEXT */' represent?",
    "explanation": "This is a Patch Flag. When the Virtual DOM 'patches' this node, it sees the '1' and knows it only needs to check the text content, completely ignoring the attributes (null).",
    "interviewTip": "You can see these flags yourself by using the Vue Template Explorer online."
  },
  "int-04": {
    "prompt": "What is the 'Block Tree' optimization?",
    "explanation": "Vue 3 divides the template into 'Blocks'. Each Block knows which of its children are dynamic. When updating, Vue iterates over the 'dynamic children' array rather than traversing the whole tree.",
    "interviewTip": "This turns the Virtual DOM complexity from 'O(total number of nodes)' to 'O(number of dynamic nodes)'."
  },
  "int-05": {
    "prompt": "What does the 'nextTick()' function do in the rendering cycle?",
    "explanation": "Vue updates the DOM asynchronously. If you change a value and immediately try to measure the DOM, you'll get the old state. nextTick() ensures you are working with the updated DOM.",
    "interviewTip": "Common use case: Focusing an element after it was just shown with v-if."
  },
  "int-06": {
    "prompt": "Which of these are steps in the Vue 'Compiler' pipeline?",
    "explanation": "Hydration is a runtime process during SSR. Parse, Transform, and Generate are the three classic stages of the Vue compiler.",
    "interviewTip": "Understanding AST (Abstract Syntax Tree) is a 'Senior' level concept in frontend engineering."
  },
  "int-07": {
    "prompt": "In the Virtual DOM, what is a 'VNode'?",
    "explanation": "VNodes are lightweight. Creating and comparing thousands of VNodes is much faster than manipulating thousands of actual DOM nodes.",
    "interviewTip": "The collection of these VNodes is what we call the 'Virtual DOM'."
  },
  "int-08": {
    "prompt": "What happens during the 'Patch' process?",
    "explanation": "Patching is the 'reconciliation' phase. Vue uses an efficient algorithm to find the minimum number of steps to transform the old DOM into the new one.",
    "interviewTip": "In Vue 3, patching is 'bit-wise' thanks to the Patch Flags we discussed earlier."
  },
  "vi-09": {
    "prompt": "What is the Virtual DOM and why does Vue use it?",
    "explanation": "The Virtual DOM allows Vue to batch updates and minimize expensive DOM operations by diffing the old and new virtual trees.",
    "interviewTip": "Vue 3's Virtual DOM implementation is significantly faster than Vue 2 due to optimizations like static hoisting and patch flags."
  },
  "vi-10": {
    "prompt": "What are patch flags in Vue 3?",
    "explanation": "Patch flags are integers that encode information about dynamic bindings, allowing Vue to skip static content during updates.",
    "interviewTip": "This is one of the key optimizations that makes Vue 3 faster than Vue 2."
  },
  "ta-01": {
    "prompt": "What is the primary role of the built-in <Transition> component?",
    "explanation": "<Transition> doesn't animate things itself; it detects when an element is added/removed and adds classes like '-enter-from' and '-enter-active' so your CSS can do the work.",
    "interviewTip": "Mention that <Transition> only works on a single element or component. For lists, you must use <TransitionGroup>."
  },
  "ta-02": {
    "prompt": "Analyze the CSS classes below. Which class defines the 'target' state (the end result) of an entering element?",
    "explanation": "The six transition classes are: enter-from, enter-active, enter-to, leave-from, leave-active, and leave-to.",
    "interviewTip": "If you don't provide a 'name' attribute to the transition, the classes default to 'v-enter-from', etc."
  },
  "ta-03": {
    "prompt": "How do you handle animations for a list of items generated by 'v-for'?",
    "explanation": "<TransitionGroup> renders a real element (default is no element in Vue 3, but can be specified) and handles the movement of items as the list is reordered.",
    "interviewTip": "Items inside a <TransitionGroup> MUST have a unique :key for the animations to work."
  },
  "ta-04": {
    "prompt": "Analyze the code. What does the 'mode' attribute do?",
    "explanation": "Without 'out-in', both components would be in the DOM at the same time during the transition, often causing layout 'jumping'.",
    "interviewTip": "The 'out-in' mode is almost always preferred for smooth page or component transitions."
  },
  "ta-05": {
    "prompt": "How can you trigger a transition when a component first mounts, even without a state change?",
    "explanation": "The 'appear' attribute tells Vue to apply the enter transition classes as soon as the element is first rendered.",
    "interviewTip": "This is great for 'hero' sections or entrance animations for a landing page."
  },
  "ta-06": {
    "prompt": "Which of these are valid 'JavaScript Hooks' provided by the <Transition> component for complex animations (e.g., using GSAP)?",
    "explanation": "Vue provides JS hooks like @before-enter, @enter, and @leave so you can use libraries like GreenSock (GSAP) or Anime.js instead of CSS.",
    "interviewTip": "When using JS hooks, it's best to add :css='false' to tell Vue to skip CSS detection for a performance boost."
  },
  "ta-07": {
    "prompt": "What is the purpose of the 'v-move' class in TransitionGroup?",
    "explanation": "While enter/leave classes handle appearing/disappearing, 'v-move' (or '[name]-move') uses the FLIP technique to smoothly slide items to their new positions.",
    "interviewTip": "This is how you get those smooth 'shuffling' effects in lists."
  },
  "ta-08": {
    "prompt": "Analyze the code. What is wrong with this animation setup?",
    "explanation": "A <Transition> only animates a single child. If you have multiple elements toggling, they need unique keys so Vue can track which is which, or you should use a single component with :is.",
    "interviewTip": "Always use unique keys when transitioning between two different elements of the same tag type."
  },
  "ta-09": {
    "prompt": "What CSS classes does Vue apply during a transition?",
    "explanation": "Vue applies these 6 classes at different stages of the transition, allowing you to define CSS transitions or animations.",
    "interviewTip": "You can customize the prefix by setting the name attribute on <Transition>."
  },
  "ta-10": {
    "prompt": "How do you animate a list of items in Vue?",
    "explanation": "<TransitionGroup> applies transitions to multiple elements rendered with v-for, including enter, leave, and move transitions.",
    "interviewTip": "Always provide unique keys for TransitionGroup children for proper animation tracking."
  },
  "tv-01": {
    "prompt": "Which tool is currently recommended by the Vue team as the primary test runner, replacing Jest in most modern setups?",
    "explanation": "Vitest is built on top of Vite. It is extremely fast, shares the same configuration as your development environment, and has a Jest-compatible API.",
    "interviewTip": "Highlight Vitest's 'Hot Module Replacement' (HMR) for tests, which makes the TDD (Test Driven Development) cycle feel much faster."
  },
  "tv-02": {
    "prompt": "What is the difference between 'mount' and 'shallowMount' in Vue Test Utils?",
    "explanation": "shallowMount is ideal for unit testing because it isolates the component from its children, ensuring that a bug in a child component doesn't cause the parent's test to fail.",
    "interviewTip": "Use 'mount' for integration tests and 'shallowMount' for pure unit tests of a single component's logic."
  },
  "tv-03": {
    "prompt": "Analyze the code. How do you simulate a user clicking a button in a Vitest test?",
    "explanation": "The 'trigger' method simulates a DOM event. Because Vue updates the DOM asynchronously, you should 'await' the trigger to ensure the DOM has updated before making assertions.",
    "interviewTip": "Always await 'trigger' and 'setValue' to avoid flaky tests caused by Vue's async rendering."
  },
  "tv-04": {
    "prompt": "Analyze the code. How do you verify that a component emitted a specific event?",
    "explanation": "wrapper.emitted() returns an object containing all events emitted by the component and the arguments passed with them.",
    "interviewTip": "You can check the arguments like this: expect(wrapper.emitted().myEvent[0]).toEqual(['expectedData'])."
  },
  "tv-05": {
    "prompt": "How do you test a component that depends on a global plugin like 'Pinia' or 'Vue Router'?",
    "explanation": "Vue Test Utils allows you to provide 'mocks' or 'stubs' for global features using the 'global' property in the second argument of mount().",
    "interviewTip": "For Pinia, it is best to use 'createTestingPinia()', which automatically mocks all your actions."
  },
  "tv-06": {
    "prompt": "Which of these are valid ways to find an element using Vue Test Utils 'find' or 'get'?",
    "explanation": "find() supports CSS selectors and component definitions. It is a best practice to use 'data-testid' for tests to decouple them from CSS classes or HTML structure.",
    "interviewTip": "Explain that 'get' throws an error if the element is not found, while 'find' returns an empty wrapper, making 'get' safer for assertions."
  },
  "tv-07": {
    "prompt": "What is 'Snapshot Testing' in Vitest?",
    "explanation": "Snapshots catch regression in the HTML structure. If you change a class name, the snapshot will fail, forcing you to verify if the change was intentional.",
    "interviewTip": "Warn that snapshots can be 'brittle' if your UI changes frequently; use them sparingly for stable components."
  },
  "tv-08": {
    "prompt": "How do you test code that uses 'nextTick()'?",
    "explanation": "Since nextTick returns a promise, awaiting it in your test ensures that you are inspecting the DOM after Vue has completed its reactive update cycle.",
    "interviewTip": "This is crucial for testing components that change their DOM structure based on a reactive state change."
  },
  "tv-09": {
    "prompt": "What is the recommended testing library for Vue 3 components?",
    "explanation": "Vue Test Utils is the official testing utility library for Vue, providing methods to mount components and interact with them in tests.",
    "interviewTip": "Combine Vue Test Utils with Jest or Vitest for a complete testing solution."
  },
  "tv-10": {
    "prompt": "What is the difference between shallow and full mounting in Vue Test Utils?",
    "explanation": "Shallow mounting (shallowMount) is useful for unit testing a component in isolation, while full mounting (mount) is better for integration tests.",
    "interviewTip": "Vue Test Utils v2 (for Vue 3) recommends using mount more often as shallow mounting can hide integration issues."
  },
  "ts-01": {
    "prompt": "Which directive is used to reactively update an HTML attribute, such as 'src' or 'disabled'?",
    "explanation": "v-bind (shorthand ':') is used to bind an attribute to an expression. For example, :disabled='isPending' will apply the disabled attribute if isPending is truthy.",
    "interviewTip": "In Vue 3.4+, you can use the shorthand :id instead of :id='id' if the attribute name matches the variable name."
  },
  "ts-02": {
    "prompt": "Analyze the code. What will be rendered in the browser?",
    "explanation": "v-html updates the element's innerHTML with the provided string. Use this with caution as it can lead to XSS attacks.",
    "interviewTip": "Always warn about XSS when discussing v-html; only use it on trusted content."
  },
  "ts-03": {
    "prompt": "What is the difference between {{ message }} and v-text=\"message\"?",
    "explanation": "Interpolation (Mustaches) allows you to mix text and variables like 'Hello {{ name }}'. v-text will overwrite everything inside the tag with the variable's value.",
    "interviewTip": "Mustaches are preferred for readability, while v-text is rarely used unless you want to avoid 'Flash of Uncompiled Template' (though v-cloak is better for that)."
  },
  "ts-04": {
    "prompt": "How do you listen to DOM events (like a click) and run some JavaScript when they are triggered?",
    "explanation": "v-on (shorthand '@') is the directive for event listeners. It can call a method or run an inline expression.",
    "interviewTip": "Mention event modifiers like @click.prevent or @click.stop for handling common event logic declaratively."
  },
  "ts-05": {
    "prompt": "Which directive creates a two-way data binding on form input, textarea, and select elements?",
    "explanation": "v-model is 'syntactic sugar' that combines v-bind (to set the value) and v-on (to listen for input changes).",
    "interviewTip": "In Vue 3, you can have multiple v-models on a single custom component (e.g., v-model:first-name and v-model:last-name)."
  },
  "ts-06": {
    "prompt": "Which of the following directives are used to optimize performance by skipping re-renders or compilation?",
    "explanation": "v-once and v-memo are for runtime performance. v-pre is for compile-time performance, allowing you to show raw mustache tags without Vue processing them.",
    "interviewTip": "v-memo is a powerful Vue 3.2+ feature specifically for optimizing large v-for lists."
  },
  "ts-07": {
    "prompt": "Analyze the code. What will happen to the input value after the button is clicked?",
    "explanation": "The .number modifier automatically typecasts the input string to a number using parseFloat().",
    "interviewTip": "Modifiers like .trim and .lazy are also vital for refining user input behavior without extra JS logic."
  },
  "ts-08": {
    "prompt": "What is the result of using a JavaScript expression inside mustaches, like {{ number + 1 }}?",
    "explanation": "Vue supports full JavaScript expressions inside data bindings, but they must be single expressions (no statements or flow control).",
    "interviewTip": "While expressions are powerful, keep them simple. If logic gets complex, move it to a 'computed' property."
  },
  "ts-09": {
    "prompt": "What is the purpose of the 'v-cloak' directive?",
    "explanation": "v-cloak stays on the element until the Vue instance finishes compiling. You typically pair it with CSS like [v-cloak] { display: none } to hide mustache tags during page load.",
    "interviewTip": "This is mainly useful for server-rendered HTML where the template is visible before Vue hydrates."
  },
  "ts-10": {
    "prompt": "How do you dynamically bind a directive argument in Vue 3?",
    "explanation": "Dynamic directive arguments (introduced in Vue 2.6+) allow you to use a JavaScript expression as the directive argument by wrapping it in square brackets.",
    "interviewTip": "This is useful for creating generic components that can bind to different events or attributes based on props."
  },
  "tr-01": {
    "prompt": "In the Composition API, how do you link a 'ref' variable to a specific DOM element in your template?",
    "explanation": "To create a template ref, you declare a ref with the same name in your script and apply the 'ref' attribute to the element in the template.",
    "interviewTip": "The variable name in your script must match the string value of the ref attribute in your template exactly."
  },
  "tr-02": {
    "prompt": "Analyze the code. Why will 'inputRef.value' be null when the console.log runs?",
    "explanation": "Template refs are only populated after the component is mounted. Any attempt to access them in the immediate body of the setup script will result in null.",
    "interviewTip": "To access a ref safely, always use the 'onMounted' lifecycle hook."
  },
  "tr-03": {
    "prompt": "How can you focus an input automatically when a component mounts?",
    "explanation": "Once mounted, the 'value' of the ref holds the actual HTMLInputElement, giving you access to native methods like .focus().",
    "interviewTip": "Mention that this is the 'Vue way' rather than using querySelector, which breaks the component encapsulation."
  },
  "tr-04": {
    "prompt": "When using 'v-for', what will a template ref contain if it is applied to the repeated element?",
    "explanation": "Vue 3 automatically populates the ref with an array of elements when it is used inside a v-for loop.",
    "interviewTip": "Note that the order of the array is not guaranteed to match the order of your data source if items are reordered."
  },
  "tr-05": {
    "prompt": "Analyze the code. By default, can a parent access the 'internalCount' of this child component via a template ref?",
    "explanation": "Components using <script setup> do not expose their internal state to the parent via refs unless you explicitly list them in defineExpose().",
    "interviewTip": "This is a key security/encapsulation feature of Vue 3 compared to the Options API."
  },
  "tr-06": {
    "prompt": "What should you do with a template ref in 'onUnmounted'?",
    "explanation": "Vue's reactivity system handles the lifecycle of the ref. When the element is unmounted, the ref.value is automatically set back to null.",
    "interviewTip": "However, you *should* use onUnmounted to destroy any third-party instances (like a map or chart) that were attached to that ref."
  },
  "tr-07": {
    "prompt": "How do you use a 'Function Ref' in Vue 3?",
    "explanation": "If you pass a function to :ref, Vue will call it with the element when it's mounted and with null when it's unmounted. This is useful for complex logic like dynamic refs in a loop.",
    "interviewTip": "This is the most flexible way to handle refs if a simple variable name isn't enough."
  },
  "tr-08": {
    "prompt": "In which scenarios is it appropriate to use Template Refs?",
    "explanation": "Template refs are for imperative DOM tasks. You should never use a ref to bypass Vue's reactivity for things that can be handled with props/state.",
    "interviewTip": "Always prefer the declarative approach (v-bind, v-if) unless you have no other choice."
  },
  "tr-09": {
    "prompt": "How do you create a template ref in the Composition API?",
    "explanation": "In Composition API, you create a ref with the same name as the template ref attribute. Vue automatically assigns the DOM element to it after mount.",
    "interviewTip": "The ref must be returned from setup() or used in <script setup> to be accessible in the template."
  },
  "tr-10": {
    "prompt": "When is a template ref populated with the actual DOM element?",
    "explanation": "Template refs are null during setup() and only get assigned after the component is mounted to the DOM.",
    "interviewTip": "Always check if the ref is not null before using it, or access it inside onMounted."
  },
  "pi-01": {
    "prompt": "Why is Pinia preferred over Vuex for Vue 3 applications?",
    "explanation": "Pinia simplifies state management by removing mutations. You simply update the state directly or via actions. It also offers excellent TypeScript autocompletion by default.",
    "interviewTip": "Mention that Pinia is modular by design; unlike Vuex's single giant store, Pinia encourages creating multiple small, focused stores."
  },
  "pi-02": {
    "prompt": "Analyze the code. What will happen if you destructure the store's state directly in a component?",
    "explanation": "Just like reactive objects, destructuring a Pinia store breaks reactivity. To maintain the link, you must use 'storeToRefs(store)'.",
    "interviewTip": "This is a frequent 'gotcha'. Use 'storeToRefs' for state and getters, but you can destructure actions (functions) normally."
  },
  "pi-03": {
    "prompt": "In Pinia, what is the equivalent of a 'Computed' property for a store?",
    "explanation": "Getters are exactly like computed properties for the store state. They are cached and only re-calculate when their dependencies change.",
    "interviewTip": "Getters can also return a function that accepts arguments (though these are not cached)."
  },
  "pi-04": {
    "prompt": "How do you reset a store back to its initial state in Pinia?",
    "explanation": "The $reset() method is a built-in utility that reverts the entire state of the store to the values defined in the initial state object.",
    "interviewTip": "Note that $reset() only works in 'Option Stores'. If you use 'Setup Stores' (function syntax), you have to implement your own reset logic."
  },
  "pi-05": {
    "prompt": "Analyze the code. Where should an API call (like fetching quiz questions) be placed in a Pinia store?",
    "explanation": "Actions are where logic and side effects (like API calls) live. Unlike Vuex, Pinia actions can be asynchronous and update the state directly.",
    "interviewTip": "In an interview, highlight that actions replace both 'actions' and 'mutations' from Vuex, simplifying the architecture."
  },
  "pi-06": {
    "prompt": "Which of these are valid ways to update multiple state properties at once in Pinia?",
    "explanation": "Pinia is flexible. Individual updates are fine, but $patch is more efficient for batching changes and allows complex logic within the function version of $patch.",
    "interviewTip": "$patch is useful when you want to group multiple changes into a single entry for the DevTools timeline."
  },
  "pi-07": {
    "prompt": "What is the purpose of 'defineStore'?",
    "explanation": "defineStore creates a hook (like useUserStore) that components can call to access the store instance.",
    "interviewTip": "Always mention that the first argument is a unique 'id' used for DevTools and store identification."
  },
  "pi-08": {
    "prompt": "How do you listen to state changes globally (e.g., for logging or persistence) in Pinia?",
    "explanation": "$subscribe() triggers whenever the state changes. It is often used to sync the store state with LocalStorage.",
    "interviewTip": "Many developers use the 'pinia-plugin-persistedstate' instead of writing manual subscriptions for storage."
  },
  "smp-09": {
    "prompt": "What is Pinia and how does it differ from Vuex?",
    "explanation": "Pinia removes concepts like mutations and modules, provides better TypeScript inference, and has a more intuitive API with stores.",
    "interviewTip": "Pinia is now the recommended state management solution for Vue 3 applications."
  },
  "smp-10": {
    "prompt": "How do you define a store in Pinia?",
    "explanation": "defineStore accepts an ID and either an options object (like Options API) or a setup function (like Composition API).",
    "interviewTip": "The setup store syntax is more flexible and aligns with Composition API patterns."
  },
  "ssr-01": {
    "prompt": "What is 'Hydration' in the context of Vue SSR?",
    "explanation": "The server sends 'dead' HTML for speed. Hydration is when Vue runs in the browser, matches the HTML to the Virtual DOM, and attaches event listeners to make the page 'live'.",
    "interviewTip": "If the HTML from the server doesn't match what the client generates, you get a 'Hydration Mismatch' error—a common SSR headache."
  },
  "ssr-02": {
    "prompt": "Analyze the Nuxt 3 code. What is the purpose of this built-in function?",
    "explanation": "useFetch is smart: it fetches the data on the server, serializes it into the HTML payload, and the client picks it up from there without making a second network request.",
    "interviewTip": "This 'Payload Extraction' is why Nuxt apps feel much faster and more integrated than custom SSR setups."
  },
  "ssr-03": {
    "prompt": "Which Nuxt.js directory is used to automatically generate routes based on file names?",
    "explanation": "Nuxt uses file-system routing. A file at `pages/about.vue` automatically becomes the `/about` route. No manual router configuration is needed.",
    "interviewTip": "For dynamic routes in Nuxt 3, you use square brackets, like `pages/quiz/[id].vue`."
  },
  "ssr-04": {
    "prompt": "Analyze the code. Where will this log appear in a Nuxt SSR environment?",
    "explanation": "Script setup code in SSR runs on the server to generate the HTML and then again on the client to hydrate the app.",
    "interviewTip": "Be careful! Code that uses browser-only globals like `window` or `localStorage` will crash on the server unless wrapped in a check or a hook like `onMounted`."
  },
  "ssr-05": {
    "prompt": "What is 'Static Site Generation' (SSG) in Nuxt?",
    "explanation": "SSG (via `nuxt generate`) creates a folder of HTML files that can be hosted on a CDN (like Vercel or Netlify). It is the fastest and most secure way to serve content.",
    "interviewTip": "Nuxt 3 supports 'Hybrid Rendering,' allowing you to choose SSR for some routes and SSG for others."
  },
  "ssr-06": {
    "prompt": "Which of these are valid ways to handle SEO metadata in a Nuxt 3 component?",
    "explanation": "Nuxt 3 provides multiple ways to manage the `<head>`. `useSeoMeta` is the most performant and type-safe for social sharing tags.",
    "interviewTip": "Since Nuxt renders HTML on the server, these tags are visible to search engine bots immediately."
  },
  "ssr-07": {
    "prompt": "Analyze the component code. What is the behavior of <ClientOnly>?",
    "explanation": "Some components (like those using D3 or Canvas) simply cannot run on the server. <ClientOnly> prevents server-side errors and hydration mismatches.",
    "interviewTip": "You can also provide a 'placeholder' slot to show a loading state on the server."
  },
  "ssr-08": {
    "prompt": "What is the role of 'Nitro' in the Nuxt 3 ecosystem?",
    "explanation": "Nitro is the powerful server backend for Nuxt. It enables features like API routes and allows the app to be deployed anywhere from a traditional server to Cloudflare Workers.",
    "interviewTip": "Mentioning Nitro shows you understand that Nuxt is a 'Full-Stack' framework, not just a frontend library."
  },
  "ssrn-09": {
    "prompt": "What is the main benefit of Server-Side Rendering (SSR) in Vue?",
    "explanation": "SSR renders the Vue application on the server, sending fully-formed HTML to the client, which improves perceived performance and SEO.",
    "interviewTip": "SSR comes with tradeoffs like increased server load and complexity. Consider Static Site Generation (SSG) for content-heavy sites."
  },
  "ssrn-10": {
    "prompt": "What is Nuxt.js?",
    "explanation": "Nuxt simplifies Vue development by providing conventions, automatic routing, SSR/SSG support, and a rich module ecosystem.",
    "interviewTip": "Nuxt 3 is built on Vue 3 and Vite, offering significantly better performance than Nuxt 2."
  },
  "sl-01": {
    "prompt": "What is the purpose of the <slot> element in a child component?",
    "explanation": "Slots act as placeholders. Whatever content the parent places between the child component's tags will replace the <slot> tag in the final render.",
    "interviewTip": "Content inside slots has access to the parent's data scope, not the child's (unless using Scoped Slots)."
  },
  "sl-02": {
    "prompt": "Analyze the code. How do you pass content to the 'header' slot specifically?",
    "explanation": "v-slot:header is the full syntax, and #header is the shorthand. Both are used on a <template> tag within the parent to target a named slot.",
    "interviewTip": "Named slots are essential for building layout components (like Cards or Page Shells)."
  },
  "sl-03": {
    "prompt": "What are 'Scoped Slots' used for?",
    "explanation": "Scoped slots allow a child to provide data to the content injected by the parent. For example, a List component providing individual 'item' data to a custom row template provided by the parent.",
    "interviewTip": "This is a high-level pattern for creating flexible, reusable components like Data Tables."
  },
  "sl-04": {
    "prompt": "Analyze the code. What will happen to the 'Modal' component in the DOM?",
    "explanation": "Teleport allows you to maintain the component's logical position (props/state) in the Vue tree while rendering it elsewhere in the HTML DOM.",
    "interviewTip": "This is the 'correct' way to handle Modals/Dialogs to avoid `z-index` and `overflow: hidden` issues from parent containers."
  },
  "sl-05": {
    "prompt": "How do you provide 'fallback' content that only shows if the parent doesn't provide any slot content?",
    "explanation": "Any content placed between <slot> and </slot> in the child component serves as the default content if the parent leaves the tags empty.",
    "interviewTip": "This is great for buttons where you want a default 'Submit' label but allow customization."
  },
  "sl-06": {
    "prompt": "Which of the following statements about <Teleport> are true?",
    "explanation": "Teleport targets can be CSS selectors (like '#app', '.container', or 'body'). Even though the DOM moves, the Vue logical tree remains intact.",
    "interviewTip": "Confirm that Teleport doesn't break the 'one-way data flow' or event bubbling in the Vue tree."
  },
  "sl-07": {
    "prompt": "Analyze the Scoped Slot syntax. How does the parent access the child's data?",
    "explanation": "The value of v-slot (here 'slotProps') is an object containing all the props passed to the slot from the child. You can also destructure it: v-slot=\"{ user }\".",
    "interviewTip": "Destructuring scoped slot props is standard practice for cleaner templates."
  },
  "sl-08": {
    "prompt": "What happens to the state of a component inside <Teleport> if it is disabled?",
    "explanation": "Teleport has a 'disabled' prop. This is useful for things like a 'PIP' (Picture-in-Picture) window that might toggle between being in the layout or floating.",
    "interviewTip": "Mentioning the 'disabled' prop shows you've read the advanced documentation for Teleport."
  },
  "st-09": {
    "prompt": "What is the purpose of the <Teleport> component in Vue 3?",
    "explanation": "Teleport is useful for modals, toasts, or tooltips that need to be rendered at the document body level to avoid z-index or overflow issues.",
    "interviewTip": "Teleport was called Portal in the RFC but was renamed before Vue 3 release."
  },
  "st-10": {
    "prompt": "How do you access slot content in the parent component?",
    "explanation": "Scoped slots allow child components to pass data back to the parent's slot content, enabling powerful patterns like renderless components.",
    "interviewTip": "Scoped slots are the foundation of many Vue UI libraries for maximum flexibility."
  },
  "perf-v-01": {
    "prompt": "Which directive should be used for content that never changes after the initial render to skip Virtual DOM tracking and patching?",
    "explanation": "v-once treats the element and its children as static content. Once rendered, Vue skips it entirely during update cycles, reducing the work of the Virtual DOM.",
    "interviewTip": "Use v-once for static help text or icons inside heavy components."
  },
  "perf-v-02": {
    "prompt": "Analyze the code. What is the benefit of using 'v-memo' here?",
    "explanation": "v-memo (Vue 3.2+) memoizes a sub-tree of the template. It only updates if the dependencies in the array change. This is a massive optimization for large lists where only one item changes at a time.",
    "interviewTip": "v-memo is essentially 'React.memo' but for a specific piece of a template."
  },
  "perf-v-03": {
    "prompt": "How does 'shallowRef' help with performance when dealing with massive objects (e.g., a huge JSON response)?",
    "explanation": "Standard 'ref' is deep. For a list of 10,000 items, Vue has to set up thousands of Proxies. 'shallowRef' avoids this overhead, only triggering an update if you replace the entire object.",
    "interviewTip": "This is the go-to solution for integrating large third-party instances (like OpenLayers or Three.js) into Vue."
  },
  "perf-v-04": {
    "prompt": "Analyze the code. Why might this 'computed' property cause performance issues?",
    "explanation": "Computed caching only works if the result is accessed again *without* the dependency changing. If the source data is a stream or updates rapidly, you are performing a heavy sort 60 times a second.",
    "interviewTip": "Consider debouncing the input data or moving the sort to a Web Worker if the calculation is too heavy."
  },
  "perf-v-05": {
    "prompt": "Which of the following are 'Tree Shaking' friendly practices in Vue 3?",
    "explanation": "Tree shaking allows the bundler to remove unused Vue features from your final JS file. Vue 3 was rewritten to be modular specifically for this reason.",
    "interviewTip": "Mention that Vue 3's core is 'tree-shakable,' meaning if you don't use `<Transition>`, it won't be in your final bundle."
  },
  "perf-v-06": {
    "prompt": "What is the purpose of the 'markRaw' utility?",
    "explanation": "Some objects (like complex class instances or React components being used inside Vue) should not be reactive. markRaw tags them so Vue ignores them, saving performance.",
    "interviewTip": "This is vital when wrapping external libraries that have their own internal state management."
  },
  "perf-v-07": {
    "prompt": "Analyze the code. Which directive is better for a component that toggles visibility 100 times per minute?",
    "explanation": "v-show only toggles CSS 'display: none'. v-if would destroy and re-create the component 100 times, which is very CPU intensive.",
    "interviewTip": "Always relate the choice to 'Initialization cost' vs 'Runtime cost'."
  },
  "perf-v-08": {
    "prompt": "What is 'Virtual List Rendering' (or Windowing)?",
    "explanation": "If you have 10,000 items, rendering 10,000 DOM nodes will crash the browser. Virtual lists only render the ~10 items the user actually sees.",
    "interviewTip": "Mention libraries like `vue-virtual-scroller` for high-performance lists."
  },
  "pov-09": {
    "prompt": "What is the purpose of v-memo directive in Vue 3?",
    "explanation": "v-memo is similar to React.memo but for templates. It's particularly useful for optimizing large v-for lists.",
    "interviewTip": "v-memo was introduced in Vue 3.2 and is most effective when combined with v-for."
  },
  "pov-10": {
    "prompt": "How can you reduce the bundle size of a Vue application?",
    "explanation": "Code splitting through dynamic imports allows you to load only the code needed for the current route, reducing initial bundle size.",
    "interviewTip": "Combine with tree-shaking, proper build configuration, and analyzing bundle size with tools like webpack-bundle-analyzer."
  },
  "lh-01": {
    "prompt": "Which lifecycle hook is the best place to perform an API call to fetch initial data for a component?",
    "explanation": "While you can initiate calls in setup(), onMounted ensures the component is already in the DOM. In Vue 3 Composition API, logic is often placed in setup/onMounted.",
    "interviewTip": "In SSR (Server-Side Rendering), onMounted does not run on the server, which is important for avoiding browser-only API errors."
  },
  "lh-02": {
    "prompt": "Analyze the code. What will be the output in the console when the component first loads?",
    "explanation": "The setup code (script setup) runs immediately. onMounted is a callback that waits until the component is mounted to the DOM, making it asynchronous relative to the script execution.",
    "interviewTip": "Understanding the execution order of 'setup' vs 'hooks' is a common junior-to-mid level interview check."
  },
  "lh-03": {
    "prompt": "Which hook is triggered specifically after a reactive data change causes the Virtual DOM to re-render and patch the physical DOM?",
    "explanation": "onUpdated is called after the DOM has been patched. It is useful for DOM-dependent logic that must react to state changes.",
    "interviewTip": "Warning: Avoid changing state inside onUpdated, as it can lead to an infinite re-render loop."
  },
  "lh-04": {
    "prompt": "Analyze the code. What is the correct way to clean up a timer to prevent memory leaks?",
    "explanation": "onUnmounted is the ideal place to clean up side effects like intervals, event listeners, or manual DOM observers when the component is removed.",
    "interviewTip": "Always mention 'cleaning up global event listeners' (like window.addEventListener) when asked about onUnmounted."
  },
  "lh-05": {
    "prompt": "For a component wrapped in <KeepAlive>, which hook triggers every time the component is brought back into view?",
    "explanation": "KeepAlive components are cached and not unmounted. Therefore, onMounted only runs once. onActivated runs every time the cached component is inserted into the DOM.",
    "interviewTip": "KeepAlive is frequently used for tabbed interfaces to preserve user input or scroll position."
  },
  "lh-06": {
    "prompt": "Which of these hooks are only used for debugging and performance tracking in development mode?",
    "explanation": "onRenderTracked and onRenderTriggered allow you to inspect which dependency is causing a component to re-render. They do not run in production.",
    "interviewTip": "These are 'advanced' hooks. Knowing them shows you have experience optimizing complex Vue apps."
  },
  "lh-07": {
    "prompt": "Why can't you access 'Template Refs' (elements marked with ref=\"...\") inside the 'setup()' body directly?",
    "explanation": "Setup executes before the component is mounted. The DOM elements don't exist yet, so the ref will be null. You must wait for onMounted to access them.",
    "interviewTip": "This is why onMounted is mandatory for third-party library initialization (like Chart.js or D3.js) that requires a DOM node."
  },
  "lh-08": {
    "prompt": "In the Composition API, where should you place the logic that was previously in the 'beforeCreate' and 'created' hooks of the Options API?",
    "explanation": "Since setup() runs at the same time as the creation phase, there's no need for explicit beforeCreate/created hooks in the Composition API.",
    "interviewTip": "This simplifies the component logic significantly compared to the Options API."
  },
  "lh-09": {
    "prompt": "Which lifecycle hook is called after the component has been mounted to the DOM?",
    "explanation": "onMounted is called after the component's template has been rendered and inserted into the DOM. This is where you can safely access DOM elements.",
    "interviewTip": "Use onMounted for DOM manipulation, third-party library initialization, or API calls that need the component to be visible."
  },
  "lh-10": {
    "prompt": "What is the Composition API equivalent of the Options API `beforeDestroy` hook?",
    "explanation": "Vue 3 renamed beforeDestroy to beforeUnmount and destroyed to unmounted to better reflect what actually happens.",
    "interviewTip": "Use onBeforeUnmount or onUnmounted to clean up timers, event listeners, or subscriptions."
  },
  "clr-01": {
    "prompt": "What is the primary architectural difference between 'v-if' and 'v-show'?",
    "explanation": "v-if is 'real' conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created. v-show is much simpler—the element always remains in the DOM.",
    "interviewTip": "Use v-if for conditions that rarely change at runtime; use v-show if you need to toggle something very frequently (like a tab or a tooltip)."
  },
  "clr-02": {
    "prompt": "Analyze the code. What will happen if 'items' is an empty array []?",
    "explanation": "v-else must follow a v-if or v-else-if. It cannot be used with v-for. To handle empty lists, you should use v-if=\"items.length === 0\" on a separate element.",
    "interviewTip": "This is a common mistake. v-for does not have a built-in 'else' block."
  },
  "clr-03": {
    "prompt": "Why is it strongly recommended to always provide a unique ':key' when using 'v-for'?",
    "explanation": "Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements in-place. This can lead to bugs with form state or animations.",
    "interviewTip": "Never use 'index' as a key if the list can be reordered, filtered, or if items can be deleted. Use unique IDs from your data."
  },
  "clr-04": {
    "prompt": "Analyze the code. In Vue 3, which directive has higher priority when used on the same element?",
    "explanation": "In Vue 3, v-if has a higher priority than v-for. This means the v-if doesn't have access to variables from the v-for scope, and the code above will likely throw an error because 'item' is not defined when v-if runs.",
    "interviewTip": "In Vue 2, the priority was reversed. Regardless of the version, you should avoid using both on the same element. Wrap the list in a <template v-for> or use a computed property to filter the list beforehand."
  },
  "clr-05": {
    "prompt": "How do you render a block of multiple elements without adding an extra wrapper div to the DOM?",
    "explanation": "The <template> tag acts as an invisible wrapper. It allows you to use directives like v-if or v-for on a group of elements without affecting the final HTML structure.",
    "interviewTip": "This is perfect for keeping your DOM tree flat and clean."
  },
  "clr-06": {
    "prompt": "Which of these are valid ways to iterate using v-for?",
    "explanation": "Vue is quite flexible. You can iterate over arrays, objects (value, key, index), and even integer ranges (1 to N). String iteration is technically possible but rarely used in practice.",
    "interviewTip": "When iterating over an object, the order is based on Object.keys() enumeration order, which may vary across browsers."
  },
  "clr-07": {
    "prompt": "Analyze the code. What is the most performant way to filter this list in a production app?",
    "explanation": "Filtering with a computed property is the best approach. It's more readable, and because of caching, the filter only runs when the 'users' list actually changes.",
    "interviewTip": "Computed properties for filtered lists also make your component logic easier to unit test."
  },
  "clr-08": {
    "prompt": "What happens if two items in a v-for list have the same ':key'?",
    "explanation": "Duplicate keys confuse the Virtual DOM's reconciliation process. Vue will warn you in the console, and you may see elements 'flickering' or showing the wrong state when the list changes.",
    "interviewTip": "Always ensure keys are truly unique within the list."
  },
  "clr-09": {
    "prompt": "What is the difference between v-if and v-show?",
    "explanation": "v-if has higher toggle cost (destroys/recreates elements), while v-show has higher initial render cost (renders everything but hides with CSS).",
    "interviewTip": "Use v-if for infrequent toggles, v-show for frequent toggles."
  },
  "clr-10": {
    "prompt": "Why should you avoid using v-if and v-for on the same element?",
    "explanation": "In Vue 3, v-for has higher priority, so v-if will run on each iteration. This is inefficient. Use a computed property or wrap with a template tag instead.",
    "interviewTip": "This is a common interview question about Vue best practices and performance."
  },
  "cw-01": {
    "prompt": "What is the primary advantage of using a 'computed' property over a regular 'method' in a template?",
    "explanation": "Caching is the killer feature. If you have an expensive calculation in a computed property, it will only run once and reuse that result until its source data changes. Methods run every time the component re-renders.",
    "interviewTip": "Use computed for data transformation (getters) and methods for event handling or actions."
  },
  "cw-02": {
    "prompt": "Analyze the code. How many times will 'Calculating...' be logged if the component re-renders 5 times, but 'count' never changes?",
    "explanation": "Because of caching, the computed function only executes once. As long as 'count' is the same, Vue returns the stored value immediately.",
    "interviewTip": "Computed properties are 'lazy'. If they aren't used in a template or another effect, they don't even run once!"
  },
  "cw-03": {
    "prompt": "When should you use a 'watcher' (watch) instead of a 'computed' property?",
    "explanation": "Computed properties must be 'pure' (no side effects) and return a value. Watchers are designed to execute logic (like saving to localStorage or fetching data) when a value changes.",
    "interviewTip": "Rule of thumb: Computed = Getters; Watchers = Side Effects."
  },
  "cw-04": {
    "prompt": "How do you make a watcher trigger immediately upon component creation, rather than waiting for the first change?",
    "explanation": "The 'immediate: true' option forces the watcher callback to run once with the initial value right when the watcher is initialized.",
    "interviewTip": "This is very useful for fetching data based on a prop as soon as the component mounts."
  },
  "cw-05": {
    "prompt": "What does the 'deep: true' option do in a watcher?",
    "explanation": "By default, watchers only track 'shallow' changes (the reference of the object). 'deep' recursively traverses the object to catch changes in sub-properties.",
    "interviewTip": "Warning: Deep watching large objects can be very expensive for performance."
  },
  "cw-06": {
    "prompt": "Analyze the code. Why is the watcher NOT triggering when 'user.name' changes?",
    "explanation": "When watching a 'ref' containing an object, the watcher is triggered only if the entire object is replaced. Internal property changes are ignored unless 'deep' is used or you watch a getter: `() => user.value.name`.",
    "interviewTip": "In Vue 3, watching a 'reactive' object automatically creates a deep watcher, but watching a 'ref' does not."
  },
  "cw-07": {
    "prompt": "Which of these are valid ways to create a 'Writable Computed' property (getter and setter)?",
    "explanation": "While most computed properties are getters, you can provide a setter to handle updates (e.g., parsing a 'fullName' string into 'firstName' and 'lastName').",
    "interviewTip": "Writable computed properties are excellent for wrapping state management (like Pinia) into a clean v-model."
  },
  "cw-08": {
    "prompt": "What is the difference between 'watch' and 'watchEffect'?",
    "explanation": "watchEffect is more concise because you don't list dependencies; it 'discovers' them during execution. However, 'watch' is more precise and gives you access to 'oldValue'.",
    "interviewTip": "Use 'watch' if you need the previous value; use 'watchEffect' for simpler dependency tracking."
  },
  "cw-09": {
    "prompt": "What is the difference between a computed property and a method in Vue?",
    "explanation": "Computed properties are only re-evaluated when their dependencies change. Methods run on every render, making them less efficient for expensive operations.",
    "interviewTip": "Use computed for derived state, methods for actions or when you need to pass arguments."
  },
  "cw-10": {
    "prompt": "When should you use a watcher with the `immediate: true` option?",
    "explanation": "By default, watchers only run when the watched value changes. `immediate: true` makes the callback run once immediately with the current value.",
    "interviewTip": "This is useful for initializing data based on props or performing initial API calls."
  },
  "ca-01": {
    "prompt": "What are the three main steps to implement React Context?",
    "explanation": "You first create the context object, wrap the parent tree with a Provider, and then use a hook or consumer in the child to access the data.",
    "interviewTip": "The most common way to 'consume' today is via the 'useContext' hook."
  },
  "ca-02": {
    "prompt": "What happens to components consuming a Context when the Provider's 'value' prop updates?",
    "explanation": "Context triggers a re-render for all consumers whenever the value changes. This is why you should keep context values stable or split large contexts.",
    "interviewTip": "To optimize, consider memoizing the context value object using 'useMemo'."
  },
  "ca-03": {
    "prompt": "What is the result of the following code if 'UserContext' has no Provider above the Header?",
    "explanation": "If no Provider is found in the tree, 'useContext' returns the default value passed to 'createContext(defaultValue)'.",
    "interviewTip": "Default values are useful for testing components in isolation without wrapping them in providers."
  },
  "ca-04": {
    "prompt": "Which of the following are good use cases for React Context?",
    "explanation": "Context is great for 'global' data that doesn't change extremely often. For high-frequency updates, Context can cause performance bottlenecks.",
    "interviewTip": "For high-frequency state, libraries like Redux, Zustand, or Recoil are often better choices."
  },
  "ca-05": {
    "prompt": "Analyze the code. How should 'App' be structured to share 'theme'?",
    "explanation": "The 'value' prop is the standard way to pass data into the Context tree. Any component inside <Layout /> can now access 'theme'.",
    "interviewTip": "If you also want to allow children to change the theme, pass `{ theme, setTheme }` as the value."
  },
  "ca-06": {
    "prompt": "Why is 'useContext' preferred over the older 'Context.Consumer' component?",
    "explanation": "Before hooks, you had to use a render prop pattern which made the JSX tree very deep and hard to follow.",
    "interviewTip": "Flattening the component tree is one of the primary aesthetic wins of the Hooks API."
  },
  "ca-07": {
    "prompt": "Can you use multiple Providers in a single application?",
    "explanation": "Nesting providers is standard practice. A component will always consume the value from the *closest* provider of that specific context above it in the tree.",
    "interviewTip": "This is often referred to as 'Context Composition'."
  },
  "ca-08": {
    "prompt": "What is the primary risk of putting too much data into a single Context object?",
    "explanation": "Because Context updates trigger a re-render for all consumers, large 'monolithic' contexts can lead to performance lag.",
    "interviewTip": "The fix is 'Context Splitting'—create separate contexts for logically different data (e.g., UserContext and ThemeContext)."
  },
  "vca-09": {
    "prompt": "How do you provide and inject dependencies in the Composition API?",
    "explanation": "provide() and inject() allow you to pass data down the component tree without props. This is Vue's dependency injection system.",
    "interviewTip": "Mention that inject() can take a default value as a second argument, and that provided values are not reactive unless you explicitly make them so."
  },
  "vca-10": {
    "prompt": "What is 'effectScope()' used for in Vue 3?",
    "explanation": "effectScope() is an advanced API that allows you to manually control when effects (watchers, computed, etc.) are created and destroyed. This is useful for plugin authors and advanced composables.",
    "interviewTip": "Mentioning effectScope shows deep knowledge of Vue's reactivity system and is rarely asked in junior interviews."
  },
  "comp-01": {
    "prompt": "What is the primary difference between a 'Composable' and a regular utility function?",
    "explanation": "A utility function like 'sum(a, b)' just returns a value. A Composable like 'useMouse()' returns reactive refs that update automatically as the user moves their mouse.",
    "interviewTip": "Keywords to use: 'Stateful Logic', 'Reusability', and 'Composition API'."
  },
  "comp-02": {
    "prompt": "What is the naming convention for Vue Composables?",
    "explanation": "Starting with 'use' is the community standard. It immediately signals to other developers that the function returns reactive state.",
    "interviewTip": "This mirrors the 'use' convention from React Hooks, making the transition easier for cross-framework developers."
  },
  "comp-03": {
    "prompt": "Analyze the code. What is the correct way to return data from a Composable to ensure easy destructuring in a component?",
    "explanation": "Returning an object is preferred in Vue. It allows the component to destructure only the parts it needs and rename them if necessary, without being forced into a specific array order.",
    "interviewTip": "Mention that returning an object is more flexible for future-proofing your API."
  },
  "comp-04": {
    "prompt": "Why is it important to use 'toValue()' (or 'unref') inside a Composable when handling input arguments?",
    "explanation": "toValue() (introduced in Vue 3.3) normalizes the input. This makes your Composable much more flexible for the consumer.",
    "interviewTip": "Using toValue/unref is the hallmark of a 'well-designed' library-level Composable."
  },
  "comp-05": {
    "prompt": "Analyze the code. What is a common pitfall when using 'reactive' inside a Composable and returning it directly?",
    "explanation": "Destructuring reactive objects kills the reactivity link. To fix this, the Composable should return 'toRefs(state)'.",
    "interviewTip": "Always recommend 'toRefs' when returning a reactive object from a Composable."
  },
  "comp-06": {
    "prompt": "Where can you safely call a Composable that uses lifecycle hooks like 'onMounted'?",
    "explanation": "Lifecycle hooks must be registered during the synchronous execution of 'setup'. If you call a Composable after an 'await', Vue loses track of which component instance the hook belongs to.",
    "interviewTip": "This is a strict 'Rule of Composables'. Always call them at the top level of your script."
  },
  "comp-07": {
    "prompt": "What are the advantages of using Composables over the legacy 'Mixins' pattern?",
    "explanation": "Mixins are 'invisible' injections that make code hard to trace. Composables make it clear where every piece of data originates.",
    "interviewTip": "If asked about Mixins, call them 'opaque' and describe Composables as 'transparent and explicit'."
  },
  "comp-08": {
    "prompt": "Can one Composable call another Composable?",
    "explanation": "Nesting Composables is a standard practice (e.g., 'useAuth' might use 'useFetch' and 'useStorage' internally).",
    "interviewTip": "This is known as 'Composable Composition'."
  },
  "comp-09": {
    "prompt": "What is a composable in Vue 3?",
    "explanation": "Composables are the Vue 3 equivalent of mixins or higher-order components, but with better composition and no naming conflicts.",
    "interviewTip": "Composables should be named with the \"use\" prefix (e.g., useMouse, useFetch) following React hooks convention."
  },
  "comp-10": {
    "prompt": "What should a composable return?",
    "explanation": "Composables typically return an object containing refs, reactive objects, computed properties, and methods that components can destructure and use.",
    "interviewTip": "Return only what the consumer needs to keep the API clean and focused."
  },
  "cb-01": {
    "prompt": "In Vue, what is the 'One-Way Data Flow' principle regarding props?",
    "explanation": "This prevents child components from accidentally mutating the parent's state, which would make the data flow hard to understand and debug.",
    "interviewTip": "If you try to mutate a prop in a child, Vue will throw a warning in the console. If you need to change it, use a local 'ref' or emit an event."
  },
  "cb-02": {
    "prompt": "Analyze the code. How does the child component notify the parent that a button was clicked?",
    "explanation": "Custom events use the v-on (or @) syntax just like native DOM events. The parent listens for the event name defined in the child's $emit call.",
    "interviewTip": "Vue 3 recommends declaring emitted events using the 'emits' option or 'defineEmits' for better documentation and validation."
  },
  "cb-03": {
    "prompt": "How do you define props with validation in a Vue 3 <script setup> component?",
    "explanation": "defineProps is a compiler macro available inside <script setup>. It doesn't need to be imported and allows for runtime validation of the data being passed.",
    "interviewTip": "Prop validation is your first line of defense against bugs in large teams. Always use object syntax for props instead of arrays."
  },
  "cb-04": {
    "prompt": "What are 'Fallthrough Attributes' in Vue 3?",
    "explanation": "If a component has a single root element, attributes passed to it (that aren't declared as props) 'fall through' to that root element.",
    "interviewTip": "You can disable this behavior by setting 'inheritAttrs: false' and manually binding attributes using '$attrs'."
  },
  "cb-05": {
    "prompt": "Analyze the code. What is the correct way for the parent to pass a dynamic numeric value to the child?",
    "explanation": "Without the colon (:), '42' is passed as a static string. With the colon (:), it is evaluated as a JavaScript expression, passing it as a number.",
    "interviewTip": "This is a common beginner mistake. Use v-bind (:) for any value that isn't a literal string."
  },
  "cb-06": {
    "prompt": "Which of the following are valid ways to communicate between components that are NOT in a direct parent-child relationship?",
    "explanation": "Provide/Inject is great for 'Prop Drilling' avoidance. Pinia is for global state. Direct mutation of $parent is highly discouraged as it creates tight coupling.",
    "interviewTip": "Mention Provide/Inject as the Vue equivalent to React's Context API."
  },
  "cb-07": {
    "prompt": "What happens if a child emits an event but the parent is not listening for it?",
    "explanation": "Unlike DOM events, Vue's custom events do not bubble by default. If no listener is present on the immediate parent, the event is simply lost.",
    "interviewTip": "This is why debugging missing events usually starts with checking the event name spelling in the @listener."
  },
  "cb-08": {
    "prompt": "Analyze the code. Why is 'defineEmits' used here?",
    "explanation": "Using defineEmits makes your component's 'contract' explicit, helping developers (and IDEs) understand how to interact with it.",
    "interviewTip": "In TypeScript, you can even define the types of the arguments passed with the event using defineEmits<{ (e: 'change', id: number): void }>."
  },
  "cb-09": {
    "prompt": "What is the purpose of the `key` attribute when rendering lists in Vue?",
    "explanation": "Keys give Vue a hint about the identity of each node. Without keys, Vue uses an algorithm that minimizes element movement but can cause issues with stateful components or transitions.",
    "interviewTip": "Always use unique, stable keys (like IDs) rather than array indexes for dynamic lists."
  },
  "cb-10": {
    "prompt": "How do you emit a custom event from a child component to its parent in Vue 3?",
    "explanation": "In <script setup>, you use defineEmits to declare events, then call emit with the event name and optional payload.",
    "interviewTip": "Vue 3 encourages explicit event declarations for better type safety and documentation."
  },
  "csb-01": {
    "prompt": "Analyze the code. Which class will be applied to the div if 'isActive' is true and 'hasError' is false?",
    "explanation": "In the object syntax, the key is the class name and the value is a boolean. Since isActive is true, 'active' is applied. Since hasError is false, 'text-danger' is omitted.",
    "interviewTip": "Keys with dashes, like 'text-danger', must be wrapped in quotes in the object syntax."
  },
  "csb-02": {
    "prompt": "How can you apply multiple classes by combining them in a list?",
    "explanation": "The array syntax allows you to apply a list of classes. You can even nest the object syntax inside the array syntax for complex logic.",
    "interviewTip": "Using `[isActive ? activeClass : '', errorClass]` is a common pattern for conditional classes within an array."
  },
  "csb-03": {
    "prompt": "When binding to the 'style' attribute, how should multi-word CSS properties (like 'font-size') be written?",
    "explanation": "Vue is flexible. You can use camelCase (`fontSize`) which is closer to JS DOM property names, or kebab-case strings (`'font-size'`).",
    "interviewTip": "CamelCase is generally preferred in the Vue community for cleaner code without extra quotes."
  },
  "csb-04": {
    "prompt": "What happens if you have both a standard 'class' and a bound ':class' on the same element?",
    "explanation": "Vue intelligently merges static and dynamic classes. If isActive is true, the result will be class=\"base active\".",
    "interviewTip": "This merging behavior also applies to 'style' and ':style' bindings."
  },
  "csb-05": {
    "prompt": "Analyze the code. What is the benefit of this pattern?",
    "explanation": "Binding to a computed object is a best practice for complex class logic. It keeps your templates readable and utilizes computed caching.",
    "interviewTip": "In a Senior dev interview, always suggest moving complex ternary operators from templates into computed properties."
  },
  "csb-06": {
    "prompt": "Which of these are valid ways to scoped CSS to a single component in Vue?",
    "explanation": "The 'scoped' attribute uses data-attributes to isolate styles. CSS Modules (module) injects a $style object into the component.",
    "interviewTip": "Be careful with 'scoped'—it doesn't affect child components' internals, only their root element."
  },
  "csb-07": {
    "prompt": "How does Vue handle CSS properties that require vendor prefixes (e.g., 'user-select')?",
    "explanation": "When you use a CSS property that requires a vendor prefix in :style, Vue will automatically detect and add the appropriate prefixes.",
    "interviewTip": "This 'Auto-prefixing' is built into Vue's runtime style binding logic."
  },
  "csb-08": {
    "prompt": "What is the result of passing an array of objects to :style?",
    "explanation": "The array syntax for :style allows you to apply multiple style objects to the same element, with later objects overriding properties in previous ones.",
    "interviewTip": "This is very useful for composing base styles with conditional modifiers."
  },
  "csb-09": {
    "prompt": "How do you bind multiple CSS classes conditionally in Vue?",
    "explanation": "Object syntax allows you to toggle classes based on reactive data. You can also combine object and array syntax.",
    "interviewTip": "For class names with hyphens, use quotes around the key."
  },
  "csb-10": {
    "prompt": "What is the benefit of using :style binding with an object?",
    "explanation": "Style binding accepts an object where keys are CSS property names (camelCase or kebab-case) and values are reactive data.",
    "interviewTip": "Vue automatically adds vendor prefixes for properties that require them."
  },
  "as-01": {
    "prompt": "Which function is used to define a component that is loaded lazily from the server only when it is rendered?",
    "explanation": "defineAsyncComponent accepts a loader function that returns a Promise (usually a dynamic import). Vue handles the loading logic automatically.",
    "interviewTip": "Mention that this is a key technique for reducing the 'Initial Bundle Size' of your application."
  },
  "as-02": {
    "prompt": "Analyze the code. What will happen while 'AdminPanel' is downloading?",
    "explanation": "By default, an async component won't show anything during loading. You can provide a 'loadingComponent' option in defineAsyncComponent or wrap the usage in a <Suspense> tag.",
    "interviewTip": "Using a skeleton loader as the 'loadingComponent' provides a much better UX than a blank space."
  },
  "as-03": {
    "prompt": "What are the two 'slots' provided by the <Suspense> component?",
    "explanation": "The #default slot contains the content that might take time to load, and the #fallback slot contains what to show in the meantime (e.g., a spinner).",
    "interviewTip": "Note that as of Vue 3.x, <Suspense> is still technically an 'experimental' feature, though it is widely used."
  },
  "as-04": {
    "prompt": "Analyze the code. What makes this component 'async' and capable of triggering a <Suspense> boundary?",
    "explanation": "In Vue 3, if a <script setup> contains top-level 'await', the component automatically becomes an 'async dependency' and must be wrapped in <Suspense> by its parent.",
    "interviewTip": "This is a very elegant way to handle data fetching, as you don't need a separate 'loading' state ref inside the component."
  },
  "as-05": {
    "prompt": "How do you handle errors (like network failure) when an async component fails to load?",
    "explanation": "While defineAsyncComponent has an 'errorComponent' option, the standard way to catch errors from async dependencies in a tree is the onErrorCaptured hook.",
    "interviewTip": "You can also use the 'error' slot if your project uses a specialized wrapper, but onErrorCaptured is the official global/parent solution."
  },
  "as-06": {
    "prompt": "Which of these are valid options when configuring 'defineAsyncComponent'?",
    "explanation": "delay prevents 'flickering' for fast connections. timeout prevents users from waiting forever. suspensible (default: true) allows the component to control the parent Suspense state.",
    "interviewTip": "Set 'delay: 0' if you want the loading spinner to appear immediately, even for fast loads."
  },
  "as-07": {
    "prompt": "Can <Suspense> handle multiple nested async components simultaneously?",
    "explanation": "Suspense is designed to coordinate multiple async dependencies. The fallback stays visible until the entire tree of async components underneath is ready.",
    "interviewTip": "This prevents 'pop-in' effects where different parts of a page load at different times."
  },
  "as-08": {
    "prompt": "What is the purpose of the 'onError' retry function in defineAsyncComponent?",
    "explanation": "The 'retry' callback allows you to attempt to reload the component, which is useful for handling temporary network issues.",
    "interviewTip": "This is a great 'Senior' level feature to mention for building resilient applications."
  },
  "acs-09": {
    "prompt": "How do you define an async component in Vue 3?",
    "explanation": "defineAsyncComponent accepts a loader function that returns a Promise resolving to the component definition, enabling code splitting.",
    "interviewTip": "You can provide loading, error, delay, and timeout options for better UX."
  },
  "acs-10": {
    "prompt": "What is the purpose of the <Suspense> component?",
    "explanation": "Suspense allows you to show a loading state while async components or async setup() are resolving, providing a better user experience.",
    "interviewTip": "Suspense is still experimental in Vue 3 but is a core feature for async data fetching patterns."
  },
  "ui-01": {
    "prompt": "Which component is the modern, more flexible alternative to TouchableOpacity and TouchableHighlight for handling touch interactions?",
    "explanation": "Pressable is a core component that provides more granular control over the various stages of press interactions (hover, press, focus).",
    "interviewTip": "Use Pressable when you need a highly customized hit box or complex feedback states."
  },
  "ui-02": {
    "prompt": "What is the primary visual difference between TouchableOpacity and TouchableHighlight?",
    "explanation": "TouchableOpacity provides feedback by reducing the opacity (transparency) of the wrapped component. TouchableHighlight requires an 'underlayColor' and adds a solid highlight effect.",
    "interviewTip": "TouchableOpacity is the most commonly used for general buttons due to its simplicity."
  },
  "ui-03": {
    "prompt": "How do you mask the characters typed into a TextInput (e.g., for a password)?",
    "explanation": "Setting 'secureTextEntry' to true replaces characters with dots/stars, following native OS password input behavior.",
    "interviewTip": "Don't forget to pair this with 'autoCorrect={false}' and 'autoCapitalize=\"none\"' for login screens."
  },
  "ui-04": {
    "prompt": "Which prop is used in TextInput to define which type of keyboard should appear (e.g., numeric, email)?",
    "explanation": "The 'keyboardType' prop allows you to set specialized keyboards like 'numeric', 'email-address', or 'phone-pad'.",
    "interviewTip": "Remember that keyboard types can vary slightly between iOS and Android."
  },
  "ui-05": {
    "prompt": "What is the purpose of the <KeyboardAvoidingView> component?",
    "explanation": "Virtual keyboards take up screen space. KeyboardAvoidingView adjusts its position or padding so that inputs remain visible to the user.",
    "interviewTip": "The 'behavior' prop is key here; usually, 'padding' works best on iOS and 'height' or 'none' on Android."
  },
  "ui-06": {
    "prompt": "Which of these are valid ways to detect that a user has finished typing in a TextInput?",
    "explanation": "onEndEditing triggers when focus is lost; onSubmitEditing when the 'return' key is pressed; onBlur when the input loses focus.",
    "interviewTip": "Use 'onSubmitEditing' for single-line inputs to trigger form submission."
  },
  "ui-07": {
    "prompt": "In React Native, what is the 'hitSlop' prop used for in touchable components?",
    "explanation": "Mobile screens can be hard to tap. 'hitSlop' makes it easier for users to hit small icons by extending the interactive area.",
    "interviewTip": "This is a great 'Senior Dev' trick for improving UX on small UI elements like 'Close' buttons."
  },
  "ui-08": {
    "prompt": "Analyze the code. Why might the keyboard NOT close when clicking 'Submit'?",
    "explanation": "React Native doesn't automatically close the keyboard on all actions. You typically import the 'Keyboard' module and call 'Keyboard.dismiss()'.",
    "interviewTip": "Another way is to wrap the screen in a 'TouchableWithoutFeedback' that calls dismiss."
  },
  "ui-09": {
    "prompt": "What is the result of using 'onChange' vs 'onChangeText' on a TextInput?",
    "explanation": "onChangeText is a convenience prop that returns just the text. onChange returns a full SyntheticEvent object containing the text in 'event.nativeEvent.text'.",
    "interviewTip": "In 99% of cases, you should use 'onChangeText' for cleaner state updates."
  },
  "ui-10": {
    "prompt": "How do you make a TextInput multi-line for a biography or comment section?",
    "explanation": "The 'multiline' prop allows the text to wrap and the input to grow or scroll vertically.",
    "interviewTip": "Pair this with 'textAlignVertical=\"top\"' on Android to ensure the text starts at the top of the box."
  },
  "ui-11": {
    "prompt": "Which of these are feedback states provided by the 'Pressable' component's style function?",
    "explanation": "Pressable allows you to pass a function to 'style' or 'children' that provides these boolean states to help you render dynamic UI.",
    "interviewTip": "This is why Pressable is replacing Touchable components; it's much more descriptive."
  },
  "ui-12": {
    "prompt": "What is the purpose of 'autoCapitalize=\"none\"' in an email input?",
    "explanation": "Most mobile keyboards capitalize the first letter by default. This is annoying for email addresses which are usually lowercase.",
    "interviewTip": "Valid values are 'none', 'sentences', 'words', and 'characters'."
  },
  "ui-13": {
    "prompt": "How do you ensure the 'Submit' button on the keyboard is actually visible and labeled correctly?",
    "explanation": "returnKeyType changes the text or icon of the 'Enter' key on the virtual keyboard to better match the user's action.",
    "interviewTip": "Common values include 'search', 'next', 'done', and 'send'."
  },
  "ui-14": {
    "prompt": "What is the difference between a <Button> and a <TouchableOpacity>?",
    "explanation": "The core <Button> is very limited (only title and color). If you want a button with an icon, custom borders, or specific padding, you must use a Touchable or Pressable wrapper around a View.",
    "interviewTip": "Most production apps avoid the <Button> component entirely in favor of custom-built button components."
  },
  "tm-01": {
    "prompt": "Which testing framework is the default for React Native and handles the execution of unit tests?",
    "explanation": "Jest is the standard test runner for React Native. It comes pre-configured with a 'react-native' preset that mocks the mobile environment.",
    "interviewTip": "Mention that Jest's 'Snapshot Testing' is a popular but controversial way to catch unintended UI changes."
  },
  "tm-02": {
    "prompt": "What is the main philosophy of 'React Native Testing Library' (RNTL)?",
    "explanation": "RNTL encourages testing *behavior* rather than *implementation*. If you refactor your code but the user still sees 'Submit', your tests should still pass.",
    "interviewTip": "Avoid using 'enzyme' in modern React Native; RNTL is the community-standard replacement."
  },
  "tm-03": {
    "prompt": "Analyze the code. How do you simulate a user typing into the 'Question' input in a test?",
    "explanation": "In RNTL, 'fireEvent.changeText' is the specialized event for TextInput components that directly mimics the 'onChangeText' prop.",
    "interviewTip": "Always use 'fireEvent.press' for buttons and 'fireEvent.changeText' for inputs."
  },
  "tm-04": {
    "prompt": "What is 'Detox' used for in the React Native ecosystem?",
    "explanation": "Detox runs your app in a real simulator and interacts with it like a user. It is called 'gray-box' because it synchronizes with the app's internal state to prevent flaky tests.",
    "interviewTip": "Compare Detox to Cypress; it’s the closest mobile equivalent for full-flow automation."
  },
  "tm-05": {
    "prompt": "Why do you need to mock native modules (like 'react-native-reanimated' or 'AsyncStorage') in Jest?",
    "explanation": "Jest runs in a Node environment, not a mobile OS. Native modules (C++/Java/Swift) don't exist there, so you must provide a JS 'mock' implementation.",
    "interviewTip": "Most popular libraries (like React Navigation) provide their own Jest mocks that you can simply import in your 'jest.setup.js'."
  },
  "tm-06": {
    "prompt": "Which of these are valid RNTL 'queries' for finding elements in your UI?",
    "explanation": "getByText and getByTestId are the most common. queryBy... is used when you want to assert that an element *doesn't* exist (it returns null instead of throwing).",
    "interviewTip": "Favor 'getByText' or 'getByLabelText' (accessibility) over 'getByTestId' whenever possible to ensure your app is accessible."
  },
  "tm-07": {
    "prompt": "What is the purpose of 'jest.useFakeTimers()'?",
    "explanation": "If your Mock Interview app has a '3-second countdown' before a question, fake timers let you skip those 3 seconds instantly during a test.",
    "interviewTip": "Don't forget to call 'jest.runAllTimers()' or 'jest.advanceTimersByTime()' after using this."
  },
  "tm-08": {
    "prompt": "Analyze the Detox test snippet. What is it verifying?",
    "explanation": "This is a typical E2E test. It checks the visibility of elements and performs actions (tap) to verify a multi-screen navigation flow.",
    "interviewTip": "In Detox, 'by.id' refers to the 'testID' prop you add to your React Native components."
  },
  "tm-09": {
    "prompt": "How do you test a component that uses a hook from a library (like 'useNavigation') without crashing?",
    "explanation": "Just like in your app, hooks often need their context. Wrapping your test component in a 'Wrapper' (like a NavigationContainer or Redux Provider) is the standard fix.",
    "interviewTip": "You can create a custom 'render' function that automatically wraps every component in all necessary providers."
  },
  "tm-10": {
    "prompt": "What does 'coverage' represent in a Jest report?",
    "explanation": "Coverage helps you identify 'dark spots' in your code that haven't been tested yet.",
    "interviewTip": "Warning: 100% coverage doesn't mean your app is bug-free; it just means every line was executed once."
  },
  "sp-01": {
    "prompt": "Which library is the standard, community-recommended replacement for the deprecated core 'AsyncStorage'?",
    "explanation": "AsyncStorage was moved out of the React Native core into the community repository to allow for faster updates and maintenance.",
    "interviewTip": "Always specify that AsyncStorage is 'asynchronous' and 'unencrypted,' making it unsuitable for sensitive secrets."
  },
  "sp-02": {
    "prompt": "What is the primary architectural advantage of 'react-native-mmkv' over 'AsyncStorage'?",
    "explanation": "MMKV uses the JavaScript Interface (JSI) to allow the JS thread to read/write data directly from C++ memory without the overhead of the JSON bridge.",
    "interviewTip": "MMKV is currently considered the fastest key-value storage for React Native, often 10-30x faster than AsyncStorage."
  },
  "sp-03": {
    "prompt": "How do you correctly save an object (not a string) to AsyncStorage?",
    "explanation": "AsyncStorage can only store strings. To store objects or arrays, you must serialize them to a JSON string first.",
    "interviewTip": "Don't forget that `getItem` will also require `JSON.parse` to turn it back into an object."
  },
  "sp-04": {
    "prompt": "Where is the most secure place to store a user's Authentication Token or Bio-metric data?",
    "explanation": "Keychain and Keystore provide hardware-level encryption that persists even if the app is deleted or the device is backed up. Key-value stores like AsyncStorage are not secure.",
    "interviewTip": "Mention 'Key-Value storage for preferences, Keychain for secrets' as a security best practice."
  },
  "sp-05": {
    "prompt": "Analyze the code. What will be the value of 'name' after these calls?",
    "explanation": "AsyncStorage is promise-based. Because 'await' is used, the code waits for the storage to return the string 'John'.",
    "interviewTip": "If you forget 'await', the constant 'name' will be a Promise, which evaluates to 'true' in a conditional, causing bugs."
  },
  "sp-06": {
    "prompt": "Which of the following are valid reasons to use 'SQLite' instead of 'AsyncStorage'?",
    "explanation": "SQLite is a full relational database. For simple key-value pairs like theme preferences, it is overkill compared to AsyncStorage or MMKV.",
    "interviewTip": "WatermelonDB or Realm are popular high-level alternatives that use SQLite or their own engines under the hood."
  },
  "sp-07": {
    "prompt": "What does 'multiSet' do in AsyncStorage?",
    "explanation": "Batch operations are more efficient than calling setItem multiple times, as they reduce the number of trips across the bridge.",
    "interviewTip": "Always use 'multiSet' or 'multiGet' when dealing with related groups of data to improve performance."
  },
  "sp-08": {
    "prompt": "In Expo, what is the default secure storage library?",
    "explanation": "expo-secure-store provides a way to encrypt and securely store key-value pairs locally on the device.",
    "interviewTip": "Note that SecureStore has a 2048-byte limit per value, so it's strictly for small secrets."
  },
  "sp-09": {
    "prompt": "What is the typical storage limit for AsyncStorage on Android?",
    "explanation": "By default, Android caps AsyncStorage at 6MB. For larger data, you must increase this in your `MainApplication.java` or `gradle.properties`.",
    "interviewTip": "If your app crashes when saving large JSONs on Android, this limit is likely the cause."
  },
  "sp-10": {
    "prompt": "Which library is an 'Offline-first' database that syncs with a server and is often used with React Native?",
    "explanation": "Realm is an object-oriented database that is much faster than SQLite and provides native synchronization features.",
    "interviewTip": "Mention Realm if the interview focuses on complex apps that must work perfectly without an internet connection."
  },
  "sec-01": {
    "prompt": "What is 'SSL Pinning' and why is it used in React Native apps?",
    "explanation": "Even with HTTPS, an attacker can sometimes force a device to trust a fake certificate. SSL Pinning ensures the app rejects any certificate that doesn't match the 'pinned' one from your server.",
    "interviewTip": "Mention libraries like 'react-native-ssl-pinning' or 'TrustKit'. Warning: If your server certificate expires and you haven't updated the app, it will stop working!"
  },
  "sec-02": {
    "prompt": "How should sensitive keys (like API secrets) be stored in a React Native app?",
    "explanation": "Standard storage (AsyncStorage/MMKV) is unencrypted. The Keychain/Keystore provides hardware-level encryption designed specifically for secrets.",
    "interviewTip": "A great answer includes: 'I use .env files for build-time configuration, but device-specific secrets go into the Secure Keychain'."
  },
  "sec-03": {
    "prompt": "What is the purpose of 'Jailbreak' or 'Root' detection in mobile apps?",
    "explanation": "On a rooted/jailbroken device, attackers can bypass sandbox restrictions and read your app's private data or intercept memory. Banks and high-security apps often block access on these devices.",
    "interviewTip": "Use 'react-native-jail-monkey' or 'expo-device' to check if the device environment is untrusted."
  },
  "sec-04": {
    "prompt": "Analyze the Android config. What does 'minifyEnabled true' and 'proguardFiles' do?",
    "explanation": "Proguard/R8 shrinks the code and renames classes/methods to nonsense names (e.g., 'a', 'b', 'c'), making the native binary difficult to read.",
    "interviewTip": "Always enable this for release builds. It's the first line of defense against decompilers."
  },
  "sec-05": {
    "prompt": "Why is it dangerous to use 'console.log' in a production React Native build?",
    "explanation": "Logging doesn't just show in your terminal; it's broadcasted to the device's system log. Production builds should have logs stripped out.",
    "interviewTip": "Use 'babel-plugin-transform-remove-console' to automatically strip all logs during the production build process."
  },
  "sec-06": {
    "prompt": "Which of these are valid methods to secure the JavaScript bundle itself?",
    "explanation": "Hermes provides 'security through compilation.' Obfuscators add an extra layer of complexity to the logic itself.",
    "interviewTip": "Explain that no JS code is 100% 'hidden,' but these steps make it significantly more expensive for an attacker to decode."
  },
  "sec-07": {
    "prompt": "What is 'Deep Link Hijacking'?",
    "explanation": "URL schemes (myapp://) are not exclusive. To prevent hijacking, you should use 'Universal Links' (iOS) or 'App Links' (Android), which use a verified website domain to prove ownership.",
    "interviewTip": "Always prefer HTTPS-based 'Universal Links' over custom URI schemes for authentication flows."
  },
  "sec-08": {
    "prompt": "What is the security risk of using 'allowFileAccess' or 'javaScriptEnabled' in a WebView?",
    "explanation": "WebViews are essentially mini-browsers. If you load untrusted URLs with full permissions enabled, you risk giving that site access to the app's internal sandbox.",
    "interviewTip": "Only enable the specific features you need, and always use 'originWhitelist' to restrict which domains the WebView can visit."
  },
  "sec-09": {
    "prompt": "How do you implement biometric authentication (Face ID / Touch ID) in React Native?",
    "explanation": "These libraries provide a cross-platform API to check if biometrics are available and to prompt the user for authentication.",
    "interviewTip": "Always have a fallback to PIN/password authentication in case biometrics fail or aren't available on the device."
  },
  "sec-10": {
    "prompt": "What is the recommended way to encrypt sensitive data before storing it locally?",
    "explanation": "Base64 is encoding, not encryption—it can be easily reversed. AES-256 is a strong encryption standard that requires a key to decrypt the data.",
    "interviewTip": "Store the encryption key in the Keychain/Keystore, never hardcode it in your JavaScript bundle."
  },
  "perf-01": {
    "prompt": "Which JavaScript engine is now the default for React Native because it provides faster TTI (Time To Interactive) and smaller APK sizes?",
    "explanation": "Hermes is optimized specifically for mobile. It uses Ahead-of-Time (AOT) compilation to turn JS into bytecode during the build process, rather than at runtime.",
    "interviewTip": "Mention that Hermes also helps reduce the 'Memory Footprint' of the app, which is vital for budget Android devices."
  },
  "perf-02": {
    "prompt": "What is 'FlashList' (by Shopify) and why is it often used instead of 'FlatList'?",
    "explanation": "FlatList unmounts off-screen items. FlashList recycles the underlying native views and simply swaps the data, which is much faster for the device to handle.",
    "interviewTip": "FlashList claims to be '5x to 10x faster' than FlatList. It's a great mention for Senior-level performance discussions."
  },
  "perf-03": {
    "prompt": "Analyze the code. Why is this list likely to lag during fast scrolling?",
    "explanation": "Functions defined inside the component body are recreated every render. Additionally, heavy logic like 'expensiveFormat' inside renderItem blocks the JS thread during scroll.",
    "interviewTip": "Solution: Move renderItem outside the component or wrap it in 'useCallback', and memoize the expensive formatting."
  },
  "perf-04": {
    "prompt": "What is the purpose of the 'InteractionManager.runAfterInteractions' method?",
    "explanation": "This ensures that a heavy task doesn't steal CPU cycles from an animation, preventing 'jank' or dropped frames.",
    "interviewTip": "This is perfect for fetching data immediately after a screen transition without making the transition feel sluggish."
  },
  "perf-05": {
    "prompt": "Which of these tools are commonly used to profile and debug performance in a React Native app?",
    "explanation": "Flipper and React DevTools are standard for JS/Bridge profiling. Xcode Instruments (and Android Studio Profiler) are needed to inspect native memory and CPU usage.",
    "interviewTip": "Flipper is a 'Senior' choice—it allows you to inspect the bridge traffic, layout, and database in one place."
  },
  "perf-06": {
    "prompt": "How can you detect if your JS thread is being overloaded in a real device?",
    "explanation": "The 'Perf Monitor' overlay shows the frame rate of both threads. If UI is 60 FPS but JS is 10 FPS, your logic is blocking the app.",
    "interviewTip": "JS FPS drops usually mean too many re-renders or heavy computations; UI FPS drops mean your View hierarchy is too deep or complex."
  },
  "perf-07": {
    "prompt": "What is 'Inline function' optimization in the context of RN performance?",
    "explanation": "An inline arrow function creates a new reference on every render. If the button is wrapped in 'React.memo', it will still re-render because the 'onPress' prop changed reference.",
    "interviewTip": "This is the most common cause of 'Wasted Renders' in large lists."
  },
  "perf-08": {
    "prompt": "Why should you avoid deep nesting of View components?",
    "explanation": "Every layer of nesting adds work for the Yoga layout engine. Flattening your UI structure improves the speed of initial rendering and updates.",
    "interviewTip": "If you have 10 nested Views just for margins/padding, try to combine them into fewer components."
  },
  "perf-09": {
    "prompt": "What is the benefit of using 'RAM bundles' (Random Access Modules) in React Native?",
    "explanation": "RAM bundles split the JavaScript into indexed modules. The app loads the 'startup' modules first, then loads other modules as they are required during navigation.",
    "interviewTip": "This is particularly useful for large apps with many screens. Mention 'Metro bundler' configuration for enabling this."
  },
  "perf-10": {
    "prompt": "How does the New Architecture improve performance compared to the legacy architecture?",
    "explanation": "The New Architecture (JSI + Fabric + Turbo Modules) removes the JSON serialization bottleneck and allows React to communicate directly with native code, enabling features like synchronous layout and priority-based rendering.",
    "interviewTip": "Mention that this brings React Native's performance much closer to fully native apps, especially for complex UI interactions."
  },
  "rn-env-01": {
    "prompt": "What is the primary difference between the 'Bridge' (Old Architecture) and 'JSI' (New Architecture)?",
    "explanation": "The legacy Bridge requires data to be serialized to JSON and sent across an asynchronous queue. JSI (JavaScript Interface) allows JS to hold references to C++ host objects, enabling direct, synchronous calls.",
    "interviewTip": "Mention that JSI is the foundation for the New Architecture (Fabric and TurboModules)."
  },
  "rn-env-02": {
    "prompt": "Which layout engine does React Native use to calculate positions and sizes of components?",
    "explanation": "Yoga is a cross-platform layout engine developed by Meta that implements Flexbox for native mobile screens.",
    "interviewTip": "Yoga is written in C++ and is what translates your 'flex: 1' styles into actual pixel coordinates on iOS and Android."
  },
  "rn-env-03": {
    "prompt": "What does the 'Hermes' engine do for a React Native application?",
    "explanation": "Hermes is a small, lightweight JS engine. It uses bytecode pre-compilation (AOT) to make app launches significantly faster.",
    "interviewTip": "Starting with React Native 0.70, Hermes is the default engine for all new projects."
  },
  "rn-env-04": {
    "prompt": "What will be the result of this code when running in a React Native environment?",
    "explanation": "Core components like View are JavaScript components (usually functions or objects) that act as wrappers for native UI elements.",
    "interviewTip": "In the end, these components tell the native side to render a 'UIView' on iOS or an 'android.view' on Android."
  },
  "rn-env-05": {
    "prompt": "Which of the following are benefits of using 'Expo' over 'React Native CLI'?",
    "explanation": "Expo simplifies development by abstracting away the complex native code, though the CLI is still preferred if you need custom native module modifications that Expo doesn't support.",
    "interviewTip": "Expo is no longer 'just for beginners'; with 'Development Builds,' it is now powerful enough for professional enterprise apps."
  },
  "rn-env-06": {
    "prompt": "What is the 'Metro' bundler in React Native?",
    "explanation": "Metro is similar to Webpack for the web. It resolves dependencies and bundles your code for the mobile environment.",
    "interviewTip": "Metro is what powers Hot Module Replacement (HMR) / Fast Refresh during development."
  },
  "rn-env-07": {
    "prompt": "In the New Architecture, what replaces the 'UIManager'?",
    "explanation": "Fabric is the new rendering system. It is more efficient because it allows the UI to be updated synchronously and improves interop with host views.",
    "interviewTip": "Fabric is to Rendering what TurboModules are to Native Logic."
  },
  "rn-env-08": {
    "prompt": "What is the purpose of 'npx react-native run-ios'?",
    "explanation": "This command triggers the build process (via Xcode tools) and pushes the application to the iOS target.",
    "interviewTip": "You must have Xcode installed on a macOS machine for this command to work."
  },
  "rn-env-09": {
    "prompt": "Identify the three main threads in a standard React Native app (Bridge architecture):",
    "explanation": "The UI thread handles native view rendering; the JS thread runs the logic; and the Shadow thread calculates the layout (Yoga) before sending it to the UI thread.",
    "interviewTip": "If the JS thread is blocked by heavy logic, the UI remains responsive (animations might still work), but user interactions like button clicks won't process."
  },
  "rn-env-10": {
    "prompt": "What will happen if you run this code in a standard React Native component?",
    "explanation": "React Native does not use the browser's DOM. You must use native primitives like <View> and <Text>.",
    "interviewTip": "There is no 'div', 'span', or 'p' in React Native; everything text-related must be inside a <Text> component."
  },
  "rn-env-11": {
    "prompt": "What is 'Autolinking' in React Native?",
    "explanation": "Previously, you had to run 'react-native link'. Now, the CLI detects native modules in your node_modules and links them during build time.",
    "interviewTip": "For iOS, you still need to run 'pod install' after adding a library to finalize the autolinking."
  },
  "rn-env-12": {
    "prompt": "What is the entry point for native configuration in an Android React Native project?",
    "explanation": "The AndroidManifest.xml is where you define permissions, activities, and app metadata for the Android OS.",
    "interviewTip": "Knowing where these native files are (android/app/src/main/...) is essential for configuring things like deep links or camera permissions."
  },
  "rn-env-13": {
    "prompt": "In React Native, how is a 'TurboModule' different from a standard Native Module?",
    "explanation": "Standard modules are initialized on app startup even if not used. TurboModules are only loaded when required and communicate directly via JSI.",
    "interviewTip": "This is a key part of the New Architecture aimed at improving app startup performance."
  },
  "rn-env-14": {
    "prompt": "What command is used to start the Metro bundler manually?",
    "explanation": "This starts the local server that provides the JS bundle and assets to your running app during development.",
    "interviewTip": "If you get a 'Could not connect to development server' error, checking if this process is running is your first step."
  },
  "rn-env-15": {
    "prompt": "Which of these is a valid way to specify a version of React Native in a project?",
    "explanation": "The React Native version is managed like any other npm package in the package.json file.",
    "interviewTip": "Upgrading React Native versions often requires the 'React Native Upgrade Helper' tool because of changes in the underlying native files."
  },
  "rn-env-16": {
    "prompt": "What does the 'Shadow Tree' represent?",
    "explanation": "The Shadow Tree is where React Native stores the layout information (flex, margin, padding) so Yoga can work its magic.",
    "interviewTip": "In the New Architecture, the Shadow Tree is immutable and managed in C++ for better performance."
  },
  "rn-env-17": {
    "prompt": "How do you enable the New Architecture in a modern React Native project (iOS)?",
    "explanation": "For most current versions, you must explicitly enable it during the pod installation process for iOS or in gradle.properties for Android.",
    "interviewTip": "Be aware that some third-party libraries might not be compatible with the New Architecture yet."
  },
  "rn-env-18": {
    "prompt": "What happens when 'Fast Refresh' is triggered?",
    "explanation": "Fast Refresh combines 'hot reloading' and 'live reloading' to provide a seamless update experience without losing the component's state if possible.",
    "interviewTip": "If you modify a file that exports something other than a React component, Fast Refresh may perform a full reload to be safe."
  },
  "ra-01": {
    "prompt": "What is a 'Worklet' in the context of React Native Reanimated?",
    "explanation": "Worklets are the core of Reanimated. They allow JavaScript code to be executed synchronously on the UI thread, bypassing the asynchronous bridge for immediate UI updates.",
    "interviewTip": "Mention that Reanimated 2+ uses a separate JS VM on the UI thread to execute these worklets."
  },
  "ra-02": {
    "prompt": "Which hook is used to create a mutable value that can be shared between the JS thread and the UI thread?",
    "explanation": "useSharedValue is the Reanimated version of state. When you change its '.value' property, it automatically triggers animations or updates style objects on the UI thread.",
    "interviewTip": "Unlike useState, changing a shared value does not trigger a React component re-render on the main JS thread."
  },
  "ra-03": {
    "prompt": "Analyze the code. What is the correct way to apply the shared value to a component's style?",
    "explanation": "useAnimatedStyle returns a style object that 'listens' to shared values. Whenever the shared value changes, the UI thread updates the view without a bridge round-trip.",
    "interviewTip": "Always ensure the component is an 'Animated' version (e.g., Animated.View) from the reanimated library."
  },
  "ra-04": {
    "prompt": "How do you smoothly animate a shared value to a new position using a spring physics model?",
    "explanation": "withSpring is a 'wrapper' function that describes how the transition to the new value should look. It uses spring physics (stiffness, damping) instead of time.",
    "interviewTip": "Unlike the standard Animated API, Reanimated allows you to set the new value directly: `val.value = withSpring(target)`."
  },
  "ra-05": {
    "prompt": "What is the purpose of 'useDerivedValue'?",
    "explanation": "useDerivedValue creates a read-only shared value that automatically updates whenever the dependencies inside its worklet change.",
    "interviewTip": "Think of this as the 'useMemo' of the UI thread."
  },
  "ra-06": {
    "prompt": "Which of these features were introduced in Reanimated 3?",
    "explanation": "Reanimated 3 focused heavily on compatibility with the New Architecture and robust Shared Element Transitions between navigation screens.",
    "interviewTip": "Shared Element Transitions make apps feel extremely high-end, similar to the App Store or Instagram."
  },
  "ra-07": {
    "prompt": "How do you run a piece of JavaScript code on the main JS thread after an animation finishes on the UI thread?",
    "explanation": "Since the completion callback runs on the UI thread, you must use runOnJS to 'call back' to the JavaScript thread for things like alerts or state updates.",
    "interviewTip": "Failing to use runOnJS inside a worklet when calling a JS function will cause a crash."
  },
  "ra-08": {
    "prompt": "What are 'Layout Animations' in Reanimated?",
    "explanation": "Layout animations provide a simple way to animate mounting/unmounting and layout shifts without managing complex shared values manually.",
    "interviewTip": "Use `Layout.springify()` to make list item shifts look bouncy and natural."
  },
  "ra-09": {
    "prompt": "What is the function of 'interpolateColor' in Reanimated?",
    "explanation": "Similar to standard interpolation, but specifically optimized for the UI thread to handle color transitions smoothly.",
    "interviewTip": "This is perfect for changing a header color from white to transparent as the user scrolls."
  },
  "ra-10": {
    "prompt": "Why is 'useAnimatedGestureHandler' (v2) or using gestures with Reanimated (v3) better than standard touch events?",
    "explanation": "By linking Gesture Handler with Reanimated, the 'translation' data from a finger swipe can update a shared value and move a View entirely on the UI thread.",
    "interviewTip": "This is the key to building 60/120 FPS 'pull-to-dismiss' or 'swipe-to-delete' interactions."
  },
  "pn-01": {
    "prompt": "What is the primary difference between a 'Local Notification' and a 'Remote Push Notification'?",
    "explanation": "Local notifications (like an alarm or a timer) stay on the device. Remote notifications are triggered by an external server to re-engage the user.",
    "interviewTip": "For your JS Mock Interview app, a 'Local' notification would be perfect for a reminder to practice tomorrow."
  },
  "pn-02": {
    "prompt": "Which service does React Native use to deliver notifications to iOS devices, even when using Firebase?",
    "explanation": "Even if you use Firebase, Google eventually has to hand the message over to Apple's APNs to reach an iPhone.",
    "interviewTip": "This is why you still need an Apple Developer Account and .p8 certificates even when using Firebase."
  },
  "pn-03": {
    "prompt": "What is a 'FCM Token'?",
    "explanation": "Your server sends messages to this token. If the user uninstalls and reinstalls the app, the token usually changes.",
    "interviewTip": "Always send the token to your backend database during the app launch or login."
  },
  "pn-04": {
    "prompt": "How do you handle a notification click when the app is completely closed (Quit state)?",
    "explanation": "getInitialNotification is a 'one-time' check that returns the notification data if the app was launched by tapping that notification.",
    "interviewTip": "This is the most common place where 'Deep Linking' logic starts after a user taps a push."
  },
  "pn-05": {
    "prompt": "What is the purpose of 'Notification Channels' on Android?",
    "explanation": "Android 8.0+ requires channels. Without a valid channel ID, notifications will not show up on modern Android devices.",
    "interviewTip": "On iOS, this concept doesn't exist; users can only toggle notifications on or off for the whole app."
  },
  "pn-06": {
    "prompt": "What happens when a 'Silent' (Data-only) notification is received?",
    "explanation": "Silent notifications carry a data payload without a 'title' or 'body'. They are used to wake up the app to download new content quietly.",
    "interviewTip": "Be careful: iOS and Android both limit how many silent pushes you can send to prevent battery drain."
  },
  "pn-07": {
    "prompt": "Which of these are required to enable Push Notifications on iOS?",
    "explanation": "iOS is very strict. You need all these settings and a real device to test the full flow from server to handset.",
    "interviewTip": "Newer Xcode versions/Simulators have added limited support, but a physical device is still the industry standard for testing."
  },
  "pn-08": {
    "prompt": "What is the role of the 'setBackgroundMessageHandler' in React Native Firebase?",
    "explanation": "This handler runs in its own specialized task outside of your main React component tree.",
    "interviewTip": "Keep this function 'pure' and avoid using hooks or complex UI logic inside it."
  },
  "pn-09": {
    "prompt": "What is 'Notification Overloading'?",
    "explanation": "This is a UX term. High-frequency, irrelevant notifications are the #1 reason for app churn.",
    "interviewTip": "Mention 'Notification Personalization' and 'Frequency Capping' as solutions to this problem."
  },
  "pn-10": {
    "prompt": "How do you request notification permissions from the user in React Native?",
    "explanation": "requestPermission() returns the authorization status (authorized, denied, provisional). On iOS, this triggers the system permission dialog.",
    "interviewTip": "Always check the current permission status before requesting to avoid annoying users with repeated prompts. On Android 13+, you also need to request the POST_NOTIFICATIONS runtime permission."
  },
  "ps-01": {
    "prompt": "Which built-in module is used to detect the operating system at runtime within your JavaScript code?",
    "explanation": "The 'Platform' module provides a 'Platform.OS' property which returns either 'ios' or 'android'.",
    "interviewTip": "You can also use 'Platform.Version' to check the specific API level of the device."
  },
  "ps-02": {
    "prompt": "How do you apply different styles for iOS and Android using the Platform.select method?",
    "explanation": "Platform.select takes an object where keys are platforms and returns the value for the platform the app is currently running on.",
    "interviewTip": "This is much cleaner than using multiple ternary operators (Platform.OS === 'ios' ? ... : ...)."
  },
  "ps-03": {
    "prompt": "What is the naming convention for creating separate files for iOS and Android that React Native will automatically pick up?",
    "explanation": "React Native's packager (Metro) detects the platform-specific extension and imports the correct file automatically when you 'import Header from \"./Header\"'.",
    "interviewTip": "This is the best pattern for complex components that require completely different native implementations."
  },
  "ps-04": {
    "prompt": "Which of these are valid ways to handle platform-specific differences in React Native?",
    "explanation": "React Native provides OS detection, the select utility, and file-level splitting. There is no built-in <NativeTarget> component.",
    "interviewTip": "Mention that file extensions are best for large logic differences, while Platform.select is best for minor style tweaks."
  },
  "ps-05": {
    "prompt": "How do you check if the current Android device has a specific API level (e.g., API 30)?",
    "explanation": "For Android, Platform.Version returns the integer API level (e.g., 30, 31). For iOS, it returns a string of the system version (e.g., '17.2').",
    "interviewTip": "Always remember to check the OS first, because '30' (number) and '17.2' (string) are compared differently in JS."
  },
  "ps-06": {
    "prompt": "What does the 'Platform.isPad' property return?",
    "explanation": "Platform.isPad is a boolean specifically for iOS to distinguish between iPhone and iPad layouts.",
    "interviewTip": "For a cross-platform tablet check, you usually need to check the screen width using Dimensions."
  },
  "ps-07": {
    "prompt": "Which property in the Platform module is used to check if the app is running in a TV environment (like Apple TV or Android TV)?",
    "explanation": "Platform.isTV is a boolean that helps you adjust navigation logic for focus-based (remote control) interfaces.",
    "interviewTip": "TV apps require 'focusable' components, which is a different paradigm than touch."
  },
  "ps-08": {
    "prompt": "Analyze the code. What will the 'elevation' property do on an iOS device?",
    "explanation": "Android uses 'elevation' for shadows (Material Design), while iOS uses 'shadowColor', 'shadowOffset', 'shadowOpacity', and 'shadowRadius'.",
    "interviewTip": "To get consistent shadows on both, you must define both sets of properties or use a library like 'react-native-shadow-2'."
  },
  "ps-09": {
    "prompt": "How do you define a component that only renders on the web when using 'React Native for Web'?",
    "explanation": "Metro and Webpack can be configured to recognize '.web.js' extensions for web-specific implementations.",
    "interviewTip": "This allows you to use standard <div> and <a> tags for the web version while using View/Text for mobile."
  },
  "ps-10": {
    "prompt": "What is the purpose of 'Platform.select' for default values?",
    "explanation": "The 'default' key acts as a fallback for any platform not explicitly listed in the object.",
    "interviewTip": "This is great for maintaining future compatibility with platforms like 'macos' or 'windows'."
  },
  "of-01": {
    "prompt": "Which library is the industry standard for detecting network connectivity status in React Native?",
    "explanation": "NetInfo provides information about the connection type (wifi, cellular) and whether the device is actually connected to the internet.",
    "interviewTip": "Always subscribe to the listener rather than just checking a one-time value, so your UI can react instantly when the user goes offline."
  },
  "of-02": {
    "prompt": "What is 'Optimistic UI' in the context of an offline-first app?",
    "explanation": "Optimistic UI makes the app feel 'instant.' If the network request fails later, the app 'rolls back' the change and informs the user.",
    "interviewTip": "This is a core feature of libraries like TanStack (React) Query."
  },
  "of-03": {
    "prompt": "Analyze the code. How does this React Query configuration handle being offline?",
    "explanation": "In 'offlineFirst' mode, queries will run the queryFn but will also successfully return data from the cache if available, even without a connection.",
    "interviewTip": "Pair this with a 'Persister' to save the cache to MMKV or AsyncStorage for true offline persistence across restarts."
  },
  "of-04": {
    "prompt": "What is the role of a 'Sync Queue' in an offline-first architecture?",
    "explanation": "A sync queue ensures that user progress isn't lost. When the app detects 'isConnected: true', it processes the pending actions in the order they were created.",
    "interviewTip": "Libraries like 'redux-persist' combined with 'redux-offline' were early pioneers of this pattern."
  },
  "of-05": {
    "prompt": "Which of these are common challenges when implementing Offline-First?",
    "explanation": "Conflict resolution is the hardest part—deciding 'who wins' if a user edits the same data on two devices while one was offline.",
    "interviewTip": "Mention 'Last Write Wins' or 'CRDTs' (Conflict-free Replicated Data Types) as advanced strategies for resolution."
  },
  "of-06": {
    "prompt": "How do you detect if a specific network request failed specifically because of a lack of internet?",
    "explanation": "state.isConnected returns a boolean indicating if the device has a network connection (though it doesn't always guarantee internet access).",
    "interviewTip": "Use `state.isInternetReachable` for a more accurate check that the Google/Apple servers can actually be reached."
  },
  "of-07": {
    "prompt": "What is 'Rehydration' in the context of state management?",
    "explanation": "When the app opens, it reads the saved JSON from AsyncStorage/MMKV and 'fills' the state, so the user sees their data before any network calls happen.",
    "interviewTip": "Always show a loading splash screen until the rehydration is complete to avoid 'layout shift'."
  },
  "of-08": {
    "prompt": "Why is 'MMKV' often preferred over 'AsyncStorage' for offline-first apps?",
    "explanation": "Because MMKV is synchronous, you can read the state instantly during the initial render, making the 'offline' experience feel much smoother.",
    "interviewTip": "AsyncStorage requires 'await', which always forces at least one 'empty' render cycle."
  },
  "of-09": {
    "prompt": "What is the best strategy for handling image caching in an offline-first app?",
    "explanation": "Libraries like 'react-native-fast-image' provide automatic disk caching with cache invalidation strategies, making offline image loading seamless.",
    "interviewTip": "Mention that you should set cache priorities (low/normal/high) based on image importance to manage disk space efficiently."
  },
  "of-10": {
    "prompt": "How do you implement a retry mechanism for failed network requests in an offline-first architecture?",
    "explanation": "Setting 'retry: 3' means the mutation will automatically retry up to 3 times with exponential backoff before giving up. This is perfect for transient network errors.",
    "interviewTip": "For critical operations like payments, you might want to persist failed mutations to a queue and retry them when the app restarts."
  },
  "nav-01": {
    "prompt": "Which navigator should you use for a standard 'push/pop' transition where a new screen slides over the previous one?",
    "explanation": "Stack Navigator provides a way for your app to transition between screens where each new screen is placed on top of a stack.",
    "interviewTip": "In modern React Navigation, use '@react-navigation/native-stack' for better performance as it uses native OS primitives."
  },
  "nav-02": {
    "prompt": "How do you navigate to a specific screen named 'Details' and pass a parameter 'itemId'?",
    "explanation": "The 'navigate' function is the most common way to move between screens. The second argument is an object containing 'params'.",
    "interviewTip": "Note the difference: 'navigate' will go back to an existing screen in the stack, while 'push' will always add a new instance even if it's the same screen."
  },
  "nav-03": {
    "prompt": "How do you retrieve the 'itemId' parameter in the 'Details' screen component?",
    "explanation": "Every screen component in a navigator receives a 'route' prop containing information about the current route, including 'params'.",
    "interviewTip": "You can also use the 'useRoute' hook to access this information anywhere in the component tree."
  },
  "nav-04": {
    "prompt": "What is the purpose of the <NavigationContainer> component?",
    "explanation": "NavigationContainer must wrap your entire application structure. It manages the app state and handles deep linking.",
    "interviewTip": "You should only have one NavigationContainer in your entire app."
  },
  "nav-05": {
    "prompt": "Which hook is used to perform a 'go back' action programmatically?",
    "explanation": "useNavigation provides access to the navigation object within any nested component, allowing actions like 'goBack' or 'navigate'.",
    "interviewTip": "This is much cleaner than passing the navigation prop manually through several layers of components."
  },
  "nav-06": {
    "prompt": "Which of the following are common types of navigators in the React Navigation ecosystem?",
    "explanation": "React Navigation provides specific packages for Stack, Tabs, and Drawers. Modals are typically handled as a 'presentation' mode within a Stack.",
    "interviewTip": "Mention 'createNativeStackNavigator' specifically for its performance benefits on iOS and Android."
  },
  "nav-07": {
    "prompt": "What does 'navigation.replace('Home')' do?",
    "explanation": "Replace is useful for login flows; once a user logs in, you replace the Login screen with Home so they can't 'go back' to the login form.",
    "interviewTip": "Use this to prevent 'infinite' back loops in your app's history."
  },
  "nav-08": {
    "prompt": "How do you change the title of a screen in the navigation header?",
    "explanation": "The 'options' prop (specifically the 'title' field) controls how the screen appears in the UI of the navigator (header text, tab label).",
    "interviewTip": "You can also set these dynamically from within the component using 'navigation.setOptions'."
  },
  "nav-09": {
    "prompt": "What is 'Deep Linking' in the context of mobile navigation?",
    "explanation": "Deep linking allows external sources (websites, emails, notifications) to trigger navigation to a specific nested screen within your app.",
    "interviewTip": "Implementing deep linking requires configuring a 'linking' object and passing it to the <NavigationContainer>."
  },
  "nav-10": {
    "prompt": "How do you detect when a screen has come into focus (becomes visible to the user)?",
    "explanation": "Since screens in a stack stay 'mounted' even when hidden, standard useEffect doesn't trigger when you return to a screen. 'useFocusEffect' is the React Navigation solution.",
    "interviewTip": "This is essential for refreshing data when a user navigates back to a screen."
  },
  "nav-11": {
    "prompt": "What happens if you call 'navigation.popToTop()'?",
    "explanation": "This is a convenience method in Stack navigators to instantly 'reset' the navigation history and return to the starting screen.",
    "interviewTip": "This is commonly used for 'Home' buttons or finishing a multi-step checkout process."
  },
  "nav-12": {
    "prompt": "How do you hide the header for a specific screen?",
    "explanation": "headerShown: false is the standard option to remove the default navigation bar for that specific screen.",
    "interviewTip": "You might do this if you are building a custom header or for a splash screen."
  },
  "nav-13": {
    "prompt": "What is 'Tab Nesting'?",
    "explanation": "Nesting allows you to have a Bottom Tab bar globally, but each tab can have its own independent history stack (e.g., Home -> Product Details).",
    "interviewTip": "Be careful with deep nesting; it can make the navigation state complex and harder to debug."
  },
  "nav-14": {
    "prompt": "Which prop allows you to customize the icon in a Bottom Tab Navigator?",
    "explanation": "tabBarIcon is a function that returns a component (usually an icon) to be displayed in the tab bar.",
    "interviewTip": "The function receives { focused, color, size } as arguments to help you style the active vs inactive state."
  },
  "nm-01": {
    "prompt": "In the legacy architecture, what is the role of 'RCTBridgeModule' on iOS?",
    "explanation": "To expose a native class to JS, it must implement the RCTBridgeModule protocol and use the RCT_EXPORT_MODULE macro.",
    "interviewTip": "Remember that data passed through this bridge must be serialized into JSON, which can be a bottleneck."
  },
  "nm-02": {
    "prompt": "What is the primary technical improvement of 'Turbo Modules' over the legacy Native Modules?",
    "explanation": "Legacy modules are all initialized at app launch, slowing down startup. Turbo Modules are loaded on demand and allow synchronous calls via JSI (JavaScript Interface).",
    "interviewTip": "If an interviewer asks about app startup performance, mention 'Lazy Loading' of Turbo Modules."
  },
  "nm-03": {
    "prompt": "Analyze the Android native code. What is the purpose of the @ReactMethod annotation?",
    "explanation": "Without this annotation, the method remains invisible to the React Native bridge, even if the class itself is exported.",
    "interviewTip": "Only methods marked with @ReactMethod can be triggered via 'NativeModules.ModuleName.methodName()'."
  },
  "nm-04": {
    "prompt": "How does JavaScript communicate with the native side in the New Architecture without serialization?",
    "explanation": "JSI allows the JavaScript engine (Hermes) to hold a reference to a C++ object, enabling direct, synchronous method calls instead of passing JSON messages.",
    "interviewTip": "JSI is what makes 'Reanimated' so fast—it allows the UI to update without waiting for the bridge."
  },
  "nm-05": {
    "prompt": "What is the purpose of 'Codegen' in the New Architecture?",
    "explanation": "Codegen ensures type safety between JS and Native code. It creates the 'glue' code automatically so you don't have to write C++ boilerplate manually.",
    "interviewTip": "Codegen helps prevent runtime crashes caused by sending the wrong data types across the JS-Native boundary."
  },
  "nm-06": {
    "prompt": "Which of these are valid ways to send data from Native back to JavaScript?",
    "explanation": "Callbacks and Promises are for responses to specific calls. Events (EventEmitter) are for native actions the JS didn't trigger, like a GPS location update.",
    "interviewTip": "Always remember to remove event listeners in 'useEffect' cleanup to avoid memory leaks."
  },
  "nm-07": {
    "prompt": "What is a 'Native UI Component' (as opposed to a Native Module)?",
    "explanation": "While Native Modules provide 'logic', Native UI Components provide 'views'. You use 'requireNativeComponent' to bring them into your JSX.",
    "interviewTip": "If you need a very complex UI element that doesn't exist in RN, you build a 'ViewManager' on the native side."
  },
  "nm-08": {
    "prompt": "Identify the issue in this iOS native method:",
    "explanation": "Legacy bridge methods are asynchronous and return 'void'. To get a result back to JS, you must pass an RCTResponseSenderBlock or an RCTPromiseResolveBlock.",
    "interviewTip": "In the New Architecture with JSI, you actually *can* return values synchronously."
  },
  "nm-09": {
    "prompt": "What does the 'RCT_EXPORT_MODULE()' macro do?",
    "explanation": "Without this macro, React Native's bridge won't know the class exists at runtime.",
    "interviewTip": "You can pass an optional name to the macro (e.g., RCT_EXPORT_MODULE(MyCustomName)) to change how it appears in JS."
  },
  "nm-10": {
    "prompt": "What is 'Fabric' in the New Architecture and how does it differ from the legacy renderer?",
    "explanation": "The legacy renderer used an asynchronous bridge to send UI updates. Fabric uses JSI to communicate synchronously with the native UI thread, enabling features like priority-based rendering and layout animations.",
    "interviewTip": "Fabric is the 'React 18 Concurrent Mode' equivalent for the native side—it allows React Native to interrupt and prioritize UI updates."
  },
  "ab-01": {
    "prompt": "Which component type must you use to make a standard View animatable with the Animated API?",
    "explanation": "Standard components cannot handle Animated values directly. You must use the 'Animated' versions: View, Text, Image, and ScrollView.",
    "interviewTip": "If you have a custom component, you can wrap it using 'Animated.createAnimatedComponent(MyComponent)'."
  },
  "ab-02": {
    "prompt": "What is the primary benefit of setting 'useNativeDriver: true' in an animation config?",
    "explanation": "By sending the animation definition to the native side once, the native thread can update the UI independently of the JavaScript event loop.",
    "interviewTip": "Remember that 'useNativeDriver' only works with non-layout properties like 'opacity' and 'transform'."
  },
  "ab-03": {
    "prompt": "How do you map a value that goes from 0 to 1 to a property that goes from 0 to 360 degrees?",
    "explanation": "Interpolation allows you to map an input range to an output range, including strings like colors or degrees.",
    "interviewTip": "Interpolation is a core concept in the Animated API for creating complex, multi-property animations from a single value."
  },
  "ab-04": {
    "prompt": "Which method is used to create a spring-based animation that mimics physical movement?",
    "explanation": "Animated.spring() provides a more natural feel by using physics parameters like 'friction', 'tension', 'bounciness', or 'stiffness' instead of a fixed duration.",
    "interviewTip": "Springs are generally preferred for UI interactions (like button presses or modas) because they feel more 'organic' to users."
  },
  "ab-05": {
    "prompt": "What is the correct way to initialize an animated value in a functional component to ensure it persists across renders?",
    "explanation": "useRef ensures that the Animated.Value instance is created once and doesn't get reset when the component re-renders.",
    "interviewTip": "Initializing in 'useRef' is the standard pattern for functional components to avoid memory leaks and state resets."
  },
  "ab-06": {
    "prompt": "How do you run multiple animations at the exact same time?",
    "explanation": "Animated.parallel starts an array of animations simultaneously.",
    "interviewTip": "Use this when you want an element to fade in and scale up at once."
  },
  "ab-07": {
    "prompt": "What does 'Animated.sequence([])' do?",
    "explanation": "Sequence ensures that the next animation in the array doesn't start until the previous one completes successfully.",
    "interviewTip": "This is great for multi-step 'onboarding' animations or complex UI transitions."
  },
  "ab-08": {
    "prompt": "How do you start an animation once it is defined?",
    "explanation": "Animations in React Native are declarative. They don't run until you explicitly call the '.start()' method.",
    "interviewTip": "You can pass a callback to .start(({ finished }) => { ... }) to handle logic after the animation ends."
  },
  "ab-09": {
    "prompt": "Which of these style properties CANNOT be used with 'useNativeDriver: true'?",
    "explanation": "As of current stable versions, the native driver primarily supports 'transform' and 'opacity'. Layout properties (width, height, flex) and some color properties typically require the JS thread.",
    "interviewTip": "If you need to animate layout properties smoothly, look into the 'LayoutAnimation' API or 'Reanimated'."
  },
  "ab-10": {
    "prompt": "What is 'Animated.event' primarily used for?",
    "explanation": "Animated.event allows for ultra-smooth interactions, like a header that shrinks as you scroll, by binding the 'contentOffset' of a ScrollView to an Animated value.",
    "interviewTip": "This is the most efficient way to link user gestures to UI changes."
  },
  "ab-11": {
    "prompt": "How do you create an animation that loops indefinitely?",
    "explanation": "Animated.loop() takes an animation and restarts it every time it reaches the end.",
    "interviewTip": "You can use this for 'pulse' effects on buttons or loading indicators."
  },
  "ab-12": {
    "prompt": "What is the 'LayoutAnimation' API used for?",
    "explanation": "LayoutAnimation is a 'fire-and-forget' API. You call it before updating state, and the native side handles the transition of all layout changes smoothly.",
    "interviewTip": "It’s very powerful but offers less granular control than the Animated API."
  },
  "ab-13": {
    "prompt": "Analyze the code. What will happen to the box after 2 seconds?",
    "explanation": "toValue: 0 for an opacity property results in the element becoming completely transparent.",
    "interviewTip": "Always ensure your initial value matches the intended starting point (e.g., new Animated.Value(1) for a fade-out)."
  },
  "ab-14": {
    "prompt": "What happens to an animation if the component unmounts while the animation is running?",
    "explanation": "While RN is generally stable, not stopping animations on unmount can occasionally lead to 'updating state on unmounted component' warnings or memory issues.",
    "interviewTip": "In 'useEffect' cleanups, you should stop active animations if they are tied to local state."
  },
  "lp-01": {
    "prompt": "Why is <FlatList> more performant than <ScrollView> for long lists of data?",
    "explanation": "FlatList lazily renders items as they are about to appear and unmounts items that move far off-screen, saving significant memory.",
    "interviewTip": "This concept is called 'Windowing' or 'Virtualization'."
  },
  "lp-02": {
    "prompt": "Which prop is required in <FlatList> to tell it what to render for each item in the data array?",
    "explanation": "The renderItem prop takes a function that receives an object (usually destructured as { item, index }) and returns a JSX element.",
    "interviewTip": "To keep performance high, define the renderItem function outside of your component or wrap it in useCallback."
  },
  "lp-03": {
    "prompt": "What is the purpose of the 'keyExtractor' prop?",
    "explanation": "By default, FlatList looks for an 'id' or 'key' property. If your data uses different names (like 'uuid'), you must use keyExtractor.",
    "interviewTip": "Always provide a unique string as a key. Avoid using the index if the data can be reordered or filtered."
  },
  "lp-04": {
    "prompt": "How do you render a header that scrolls along with the list items?",
    "explanation": "Using ListHeaderComponent ensures the header stays part of the list's scrollable area without breaking the virtualization logic.",
    "interviewTip": "Never wrap a FlatList inside a ScrollView of the same orientation; it breaks virtualization and causes performance warnings."
  },
  "lp-05": {
    "prompt": "Which component should you use to render grouped data (e.g., a contact list organized by the first letter of the name)?",
    "explanation": "SectionList is designed specifically for data divided into logical sections, each with its own header.",
    "interviewTip": "SectionList data must be an array of objects, where each object has a 'data' array (e.g., { title: 'A', data: ['Alice', 'Aaron'] })."
  },
  "lp-06": {
    "prompt": "What does the 'getItemLayout' prop optimize?",
    "explanation": "By providing the exact dimensions of items ahead of time, FlatList doesn't have to calculate them on the fly as you scroll, making it much smoother.",
    "interviewTip": "This is a 'pro' optimization for lists with hundreds of items where every item has a constant height."
  },
  "lp-07": {
    "prompt": "Analyze the code. What will happen if the user reaches the bottom of the list?",
    "explanation": "onEndReachedThreshold is a value from 0 to 1 representing how close to the bottom (as a fraction of the list length) the user must be to trigger the event.",
    "interviewTip": "This is how 'Infinite Scroll' is implemented in mobile apps."
  },
  "lp-08": {
    "prompt": "How do you add a separator line between items without adding it to the top or bottom of the list?",
    "explanation": "ItemSeparatorComponent renders a component between every item, but excludes the very top and very bottom of the list.",
    "interviewTip": "This is cleaner than using margins or borders because it handles the 'edges' of the list automatically."
  },
  "lp-09": {
    "prompt": "Which of these props can help improve performance on a very slow FlatList?",
    "explanation": "All these props fine-tune the virtualization engine. For example, a smaller windowSize reduces memory but might show more 'blank' spaces during fast scrolling.",
    "interviewTip": "Always start with defaults. Only tweak these if you notice visible lag or high memory usage."
  },
  "lp-10": {
    "prompt": "What is the 'extraData' prop used for in a FlatList?",
    "explanation": "FlatList is a PureComponent. It only re-renders if the 'data' prop reference changes. If your items depend on a global 'theme' or 'selectedID', you must pass that to extraData.",
    "interviewTip": "If your list isn't updating when you change a single item's selected state, you probably forgot extraData."
  },
  "lp-11": {
    "prompt": "How do you implement 'Pull to Refresh' in a FlatList?",
    "explanation": "refreshing (boolean) shows the spinner; onRefresh (function) is the callback where you fetch new data.",
    "interviewTip": "This provides the native 'bounce and spin' experience users expect on mobile."
  },
  "lp-12": {
    "prompt": "What happens if you don't provide a unique key to list items?",
    "explanation": "React uses keys to optimize DOM/Native UI updates. Using the index can cause 'state' to stick to the wrong items if the list changes.",
    "interviewTip": "In an interview, explain that stable keys prevent expensive re-mounts."
  },
  "lp-13": {
    "prompt": "Which prop allows you to render the list in multiple columns (e.g., a grid)?",
    "explanation": "numColumns={2} will automatically arrange items in two columns. This requires your items to have a flexible width or matching fixed width.",
    "interviewTip": "Note that you cannot change numColumns on the fly; the component must remount for this to change."
  },
  "lp-14": {
    "prompt": "What is the 'ListEmptyComponent' used for?",
    "explanation": "It's a convenient prop to handle the empty state without using extra ternary operators in your JSX.",
    "interviewTip": "It makes your component code much cleaner."
  },
  "ia-01": {
    "prompt": "How do you provide different image resolutions for different screen densities in React Native (e.g., Retina displays)?",
    "explanation": "If you have 'logo.png', 'logo@2x.png', and 'logo@3x.png', React Native will automatically pick the best one for the device's screen density.",
    "interviewTip": "This ensures images look crisp without downloading unnecessarily large files on lower-end devices."
  },
  "ia-02": {
    "prompt": "What happens if you omit the 'width' and 'height' styles for a remote (network) image?",
    "explanation": "Unlike local images (require), React Native does not know the dimensions of a network image until it is downloaded. You MUST specify size styles.",
    "interviewTip": "Always provide dimensions or a flex value to remote images to avoid invisible components."
  },
  "ia-03": {
    "prompt": "Which library is considered the industry standard for advanced image caching and performance in React Native?",
    "explanation": "FastImage replaces the standard Image component, offering better caching, priority loading, and GIF support using native SDWebImage (iOS) and Glide (Android).",
    "interviewTip": "Mention FastImage when asked about 'image flickering' or performance issues in long lists like FlatList."
  },
  "ia-04": {
    "prompt": "How do you render an SVG file in a standard React Native project?",
    "explanation": "SVGs are not native UI elements in mobile OS. You need the 'react-native-svg' library (and often 'react-native-svg-transformer') to render them.",
    "interviewTip": "Using SVGs is preferred for icons because they stay sharp at any size and reduce bundle weight."
  },
  "ia-05": {
    "prompt": "What is the purpose of the 'defaultSource' prop on the Image component?",
    "explanation": "It improves UX by showing a local 'loading' or 'avatar-placeholder' image instead of a blank space while the network request finishes.",
    "interviewTip": "Note that 'defaultSource' is only supported on iOS. For Android, you usually manage this with state."
  },
  "ia-06": {
    "prompt": "Which component should you use to display a background image that contains other components as children?",
    "explanation": "ImageBackground is a wrapper that has the same props as Image but allows you to nest children inside it.",
    "interviewTip": "It's effectively a <View> with an absolute-positioned <Image> behind it."
  },
  "ia-07": {
    "prompt": "What is 'Base64' image rendering?",
    "explanation": "Base64 allows you to pass the actual binary data of the image as a string. It's useful for small icons or images fetched from a local database.",
    "interviewTip": "Avoid using Base64 for large images, as it increases memory usage and slows down the JS thread."
  },
  "ia-08": {
    "prompt": "How do you handle images that need to be tinted (e.g., making a black icon blue)?",
    "explanation": "The 'tintColor' style property changes the color of all non-transparent pixels to the specified color.",
    "interviewTip": "This is great for icons, allowing you to use one PNG asset for multiple themes (Light/Dark)."
  },
  "ia-09": {
    "prompt": "In Expo, which library is used for high-performance image handling that mimics the 'FastImage' functionality?",
    "explanation": "'expo-image' is a high-performance component designed for speed, supporting blurhash (placeholders) and smooth transitions.",
    "interviewTip": "It is currently the recommended way to handle images in the Expo ecosystem."
  },
  "ia-10": {
    "prompt": "Which of the following are valid image formats supported by React Native?",
    "explanation": "While PNG, JPG, and GIF are universally supported, SVG requires a library. WebP is excellent for performance but requires extra care on older iOS versions.",
    "interviewTip": "Mention WebP as a way to reduce app size while maintaining high quality."
  },
  "ia-11": {
    "prompt": "What is the result of using 'resizeMode: \"contain\"'?",
    "explanation": "'contain' ensures the whole image is visible within the frame, which may leave empty space (letterboxing).",
    "interviewTip": "Use 'contain' for logos and 'cover' for background photos."
  },
  "ia-12": {
    "prompt": "How can you pre-load a remote image before showing it to the user?",
    "explanation": "Image.prefetch(url) downloads the image to the local disk cache so it displays instantly when the component later mounts.",
    "interviewTip": "This is perfect for pre-loading the next image in a gallery or a user's profile picture during login."
  },
  "ia-13": {
    "prompt": "Why might an image disappear or 'flicker' when a FlatList scrolls?",
    "explanation": "Standard Image components often re-fetch or re-decode images when they scroll back into view. Using a library with a better cache helps fix this.",
    "interviewTip": "This is the 'smoking gun' for needing react-native-fast-image or expo-image."
  },
  "ia-14": {
    "prompt": "What is a 'BlurHash'?",
    "explanation": "Blurhash allows you to show a beautiful, colorful blurred placeholder while the high-res image is still downloading.",
    "interviewTip": "It significantly improves the 'Perceived Performance' of your app."
  },
  "gh-01": {
    "prompt": "Why is 'React Native Gesture Handler' preferred over the built-in 'PanResponder'?",
    "explanation": "RNGH interacts directly with the native platform's gesture recognition system, meaning touch events don't have to travel to the JS thread to be processed.",
    "interviewTip": "Always mention 'determinism' and 'responsiveness' when comparing RNGH to PanResponder."
  },
  "gh-02": {
    "prompt": "Which component must wrap your entire app to enable Gesture Handler functionality?",
    "explanation": "To ensure gestures are captured correctly, especially on Android, you must wrap your entry point (usually App.js) in a <GestureHandlerRootView>.",
    "interviewTip": "Missing this wrapper is the most common reason gestures 'silently fail' to trigger."
  },
  "gh-03": {
    "prompt": "What will this code do when the user drags their finger across the screen?",
    "explanation": "In a Pan gesture, 'translationX' and 'translationY' represent the distance the finger has moved since the gesture started.",
    "interviewTip": "Contrast 'translation' (movement relative to start) with 'absolutePosition' (coordinate relative to parent)."
  },
  "gh-04": {
    "prompt": "Which gesture handler is specifically designed for a single quick press?",
    "explanation": "Gesture.Tap() is used for discrete touch events. You can configure it to require multiple taps (e.g., double-tap to like).",
    "interviewTip": "Tap is preferred over Pressable when you need to coordinate it with other gestures like Pinch or Pan."
  },
  "gh-05": {
    "prompt": "How do you allow two gestures to work at the same time (e.g., pinching and rotating simultaneously)?",
    "explanation": "Gesture.Simultaneous() allows all provided gestures to remain active together.",
    "interviewTip": "This is essential for complex 'Image Editor' interfaces where users expect multi-touch freedom."
  },
  "gh-06": {
    "prompt": "What is the purpose of 'Gesture.Exclusive'?",
    "explanation": "Exclusive gives priority to the first gesture. If a double-tap is detected, it prevents the single-tap from firing.",
    "interviewTip": "This is how you solve conflicts between overlapping touch areas."
  },
  "gh-07": {
    "prompt": "Which event callback runs when the user lifts their finger from the screen?",
    "explanation": "onFinalize runs regardless of whether the gesture finished successfully or was cancelled. onEnd only runs if the gesture was successful.",
    "interviewTip": "Use onFinalize to 'reset' your UI state to ensure it doesn't get stuck if the gesture is interrupted."
  },
  "gh-08": {
    "prompt": "Which of these are valid built-in gesture types in RNGH?",
    "explanation": "Pinch, Rotation, and Fling are all touch gestures. 'Shake' is a device motion event, not handled by Gesture Handler.",
    "interviewTip": "Mention 'Fling' as an optimized way to handle 'Swipe to delete' interactions."
  },
  "gh-09": {
    "prompt": "What does 'simultaneousHandlers' prop do in the legacy API?",
    "explanation": "Without this, a ScrollView would 'steal' the touch event as soon as it detects movement. simultaneousHandlers allows both to cooperate.",
    "interviewTip": "This is crucial for drawers or bottom sheets that contain scrollable content."
  },
  "gh-10": {
    "prompt": "In the new 'Gesture' API (v2), how do you attach the gesture to a View?",
    "explanation": "The GestureDetector is the wrapper that bridges the gesture definition with a specific UI component.",
    "interviewTip": "Remember that GestureDetector can only have ONE child."
  },
  "rn-flex-01": {
    "prompt": "What is the default 'flexDirection' for a View in React Native?",
    "explanation": "On the web, the default is 'row'. In React Native, it is 'column' to better align with the vertical nature of mobile devices.",
    "interviewTip": "Always verify the direction before debugging alignment, as 'justifyContent' and 'alignItems' swap roles depending on this property."
  },
  "rn-flex-02": {
    "prompt": "Which property aligns children along the 'Main Axis'?",
    "explanation": "justifyContent defines how children are distributed along the primary axis (defined by flexDirection).",
    "interviewTip": "Common values include 'center', 'space-between', and 'space-around'."
  },
  "rn-flex-03": {
    "prompt": "What will be the size of these two boxes?",
    "explanation": "Flex values are proportional. Total flex is 1 + 3 = 4. Red is 1/4 (25%) and Blue is 3/4 (75%).",
    "interviewTip": "In React Native, 'flex: 1' on a single child tells it to fill all available space in its parent."
  },
  "rn-flex-04": {
    "prompt": "Which property allows an individual child to deviate from the 'alignItems' set by its parent?",
    "explanation": "alignSelf allows you to override the parent's alignment for a specific element.",
    "interviewTip": "This is very useful for centering one specific item in a list that is otherwise stretched."
  },
  "rn-flex-05": {
    "prompt": "In React Native, what is the default value for 'alignItems'?",
    "explanation": "By default, children are 'stretched' to fill the secondary axis of their parent unless a specific width/height is provided.",
    "interviewTip": "If your child component is 'disappearing', it might be because you set flexDirection: 'row' and the default 'stretch' is trying to find a height it doesn't have."
  },
  "rn-flex-06": {
    "prompt": "How do you center a child both horizontally and vertically inside a standard View?",
    "explanation": "Using 'center' for both justifyContent (main axis) and alignItems (cross axis) centers the content perfectly.",
    "interviewTip": "Ensure the parent has 'flex: 1' or a specific size, or there will be no space to center within."
  },
  "rn-flex-07": {
    "prompt": "What is the result of using 'flex: -1' in React Native?",
    "explanation": "A negative flex value allows a component to shrink when the content overflows the parent, but it won't take up extra space otherwise.",
    "interviewTip": "This is rarely used but helpful for handling dynamic text in tight headers."
  },
  "rn-flex-08": {
    "prompt": "Which property should you use to add space between items in a Flex container without using margins?",
    "explanation": "Modern React Native versions support the 'gap' property (as well as rowGap and columnGap), which adds space specifically between items.",
    "interviewTip": "Using 'gap' is much cleaner than applying margin to every child and then removing it from the last one."
  },
  "rn-flex-09": {
    "prompt": "Analyze this code. Where will the 'Box' be located?",
    "explanation": "flex-end for row direction puts it at the right; flex-end for cross-axis puts it at the bottom.",
    "interviewTip": "Always visualize the 'L' shape of the axis: Main axis (X) and Cross axis (Y) for row direction."
  },
  "rn-flex-10": {
    "prompt": "Does React Native support 'z-index' for overlapping elements?",
    "explanation": "React Native supports zIndex. However, if multiple elements have the same zIndex, the one defined later in the JSX appears on top.",
    "interviewTip": "On Android, sometimes 'elevation' is needed alongside zIndex for shadow-related overlapping issues."
  },
  "rn-flex-11": {
    "prompt": "Which of the following are valid units for 'width' and 'height' in React Native styles?",
    "explanation": "React Native primarily uses unitless numbers (logical pixels) and percentage strings. rem/em/vh/vw are not natively supported.",
    "interviewTip": "To get screen-based units (like vw/vh), use the 'Dimensions' or 'useWindowDimensions' API."
  },
  "rn-flex-12": {
    "prompt": "What is 'flexBasis' used for?",
    "explanation": "flexBasis determines the default size of an item before the remaining space is distributed via flexGrow or flexShrink.",
    "interviewTip": "If flexDirection is 'column', flexBasis acts like 'height'. If 'row', it acts like 'width'."
  },
  "rn-flex-13": {
    "prompt": "How do you make a View wrap its children into multiple lines if they exceed the container width?",
    "explanation": "By default, flex containers are 'nowrap'. Setting 'flexWrap: wrap' allows items to move to the next line.",
    "interviewTip": "This is essential for creating 'tag cloud' layouts or photo grids."
  },
  "rn-flex-14": {
    "prompt": "What is the 'Shadow Thread' responsible for?",
    "explanation": "The Shadow Thread is where React Native calculates the mathematical layout of your components using Yoga before sending it to the UI Thread.",
    "interviewTip": "Knowing this helps you understand that style changes in JS have a specific path through threads before appearing on screen."
  },
  "rn-flex-15": {
    "prompt": "How do you get the width of the physical screen in React Native?",
    "explanation": "The Dimensions API (or the useWindowDimensions hook) provides the width and height of the current window/screen.",
    "interviewTip": "Prefer 'useWindowDimensions' because it automatically updates if the screen rotates or the window size changes (on tablets/web)."
  },
  "rn-flex-16": {
    "prompt": "What does 'aspectRatio' do in a Style object?",
    "explanation": "If you set 'aspectRatio: 1', the component will always be a square, even if only the width is defined.",
    "interviewTip": "This is incredibly useful for images and video containers where you want them to be responsive but maintain a 16:9 or 4:3 look."
  },
  "rn-flex-17": {
    "prompt": "Identify the error in this Style object:",
    "explanation": "React Native does not implement the full CSS spec. Properties like float, clear, and block/inline display do not exist.",
    "interviewTip": "If you need a side-by-side layout, always use 'flexDirection: row'."
  },
  "hf-01": {
    "prompt": "What is the mandatory first step before accessing any hardware feature like the Camera or Location in a production app?",
    "explanation": "Modern OS (iOS and Android) require apps to explicitly ask the user for permission. Attempting to use a sensor without permission will cause a crash or a silent fail.",
    "interviewTip": "Distinguish between 'Ask once' and 'Always allowed' permissions, especially for Location."
  },
  "hf-02": {
    "prompt": "In Expo, which library is the standard for accessing the device's camera?",
    "explanation": "expo-camera provides a high-level component that handles the viewfinder, taking photos, and recording videos.",
    "interviewTip": "Mention that for highly advanced needs (like frame processors for AI), 'react-native-vision-camera' is often used in the CLI workflow."
  },
  "hf-03": {
    "prompt": "How do you handle the difference between 'Foreground' and 'Background' location permissions on Android?",
    "explanation": "To protect privacy, Android 10+ requires users to specifically grant 'Allow all the time' for background access.",
    "interviewTip": "Always follow the 'Principle of Least Privilege'—only ask for background access if it is critical to the app's core function."
  },
  "hf-04": {
    "prompt": "Which library is used to implement FaceID or Fingerprint authentication in React Native?",
    "explanation": "expo-local-authentication (and react-native-local-auth for CLI) provides a unified API to trigger the device's native biometric prompt.",
    "interviewTip": "Always check 'hasHardwareAsync()' and 'isEnrolledAsync()' before showing the 'Login with FaceID' button."
  },
  "hf-05": {
    "prompt": "Analyze the code. What happens if the user denies the permission?",
    "explanation": "To prevent 'permission spamming,' iOS only shows the system dialog once. If the status is 'denied,' you must programmatically link to Settings using 'Linking.openSettings()'.",
    "interviewTip": "This is a critical UX detail for apps that rely on hardware."
  },
  "hf-06": {
    "prompt": "What is 'Geofencing'?",
    "explanation": "Geofencing allows apps to be notified by the OS when the user crosses a coordinate radius, even if the app isn't actively running.",
    "interviewTip": "This is very efficient for battery life compared to constantly polling the user's location."
  },
  "hf-07": {
    "prompt": "Where must you declare the 'reason' for requesting a permission (e.g., CameraUsageDescription) for iOS?",
    "explanation": "iOS requires a 'Purpose String' in the Info.plist. In Expo, you define these in the 'plugins' section of app.json and they are injected into the plist during build.",
    "interviewTip": "If you don't provide a clear, user-friendly reason, Apple will reject your app during review."
  },
  "hf-08": {
    "prompt": "What does the 'Accelerometer' sensor measure?",
    "explanation": "Accelerometers are used for shake detection, step counting, and controlling games by tilting the phone.",
    "interviewTip": "Mention that sensors like this produce data at high frequencies, so it's important to use a 'Subscription' model and clean it up in 'useEffect'."
  },
  "hf-09": {
    "prompt": "How do you check if an Android device has a physical 'Back' button or is using gesture navigation?",
    "explanation": "The BackHandler module lets you listen to the hardware back button press and prevent it or customize its behavior.",
    "interviewTip": "This is an Android-only concern; iOS users expect a 'Back' button in the navigation header or a swipe-back gesture."
  },
  "hf-10": {
    "prompt": "What is 'Linking' used for in hardware access?",
    "explanation": "The Linking module is the bridge to other apps. For example, `Linking.openURL('tel:123456')` triggers the native dialer.",
    "interviewTip": "Use 'Linking.canOpenURL' first to ensure the device has a handler for that specific link (like an email client)."
  },
  "dep-01": {
    "prompt": "What is 'Fastlane' in the context of React Native deployment?",
    "explanation": "Fastlane automates the tedious parts of iOS and Android deployment. You can define a 'Lane' that builds the app, signs it with certificates, and uploads it to TestFlight or Google Play.",
    "interviewTip": "Fastlane is usually used within CI/CD pipelines (like GitHub Actions) to avoid manual uploads from a developer's laptop."
  },
  "dep-02": {
    "prompt": "What is 'CodePush' (App Center) primarily used for?",
    "explanation": "CodePush allows you to fix bugs or update UI instantly by 'pushing' a new JS bundle to users. It bypasses the 24-48 hour store review process.",
    "interviewTip": "Remember: CodePush *cannot* be used for changes that involve new native modules or changes to the AppDelegate/MainApplication files."
  },
  "dep-03": {
    "prompt": "In the Expo ecosystem, what does 'EAS Build' provide?",
    "explanation": "EAS (Expo Application Services) Build takes your project and compiles it on Expo's servers. This is huge for developers who don't have a Mac but need to build an iOS app.",
    "interviewTip": "EAS works with both 'Managed' and 'Bare' React Native projects."
  },
  "dep-04": {
    "prompt": "Analyze the 'eas.json' snippet. What happens when you run 'eas build --profile preview'?",
    "explanation": "The 'internal' distribution and 'apk' build type are perfect for sharing a testable file with your team via a link, avoiding the store entirely.",
    "interviewTip": "Android uses .aab (Android App Bundle) for the Play Store, but .apk is needed for direct installation on devices."
  },
  "dep-05": {
    "prompt": "Which of these are required to sign a production iOS app for the App Store?",
    "explanation": "iOS code signing is a three-part system: the Certificate (Who you are), the App ID (What the app is), and the Provisioning Profile (The bridge between the two).",
    "interviewTip": "Managing these is often the biggest pain point in mobile dev. Tools like 'fastlane match' help share these across a dev team."
  },
  "dep-06": {
    "prompt": "What is 'Over-the-Air' (OTA) updating?",
    "explanation": "OTA updates (via Expo Updates or CodePush) are the mobile equivalent of 'refreshing the browser' on the web.",
    "interviewTip": "Note: Apple's rules allow OTA updates as long as you aren't significantly changing the 'primary purpose' of the app."
  },
  "dep-07": {
    "prompt": "Which file in an Android project contains the 'versionCode' and 'versionName'?",
    "explanation": "In Android, the app-level build.gradle is the source of truth for versioning. versionCode is an integer (for the store), versionName is the string (for users).",
    "interviewTip": "Every time you submit to the Play Store, the 'versionCode' MUST be higher than the last one."
  },
  "dep-08": {
    "prompt": "What is 'Semantic Versioning' (SemVer) as applied to mobile apps?",
    "explanation": "Major: Breaking changes. Minor: New features. Patch: Bug fixes. This is the standard for almost all software, including React Native apps.",
    "interviewTip": "For mobile, a Major change often indicates a required store update due to native changes."
  },
  "dep-09": {
    "prompt": "What is the role of a 'Keystore' in Android deployment?",
    "explanation": "If you lose your production Keystore, you cannot update your app on the Play Store anymore. It is critical to keep it backed up and secure.",
    "interviewTip": "Google Play App Signing now allows Google to manage the key for you, which is a safer modern alternative."
  },
  "dep-10": {
    "prompt": "How do you handle different environments (Development, Staging, Production) in React Native?",
    "explanation": "Environment variables allow you to switch between a local dev server and a production API without touching the source code.",
    "interviewTip": "Never commit sensitive API keys or secrets directly into your .env files if they will be committed to a public repo."
  },
  "rn-core-01": {
    "prompt": "Which component is the most fundamental building block for UI, acting as a container that supports layout with Flexbox?",
    "explanation": "The <View> component maps directly to the native equivalent (UIView on iOS, android.view on Android) and is used for layout and styling.",
    "interviewTip": "Think of <View> as the <div> of React Native."
  },
  "rn-core-02": {
    "prompt": "What will happen if you try to render raw text outside of a <Text> component?",
    "explanation": "Unlike the web where text can exist inside a <div>, React Native requires all text to be explicitly wrapped in a <Text> component.",
    "interviewTip": "This is a very common beginner mistake when transitioning from Web to Mobile."
  },
  "rn-core-03": {
    "prompt": "How do you display a remote image from a URL in React Native?",
    "explanation": "Remote images require an object with a 'uri' property. Local images use the 'require' function.",
    "interviewTip": "Remember that remote images in React Native do not have an automatic size; you MUST specify width and height in the styles or they won't show up."
  },
  "rn-core-04": {
    "prompt": "What is the primary purpose of the 'StyleSheet.create' method?",
    "explanation": "StyleSheet.create sends the style object through the bridge only once, rather than recreating it on every render, which is more efficient.",
    "interviewTip": "It also provides validation, throwing errors if you use invalid CSS properties that React Native doesn't support."
  },
  "rn-core-05": {
    "prompt": "Which component should you use if you need a container that allows the user to swipe through content that is larger than the screen?",
    "explanation": "A <View> has no scrolling capabilities. For basic scrolling of a small amount of content, <ScrollView> is the correct choice.",
    "interviewTip": "For large lists of data, <ScrollView> is inefficient because it renders all children at once. Use <FlatList> instead for performance."
  },
  "rn-core-06": {
    "prompt": "Which of the following properties are valid for the <Text> component in React Native?",
    "explanation": "The <Text> component is surprisingly powerful, supporting truncation, native touch events, and copy-paste selection.",
    "interviewTip": "Nested <Text> components inherit styles from their parents, which is different from how <View> inheritance works."
  },
  "rn-core-07": {
    "prompt": "How do you handle local assets (like a logo) in an <Image> component?",
    "explanation": "The 'require' syntax allows the packager to bundle the image metadata (width, height, path) during build time.",
    "interviewTip": "Unlike remote images, local images usually don't need explicit width/height to appear, though it's still good practice to set them."
  },
  "rn-core-08": {
    "prompt": "What is the difference between <View> and <SafeAreaView>?",
    "explanation": "SafeAreaView is essential for iOS devices with notches to ensure content isn't hidden behind system UI elements.",
    "interviewTip": "In modern development, many developers use the 'react-native-safe-area-context' library for even better control over safe areas."
  },
  "rn-core-09": {
    "prompt": "What is the result of applying 'flexDirection' to a <View> in React Native?",
    "explanation": "In standard Web CSS, the default is 'row'. In React Native, the default is 'column' to better suit vertical mobile screens.",
    "interviewTip": "This is one of the most frequent 'gotchas' for web developers moving to React Native."
  },
  "rn-core-10": {
    "prompt": "Which component is used to collect text input from the user?",
    "explanation": "TextInput is the core component for keyboard input. It supports various keyboard types (numeric, email) and secure text entry for passwords.",
    "interviewTip": "Always handle the 'onChangeText' prop (which gives the string directly) rather than 'onChange' (which gives an event object)."
  },
  "rn-core-11": {
    "prompt": "How do you apply multiple style objects to a single component?",
    "explanation": "React Native's 'style' prop accepts an array of objects. The last object in the array takes precedence (overwrites previous ones).",
    "interviewTip": "This is perfect for conditional styling: style={[styles.box, isActive && styles.activeBox]}."
  },
  "rn-core-12": {
    "prompt": "What is the purpose of the <ActivityIndicator /> component?",
    "explanation": "It's a built-in component that displays a native loading spinner (UIActivityIndicator on iOS, ProgressBar on Android).",
    "interviewTip": "You can customize its size ('small' or 'large') and color."
  },
  "rn-core-13": {
    "prompt": "Which of these are valid 'resizeMode' values for an <Image> component?",
    "explanation": "resizeMode determines how the image should be scaled when the frame doesn't match the image aspect ratio.",
    "interviewTip": "'cover' is the default and usually what you want for full-bleed backgrounds."
  },
  "rn-core-14": {
    "prompt": "Why is it important to use 'key' in a list of components rendered inside a ScrollView?",
    "explanation": "Just like React on the Web, the reconciliation algorithm uses keys to track the identity of elements in an array.",
    "interviewTip": "Using the array index as a key is generally discouraged if the order of items can change."
  },
  "rn-core-15": {
    "prompt": "What does the 'contentContainerStyle' prop do on a <ScrollView>?",
    "explanation": "If you apply padding to a ScrollView's 'style' prop, the content will be cut off. You must use 'contentContainerStyle' to add padding to the scrollable area itself.",
    "interviewTip": "This is the most common way to add 'breathing room' at the bottom of a scrollable list."
  },
  "rn-core-16": {
    "prompt": "What will the following code render on the screen?",
    "explanation": "By default, Views have 'alignItems: stretch', so it will take up the full width of its parent and act as a 1-pixel high line.",
    "interviewTip": "This is a common way to create custom border-like separators between list items."
  },
  "sb-01": {
    "prompt": "What happens when you update a React state variable using its setter function?",
    "explanation": "Calling a state setter notifies React that the underlying data has changed, triggering a re-render to synchronize the UI with the new data.",
    "interviewTip": "Remember that state updates are asynchronous and batched for performance."
  },
  "sb-02": {
    "prompt": "What is the correct way to initialize a state variable 'count' to 0?",
    "explanation": "useState returns an array where the first element is the current state and the second is the updater function. We use array destructuring to name them.",
    "interviewTip": "Always use 'const' for state variables because you should never mutate them directly; only the setter should change them."
  },
  "sb-03": {
    "prompt": "What will be the value of 'count' displayed in the UI after clicking the button once?",
    "explanation": "Because 'count' is captured from the current render's scope, all three calls see 'count' as 0. React batches these, and the result is 0 + 1.",
    "interviewTip": "This is a classic 'Stale Closure' example. To fix this, use the functional update pattern: setCount(prev => prev + 1)."
  },
  "sb-04": {
    "prompt": "Which of the following are true regarding the Rules of Hooks?",
    "explanation": "Hooks must follow a consistent call order. Placing them in loops or conditions breaks React's ability to track state correctly.",
    "interviewTip": "If you need a conditional hook, put the condition *inside* the hook (like useEffect) rather than wrapping the hook itself."
  },
  "sb-05": {
    "prompt": "How do you correctly update an object state while preserving existing fields?",
    "explanation": "The setter function replaces the state entirely. To update a field, you must spread the existing state and overwrite the target field.",
    "interviewTip": "Directly mutating 'user.age' fails because React uses Object.is to check for changes. If the object reference is the same, no render occurs."
  },
  "sb-06": {
    "prompt": "What is the primary benefit of the 'Lazy Initializer' pattern?",
    "explanation": "If you pass an initial value directly, it is calculated every render. If you pass a function, React only executes it during the first render.",
    "interviewTip": "Use this for expensive tasks like parsing large JSON from storage or complex mathematical computations."
  },
  "sb-07": {
    "prompt": "How do you access the value of an input field in a 'Controlled Component'?",
    "explanation": "React's synthetic event object 'e' contains a 'target' property pointing to the DOM element, which has the 'value' property.",
    "interviewTip": "In controlled components, the state is the 'single source of truth' for the input value."
  },
  "sb-08": {
    "prompt": "What is a 'SyntheticEvent' in React?",
    "explanation": "React creates these wrappers so that events behave identically across Chrome, Safari, Firefox, and Edge.",
    "interviewTip": "You can still access the native browser event via 'e.nativeEvent' if absolutely necessary."
  },
  "sb-09": {
    "prompt": "What will happen if you update state with the exact same value it currently holds?",
    "explanation": "React uses Object.is to compare the new state with the old. If they are identical, React avoids the unnecessary work of rendering.",
    "interviewTip": "This is why mutating an array and calling setState(sameArray) doesn't work—the reference is identical."
  },
  "sb-10": {
    "prompt": "Analyze the code. What is the console output after the button is clicked?",
    "explanation": "Setting state is asynchronous. The 'val' variable belongs to the current execution frame and doesn't change until the next render.",
    "interviewTip": "If you need to perform an action after state updates, use the 'useEffect' hook."
  },
  "sb-11": {
    "prompt": "Which of these are valid ways to trigger a function when a user clicks a button?",
    "explanation": "Option A passes a reference. Option C creates an anonymous function. Option D is wrong because it executes the function *during* render.",
    "interviewTip": "Watch out for 'onClick={handleClick()}'; it will cause an infinite loop if handleClick updates state."
  },
  "sb-12": {
    "prompt": "How do you clear an interval created inside a component when using state timers?",
    "explanation": "To prevent memory leaks and unexpected behavior, you must clear side effects like intervals when a component unmounts.",
    "interviewTip": "This is a key part of the component lifecycle management."
  },
  "sb-13": {
    "prompt": "What is 'State Lifting'?",
    "explanation": "When two sibling components need to stay in sync, you move the state to their parent and pass it back down via props.",
    "interviewTip": "This is the standard way to share state without using Context."
  },
  "sb-14": {
    "prompt": "What is the default value of 'event.preventDefault()' in a form's 'onSubmit'?",
    "explanation": "By default, HTML forms reload the page. In React 'Single Page Apps', we prevent this to handle the submission via JS.",
    "interviewTip": "Always remember this in form handlers to avoid losing your application state."
  },
  "sb-15": {
    "prompt": "How do you correctly handle a state update that depends on the previous state?",
    "explanation": "Functional updates guarantee that you are working with the most recent state, even if multiple updates are queued.",
    "interviewTip": "This pattern is essential when state updates are triggered rapidly (like in an interval or during high-frequency events)."
  },
  "sb-16": {
    "prompt": "Where can you define state in a functional component?",
    "explanation": "According to the Rules of Hooks, they must be called at the very top of your component function.",
    "interviewTip": "React uses the call order to map state to the correct component instance."
  },
  "sb-17": {
    "prompt": "What is an 'Uncontrolled Component'?",
    "explanation": "In uncontrolled components, the form data is handled by the DOM itself. You use 'useRef' to pull values when needed.",
    "interviewTip": "Controlled components are usually preferred for complex forms, while uncontrolled are fine for simple, one-off inputs."
  },
  "ss-01": {
    "prompt": "What is the primary problem that React Query solves compared to using useEffect for data fetching?",
    "explanation": "While useEffect can fetch data, it doesn't handle caching or background re-fetching. React Query manages the lifecycle of your server data so you don't have to.",
    "interviewTip": "Mention that React Query treats 'Server State' as something the client doesn't own, but merely 'borrows'."
  },
  "ss-02": {
    "prompt": "Analyze the code. What does 'data' contain while 'isLoading' is true?",
    "explanation": "During the very first fetch (hard loading state), 'data' is undefined until the promise resolves.",
    "interviewTip": "If you have cached data from a previous session, 'isLoading' might be false while 'isFetching' is true."
  },
  "ss-03": {
    "prompt": "What is the 'queryKey' used for in React Query?",
    "explanation": "The queryKey (usually an array) tells React Query when to re-fetch data. If the key changes (e.g., ['user', id]), the query automatically re-runs.",
    "interviewTip": "Think of the queryKey as the 'dependency array' for your server data."
  },
  "ss-04": {
    "prompt": "Which properties are returned by the 'useQuery' hook to help manage UI states?",
    "explanation": "useQuery provides a rich set of boolean flags and data objects to handle every possible network state.",
    "interviewTip": "The difference between 'isLoading' and 'isFetching' is a common senior-level question (Initial fetch vs. Background update)."
  },
  "ss-05": {
    "prompt": "How do you perform 'Data Mutations' (POST/PUT/DELETE) in React Query?",
    "explanation": "useMutation is used for any server-side side effects. It provides methods like 'mutate' and 'mutateAsync' to trigger the call.",
    "interviewTip": "Always mention 'Invalidation'—after a mutation, you usually want to tell React Query that the old data is now 'stale'."
  },
  "ss-06": {
    "prompt": "What does 'queryClient.invalidateQueries' do?",
    "explanation": "This is the 'magic' of React Query. After updating data, you invalidate the key, and the UI automatically refreshes with the latest server values.",
    "interviewTip": "This is the standard way to handle 'Optimistic Updates' fallbacks as well."
  },
  "ss-07": {
    "prompt": "What is 'Stale Time' in React Query?",
    "explanation": "By default, staleTime is 0, meaning data is considered stale immediately. Setting it higher reduces network traffic for data that doesn't change often.",
    "interviewTip": "Don't confuse 'staleTime' with 'gcTime' (formerly cacheTime). gcTime determines when inactive data is deleted from memory."
  },
  "ss-08": {
    "prompt": "Identify the issue in the following code snippet:",
    "explanation": "The 'queryFn' must be a function that React Query can call later. Correct syntax: `queryFn: () => fetchUser(id)`.",
    "interviewTip": "This is a frequent mistake that leads to infinite loops or execution during the wrong phase."
  },
  "ss-09": {
    "prompt": "How does React Query handle a lost internet connection?",
    "explanation": "React Query has built-in 'Offline Support' and will pause/resume fetches based on the browser's connectivity status.",
    "interviewTip": "You can customize the 'retry' count and 'retryDelay' in the global configuration."
  },
  "ss-10": {
    "prompt": "What is an 'Optimistic Update'?",
    "explanation": "You update the cache manually when the user clicks 'Submit'. If the server fails, you 'roll back' to the previous state.",
    "interviewTip": "This makes your app feel 'instant' even on slow connections."
  },
  "ss-11": {
    "prompt": "Which component is required at the root of your app to use React Query?",
    "explanation": "You must create a `const queryClient = new QueryClient()` and pass it to the `<QueryClientProvider client={queryClient}>`.",
    "interviewTip": "This provider holds the 'Query Cache', which is what allows data to be shared across the entire app without Redux."
  },
  "ss-12": {
    "prompt": "What is the result of 'enabled: false' in useQuery options?",
    "explanation": "The 'enabled' option is used for 'Dependent Queries' (waiting for a userId) or manual triggers.",
    "interviewTip": "Use this to prevent a query from running until you have all the necessary data (like an ID from a previous query)."
  },
  "rt-01": {
    "prompt": "Which component is used to define the mapping between a URL path and a React component?",
    "explanation": "<Route> is the fundamental building block. It renders its element only when the current URL matches the 'path' prop.",
    "interviewTip": "In React Router v6, the syntax changed to <Route path='/...' element={<MyComponent />} />."
  },
  "rt-02": {
    "prompt": "How do you navigate to a new page programmatically in a functional component (e.g., after a form submission)?",
    "explanation": "The 'useNavigate' hook returns a function that lets you change the URL without a full page reload.",
    "interviewTip": "Use 'navigate('/path', { replace: true })' if you want to replace the current entry in the history stack instead of adding a new one."
  },
  "rt-03": {
    "prompt": "What is the primary difference between a standard <a> tag and a React Router <Link> tag?",
    "explanation": "<a> tags cause the browser to refresh the page. <Link> tags use the History API to update the URL and re-render only the necessary components.",
    "interviewTip": "Using <a> for internal navigation breaks the 'Single Page' experience and resets the application state."
  },
  "rt-04": {
    "prompt": "How do you access dynamic parameters from the URL (e.g., the 'id' in '/users/:id')?",
    "explanation": "The 'useParams' hook returns an object of key/value pairs of URL parameters defined in the route path.",
    "interviewTip": "Always ensure the variable name in destructuring matches the placeholder name in the Route path."
  },
  "rt-05": {
    "prompt": "Which of these components must wrap your entire application to enable routing functionality?",
    "explanation": "BrowserRouter is the most common (uses clean URLs), while HashRouter uses the # fragment for compatibility with older servers/static hosting.",
    "interviewTip": "Most modern apps use BrowserRouter for SEO-friendly URLs."
  },
  "rt-06": {
    "prompt": "What is the purpose of the <Outlet /> component in React Router v6?",
    "explanation": "Outlet is used in a parent route's element to indicate where child route elements should be rendered.",
    "interviewTip": "This is the key to creating shared layouts (like a persistent sidebar or navbar)."
  },
  "rt-07": {
    "prompt": "How do you define a '404 Not Found' route in React Router v6?",
    "explanation": "The '*' (splat) path acts as a wildcard that matches any URL that hasn't been matched by previous routes.",
    "interviewTip": "Place the wildcard route at the very bottom of your <Routes> list."
  },
  "rt-08": {
    "prompt": "What does the 'useLocation' hook return?",
    "explanation": "useLocation provides access to the 'location' object, which is useful for tracking page views or reading query strings (?query=abc).",
    "interviewTip": "You can use 'location.state' to pass hidden data between routes that doesn't appear in the URL."
  },
  "rt-09": {
    "prompt": "How can you pass query parameters (e.g., ?sort=asc) and read them in a component?",
    "explanation": "useSearchParams is the React-friendly hook for managing query strings. You can also manually parse location.search.",
    "interviewTip": "Query params are great for shareable UI states like filters or search terms."
  },
  "rt-10": {
    "prompt": "What happens if you have multiple routes that match the current URL in React Router v6?",
    "explanation": "Unlike v5 which picked the first match (requiring 'exact'), v6 is smarter and calculates the most specific match automatically.",
    "interviewTip": "This means the order of routes matters less in v6 than it did in previous versions."
  },
  "rt-11": {
    "prompt": "How do you implement a 'Redirect' after a user logs out in v6?",
    "explanation": "The <Navigate /> component is the declarative way to perform a redirect during rendering.",
    "interviewTip": "Use this for 'Protected Routes' where you check authentication before showing a page."
  },
  "rt-12": {
    "prompt": "Analyze the code. What is the URL after clicking 'Details'?",
    "explanation": "Links without a leading slash are 'relative' to the current path. Since we are at /products, appending 123 results in /products/123.",
    "interviewTip": "Use absolute paths (starting with /) if you want to navigate from the root of the site."
  },
  "rl-01": {
    "prompt": "What is the primary purpose of the 'key' prop when rendering a list in React?",
    "explanation": "Keys act as stable identities for elements across renders. Without them, React might unnecessarily re-render the entire list or misidentify which element is which during updates.",
    "interviewTip": "Keys should be unique among siblings and stable (not changing on every render)."
  },
  "rl-02": {
    "prompt": "Which JavaScript method is most commonly used to transform an array of data into a list of React components?",
    "explanation": "The .map() method is ideal because it returns a new array of the same length, allowing you to wrap each data item in JSX.",
    "interviewTip": "Remember that .forEach() returns undefined and won't render anything in JSX."
  },
  "rl-03": {
    "prompt": "What is a potential downside of using the array 'index' as a key?",
    "explanation": "If the list changes order, the index stays the same for a position even if the content moves. This confuses React's state management for those components.",
    "interviewTip": "Only use the index as a key if the list is static (never changes, filters, or sorts)."
  },
  "rl-04": {
    "prompt": "Analyze the code below. What will happen if two items have the same ID?",
    "explanation": "React requires keys to be unique among siblings. Duplicate keys cause unpredictable behavior during updates, and React will warn you in development.",
    "interviewTip": "If your data lacks unique IDs, you can combine fields (like item.type + item.id) to create a unique string."
  },
  "rl-05": {
    "prompt": "Where exactly should the 'key' prop be placed when rendering a list of custom components?",
    "explanation": "The key must always be applied to the outermost element returned by the map function so React can track the item in the collection.",
    "interviewTip": "If you wrap your component in a <div> or a Fragment inside the map, the key goes on that wrapper."
  },
  "rl-06": {
    "prompt": "Which of the following are recommended sources for a 'key' prop?",
    "explanation": "Keys must be stable. Random numbers or timestamps change every render, causing the entire list to unmount and remount, which destroys state and performance.",
    "interviewTip": "Stable, unique IDs are the gold standard for React keys."
  },
  "rl-07": {
    "prompt": "How do you render a list if you don't want an extra wrapper tag like <div> or <li>?",
    "explanation": "The shorthand <> syntax does not support the 'key' prop. When mapping multiple elements without a wrapper, you must use <React.Fragment key={...}>.",
    "interviewTip": "This is one of the few cases where the long-form Fragment syntax is mandatory."
  },
  "rl-08": {
    "prompt": "What is the output of the following rendering logic?",
    "explanation": "React allows you to mix dynamic content (arrays) with static JSX. It will simply render them in the order they appear.",
    "interviewTip": "This is useful for adding a 'Create New' or 'Load More' item at the end of a dynamic list."
  },
  "rl-09": {
    "prompt": "What does React do when it detects a key change for a component (e.g., key 1 becomes key 2)?",
    "explanation": "Changing a key tells React the identity of the component has changed. It destroys the old instance (including its local state) and creates a fresh one.",
    "interviewTip": "You can intentionally change a key to 'reset' a component (like a form) to its initial state."
  },
  "rl-10": {
    "prompt": "Is it possible to use an object as a key?",
    "explanation": "React converts keys to strings internally. Using an object will result in the string '[object Object]' for all items, making them non-unique.",
    "interviewTip": "Always pick a primitive value (string/number) for your key."
  },
  "rl-11": {
    "prompt": "What will happen if you provide no key at all while mapping?",
    "explanation": "React will default to using the array index as a key if none is provided, but it will log a warning to alert you of potential performance and bug issues.",
    "interviewTip": "Warnings in the console are often missed—always check your logs during development."
  },
  "rl-12": {
    "prompt": "Which of the following scenarios absolutely require a unique key?",
    "explanation": "Sorting and removing items are operations where React's diffing algorithm relies heavily on keys to avoid state bugs (like text staying in an input while the label changes).",
    "interviewTip": "If the list can be manipulated by the user, a stable key is mandatory."
  },
  "rl-13": {
    "prompt": "How do you render a list in reverse order using .map()?",
    "explanation": "Since .reverse() mutates the original array, we spread the data into a new array `[...data]` first, then reverse and map.",
    "interviewTip": "Always keep your data transformations 'immutable' to avoid side effects."
  },
  "rl-14": {
    "prompt": "What is the most efficient way to render a very long list (e.g., 10,000 items)?",
    "explanation": "Windowing only renders the items currently visible in the viewport, significantly reducing the number of DOM nodes.",
    "interviewTip": "Mention libraries like 'react-window' or 'react-virtualized' for this purpose."
  },
  "rl-15": {
    "prompt": "In the following snippet, why is 'Math.random()' a bad choice for a key?",
    "explanation": "Every time the component re-renders, a new random key is generated. React thinks it's a new element and recreates it from scratch.",
    "interviewTip": "A key must stay the same for the same item between renders to be useful."
  },
  "rl-16": {
    "prompt": "How do you filter a list before rendering it?",
    "explanation": "Method chaining (filter then map) is the standard and most readable way to handle conditional list rendering.",
    "interviewTip": "For large lists, you might wrap this logic in useMemo to avoid re-calculating on every render."
  },
  "rl-17": {
    "prompt": "If a list item has a state (like a toggle), what happens to that state if the item is removed from the array?",
    "explanation": "State is tied to the component instance in the DOM tree. When an item is removed from the array, its component is unmounted and its state is wiped.",
    "interviewTip": "If data must survive a list removal, it should be stored in the parent's state or a global store."
  },
  "rd-01": {
    "prompt": "What is the primary purpose of the 'useRef' hook in React?",
    "explanation": "useRef returns a plain JavaScript object that persists for the full lifetime of the component. Changing the .current property does not trigger a re-render.",
    "interviewTip": "Think of useRef as a 'box' that can hold any value, but most commonly it holds a DOM element."
  },
  "rd-02": {
    "prompt": "How do you access a DOM node using a ref in a functional component?",
    "explanation": "When you pass a ref to a JSX element, React sets the '.current' property of that ref object to the corresponding DOM node.",
    "interviewTip": "Always check if inputRef.current exists before calling methods on it to avoid null errors."
  },
  "rd-03": {
    "prompt": "What happens to the value stored in 'useRef' when the component re-renders?",
    "explanation": "Unlike local variables, which are recreated every render, useRef values are kept by React throughout the component's lifecycle.",
    "interviewTip": "This makes refs perfect for storing timers, interval IDs, or previous prop values."
  },
  "rd-04": {
    "prompt": "In which scenarios is it appropriate to use a Ref?",
    "explanation": "If something can be done 'declaratively' with state, use state. Use refs only for 'imperative' actions like focusing or measuring.",
    "interviewTip": "The React docs call refs an 'escape hatch'—use them only when state isn't enough."
  },
  "rd-05": {
    "prompt": "What is the purpose of 'forwardRef'?",
    "explanation": "By default, you cannot pass a 'ref' prop to a functional component. forwardRef 'forwards' the ref from the parent down to a specific element in the child.",
    "interviewTip": "This is a common pattern for design system components like Inputs or Buttons."
  },
  "rd-06": {
    "prompt": "When does React update the 'ref.current' property?",
    "explanation": "React assigns the DOM node to .current when the component mounts and sets it to null when it unmounts.",
    "interviewTip": "Because of this timing, you should only access DOM refs inside useEffect or event handlers."
  },
  "rd-07": {
    "prompt": "What is the result of the following code after clicking 'Log'?",
    "explanation": "Every time the component renders, the count increments. Since it's a ref, it persists, but it doesn't *trigger* a render itself.",
    "interviewTip": "This is a great way to track how many times a component is re-rendering for performance debugging."
  },
  "rd-08": {
    "prompt": "How do you store an interval ID in a functional component correctly?",
    "explanation": "A local variable would be reset on every render. useState would trigger a re-render when the ID is set. useRef is the perfect middle ground.",
    "interviewTip": "Always clear your intervals in the cleanup function of useEffect to avoid memory leaks."
  },
  "rd-09": {
    "prompt": "Can you use 'useRef' to store a value that isn't a DOM element?",
    "explanation": "useRef is essentially a generic container for any mutable value you want to keep between renders.",
    "interviewTip": "This is often used to store 'previousProps' for comparison logic."
  },
  "rd-10": {
    "prompt": "What is the difference between 'useRef' and 'createRef'?",
    "explanation": "In functional components, createRef would lose its value on every re-render. useRef is designed to 'hook' into React's persistent storage.",
    "interviewTip": "If you use createRef inside a function component, it will be reset every time the function runs."
  },
  "rd-11": {
    "prompt": "Identify the issue in this code:",
    "explanation": "During the first render, the DOM hasn't been created yet, so myRef.current is undefined/null. You should only access it in a useEffect or an event.",
    "interviewTip": "This is a very common 'TypeError: Cannot read property of null' bug."
  },
  "rd-12": {
    "prompt": "How do you handle multiple refs in a list generated by .map()?",
    "explanation": "You cannot call hooks inside loops. Instead, create a single ref to an array or a Map and assign each element to an index/key.",
    "interviewTip": "Pattern: `<li ref={el => (itemsRef.current[i] = el)} />` (this is called a callback ref)."
  },
  "rd-13": {
    "prompt": "What does 'useImperativeHandle' do?",
    "explanation": "Used with forwardRef, it lets you hide the raw DOM node and instead expose only specific methods (like .focus() or .scrollTo()) to the parent.",
    "interviewTip": "This is helpful for encapsulation—don't let the parent mess with the child's internals."
  },
  "rd-14": {
    "prompt": "What will be printed to the console?",
    "explanation": "Unlike state updates which are async, updates to ref.current happen instantly. The incremented value is available immediately.",
    "interviewTip": "This is a key distinction: State is for data that the UI depends on; Refs are for data the UI *doesn't* directly render."
  },
  "ri-01": {
    "prompt": "What is the primary architectural benefit of the Virtual DOM?",
    "explanation": "The Virtual DOM is a lightweight representation of the real DOM. React uses it to batch updates and minimize expensive direct DOM manipulations.",
    "interviewTip": "Use the term 'Reconciliation' when describing how React synchronizes the Virtual and Real DOMs."
  },
  "ri-02": {
    "prompt": "Which of the following best describes 'Declarative' programming in React?",
    "explanation": "In React, you declare the desired state of the UI, and React handles the actual DOM transitions. Imperative programming involves manual DOM updates.",
    "interviewTip": "Declarative code is generally easier to debug and reason about because it is more predictable."
  },
  "ri-03": {
    "prompt": "Why is React often classified as a 'Library' rather than a 'Framework'?",
    "explanation": "Unlike frameworks (like Angular), React is unopinionated. You must choose external tools for things like navigation and data fetching.",
    "interviewTip": "This flexibility allows teams to pick the 'best-in-class' tools for their specific needs."
  },
  "ri-04": {
    "prompt": "What does this JSX code actually represent after it is compiled by Babel?",
    "explanation": "JSX is 'syntactic sugar'. Babel transforms it into nested React.createElement calls, which return plain JS objects (React Elements).",
    "interviewTip": "Since React 17, the 'new JSX transform' handles this automatically without requiring 'import React' in every file."
  },
  "ri-05": {
    "prompt": "What will the following code output to the console?",
    "explanation": "React Elements are tagged with a specific Symbol ($$typeof) for security reasons, primarily to prevent XSS (Cross-Site Scripting).",
    "interviewTip": "This tag ensures that React only renders objects it has created itself."
  },
  "ri-06": {
    "prompt": "What is the 'Single Responsibility Principle' in React components?",
    "explanation": "Components should be modular and focused. If a component grows too large, it should be decomposed into smaller sub-components.",
    "interviewTip": "Small, focused components are much easier to test and reuse."
  },
  "ri-07": {
    "prompt": "What happens if you try to render the following component?",
    "explanation": "React components must return a single root node. This is because a function can only return one value (one object tree).",
    "interviewTip": "Use a Fragment (<></>) to group elements without adding a wrapper div to the DOM."
  },
  "ri-08": {
    "prompt": "In the context of the React ecosystem, what is 'Babel'?",
    "explanation": "Babel takes modern code (JSX, ES6+) and turns it into backward-compatible versions of JavaScript that all browsers can run.",
    "interviewTip": "Vite and Create React App use Babel (or alternatives like SWC) under the hood."
  },
  "ri-09": {
    "prompt": "Analyze the code below. Why won't the UI update when the user clicks?",
    "explanation": "React is not 'watching' the 'likes' variable. To trigger a UI update, you must use the 'useState' hook.",
    "interviewTip": "This is a fundamental concept: State change = Re-render."
  },
  "ri-10": {
    "prompt": "What does the 'unidirectional data flow' mean in React?",
    "explanation": "In React, children receive data from parents via props. If children need to change parent state, they use callbacks passed down as props.",
    "interviewTip": "This 'top-down' flow makes the application state much easier to predict and debug."
  },
  "ri-11": {
    "prompt": "Which of these are valid ways to render a 'Fragment' in React?",
    "explanation": "All three are valid, with <>...</> being the most concise shorthand.",
    "interviewTip": "Remember that only <React.Fragment> (the full syntax) can accept a 'key' prop."
  },
  "ri-12": {
    "prompt": "What is the result of the following 'typeof' check?",
    "explanation": "JSX elements are transpiled into plain JavaScript objects.",
    "interviewTip": "Because they are objects, you can pass them as props, store them in variables, or put them in arrays."
  },
  "ri-13": {
    "prompt": "What is the purpose of the 'ReactDOM' library?",
    "explanation": "React is platform-independent. ReactDOM is the specific 'glue' that allows React to work with web browsers.",
    "interviewTip": "React Native uses a different renderer (the native mobile UI) instead of ReactDOM."
  },
  "ri-14": {
    "prompt": "What is wrong with this return statement?",
    "explanation": "Due to Automatic Semicolon Insertion (ASI), the return is cut off. You must place the JSX on the same line or wrap it in parentheses.",
    "interviewTip": "Always wrap multi-line JSX in parentheses: return (...);"
  },
  "ri-15": {
    "prompt": "How does React distinguish between an HTML tag and a custom component in JSX?",
    "explanation": "React.createElement() uses the case of the first letter to decide if it should render a string (native HTML) or a variable (component).",
    "interviewTip": "If you define a component as 'const myHeader = ...', use it as <MyHeader /> to ensure it's recognized."
  },
  "ri-16": {
    "prompt": "What is the 'Reconciliation' algorithm?",
    "explanation": "Reconciliation is the 'diffing' process where React calculates the minimal set of changes needed to update the browser's UI.",
    "interviewTip": "React assumes that if a component type changes, the whole tree below it needs to be rebuilt."
  },
  "ri-17": {
    "prompt": "Why should components be 'pure' functions regarding their props?",
    "explanation": "A component should never modify its props. It should return the same JSX for the same set of props and state.",
    "interviewTip": "Immutability is key to React's performance optimizations (like React.memo)."
  },
  "ri-18": {
    "prompt": "Identify the dynamic part of this JSX:",
    "explanation": "Curly braces {} are the escape hatch into JavaScript, allowing you to embed dynamic values or logic.",
    "interviewTip": "You can even put complex logic like map() or ternary operators inside these braces."
  },
  "pc-01": {
    "prompt": "What is the result of the following code snippet?",
    "explanation": "Because '25' was passed as a string (with quotes), the '+' operator performs string concatenation instead of addition.",
    "interviewTip": "Always pass numbers inside curly braces, e.g., age={25}, to ensure they stay as numeric types."
  },
  "pc-02": {
    "prompt": "Which statement best describes the nature of 'props' in React?",
    "explanation": "React enforces a strict rule of immutability for props to ensure the 'One-Way Data Flow' is predictable and easy to debug.",
    "interviewTip": "Treat props as 'snapshots' of data provided by the parent."
  },
  "pc-03": {
    "prompt": "What will be rendered by the following component structure?",
    "explanation": "The 'children' prop is a special prop in React that automatically contains whatever is placed between the opening and closing tags of a component.",
    "interviewTip": "This pattern is known as 'Containment' or 'Composition'."
  },
  "pc-04": {
    "prompt": "Which of the following are valid ways to provide default values for props in a functional component?",
    "explanation": "ES6 defaults are the modern standard. .defaultProps is the legacy React way. Using the OR operator inside JSX is a quick inline fallback.",
    "interviewTip": "For functional components, the ES6 destructuring approach is generally preferred by the React team today."
  },
  "pc-05": {
    "prompt": "How does a child component 'send data back' to its parent?",
    "explanation": "Parents pass functions. Children call those functions with data as arguments. This 'Events Up' pattern maintains the unidirectional flow.",
    "interviewTip": "This is often called 'Lifting State Up' when the child triggers an update to the parent's state."
  },
  "pc-06": {
    "prompt": "What is 'Prop Drilling'?",
    "explanation": "Prop drilling makes components harder to reuse because intermediate components are forced to handle data they don't actually need.",
    "interviewTip": "Context API or State Management libraries (like Redux/Zustand) are common solutions for avoiding excessive drilling."
  },
  "pc-07": {
    "prompt": "Analyze the code. What happens when the button is clicked?",
    "explanation": "The reference to the alertMsg function is passed as a prop. When the child button is clicked, it executes that reference.",
    "interviewTip": "This demonstrates how functional props bridge communication between components."
  },
  "pc-08": {
    "prompt": "What does the spread operator (...) do in the following context?",
    "explanation": "The spread operator spreads the keys of the object into individual attributes in JSX.",
    "interviewTip": "While convenient, overusing the spread operator can make it hard to see what data a component actually depends on."
  },
  "pc-09": {
    "prompt": "What happens if you pass a prop called 'class' to a custom React component?",
    "explanation": "While 'class' is reserved for HTML elements in JSX (where you must use className), for a *custom* component, it's just a key in an object. However, it's confusing and usually avoided.",
    "interviewTip": "Stay consistent and use 'className' even for your own components to avoid confusion with native DOM elements."
  },
  "pc-10": {
    "prompt": "In the following code, what is the initial value of 'isActive' in the Child?",
    "explanation": "In JSX, if a prop is passed without a value, it defaults to boolean 'true'.",
    "interviewTip": "This is similar to HTML attributes like 'disabled' or 'required'."
  },
  "pc-11": {
    "prompt": "What is the best way to pass multiple related pieces of data (e.g., user name, email, avatar)?",
    "explanation": "Passing a single object makes the component API cleaner and easier to update, especially if the data structure comes directly from an API.",
    "interviewTip": "If the component only needs one small field from the object, passing individual props might be better for performance and decoupling."
  },
  "pc-12": {
    "prompt": "Can you pass another React component as a prop to a component?",
    "explanation": "This is a powerful pattern for 'Slots'. It allows you to inject UI components into specific parts of a layout.",
    "interviewTip": "This is often preferred over deep nesting or complex conditional logic within the component."
  },
  "pc-13": {
    "prompt": "What will log to the console?",
    "explanation": "React 'freezes' the props object. Attempting to mutate it will throw an error or fail silently, depending on the environment.",
    "interviewTip": "If you need to change data, that data should be 'State', not 'Props'."
  },
  "pc-14": {
    "prompt": "Which of the following data types can be passed as props in React?",
    "explanation": "Props are just JavaScript. Anything that can be assigned to a variable in JS can be passed as a prop.",
    "interviewTip": "This flexibility is why React is so composable."
  },
  "pc-15": {
    "prompt": "What is the result of the logical expression in this prop assignment?",
    "explanation": "Curly braces allow you to put any JS expression. The result of the expression (true/false) is what is passed as the prop value.",
    "interviewTip": "This is a clean way to handle UI states directly in the template."
  },
  "pc-16": {
    "prompt": "How do you access the value of a prop in a functional component?",
    "explanation": "Functional components receive 'props' as their first parameter. You can either use props.name or destructure it immediately.",
    "interviewTip": "Destructuring is the standard: const MyComponent = ({ name }) => { ... }"
  },
  "pc-17": {
    "prompt": "What is the 'Prop-Types' library used for?",
    "explanation": "Prop-Types lets you declare the expected type (string, number, etc.) for each prop. React will show a warning in the console if the wrong type is passed.",
    "interviewTip": "While TypeScript has largely replaced Prop-Types in modern projects, it's still widely used in many existing codebases."
  },
  "po-01": {
    "prompt": "What is the primary purpose of 'React.lazy' and 'Suspense'?",
    "explanation": "React.lazy allows you to render a dynamic import as a regular component. Suspense provides a fallback UI (like a spinner) while that component is loading.",
    "interviewTip": "This reduces the initial bundle size, which improves the 'Time to Interactive' metric."
  },
  "po-02": {
    "prompt": "Analyze the code. What happens to 'HugeComponent' when the app first loads?",
    "explanation": "By using dynamic import(), the build tool (like Webpack or Vite) creates a separate chunk for this component that is fetched over the network only when needed.",
    "interviewTip": "Lazy loading is best used for components that aren't immediately visible, like Modals or separate Routes."
  },
  "po-03": {
    "prompt": "Which of these are effective ways to identify performance bottlenecks in a React app?",
    "explanation": "The Profiler shows which components rendered and why. 'Highlight updates' gives visual feedback on re-renders, and the Network tab helps identify bloated code.",
    "interviewTip": "The Profiler's 'Flamegraph' helps pinpoint exactly which component in a deep tree is causing a lag."
  },
  "po-04": {
    "prompt": "What is 'Windowing' (or Virtualization) used for?",
    "explanation": "If you have 10,000 items, rendering them all creates 10,000+ DOM nodes, which slows the browser. Windowing keeps the DOM small (e.g., only 20 nodes).",
    "interviewTip": "Mention libraries like 'react-window' or 'react-virtualized' as the industry standard for this."
  },
  "po-05": {
    "prompt": "What happens to the performance if you define a component inside another component's body?",
    "explanation": "Because the component function is recreated, React sees it as a completely new type every time. This destroys all state of the child and forces a full remount.",
    "interviewTip": "Always define your components outside the main function or in separate files."
  },
  "po-06": {
    "prompt": "What is 'Throttling' and 'Debouncing' in the context of React events?",
    "explanation": "Debouncing waits for a pause in activity (e.g., typing), while Throttling limits calls to once every X milliseconds (e.g., scrolling).",
    "interviewTip": "Use 'lodash.debounce' or similar utilities to prevent 100 API calls as a user types a single word."
  },
  "po-07": {
    "prompt": "How does 'Transition API' (useTransition) help with performance in React 18+?",
    "explanation": "startTransition tells React that an update (like filtering a massive list) can be interrupted by more urgent tasks like typing or clicking.",
    "interviewTip": "Use 'useTransition' to prevent the UI from 'freezing' during heavy rendering tasks."
  },
  "po-08": {
    "prompt": "What is the benefit of moving state down to a child component?",
    "explanation": "This is called 'Localizing State'. If only the Modal needs to know if it's open, keep that state there to avoid rendering the whole App whenever it toggles.",
    "interviewTip": "Before using useMemo, always check if you can simply restructure your component tree to avoid re-renders."
  },
  "po-09": {
    "prompt": "Why is 'index' as a key bad for performance in a dynamic list?",
    "explanation": "If the list reorders, the item at index 0 changes, but the key '0' remains. React thinks the content changed rather than the item moving.",
    "interviewTip": "Stable keys (like IDs) allow React to simply 'move' DOM nodes instead of re-creating them."
  },
  "po-10": {
    "prompt": "What does the 'useDeferredValue' hook do?",
    "explanation": "Similar to useTransition, but for values. It gives you a 'deferred' version of a value that 'lags behind' the urgent update, keeping the UI smooth.",
    "interviewTip": "Perfect for a search input where the input updates instantly, but the results list updates slightly later."
  },
  "po-11": {
    "prompt": "Which of these patterns can lead to memory leaks in React?",
    "explanation": "When a component unmounts, global things like timers and event listeners stay in memory unless you manually stop them.",
    "interviewTip": "Always use the return function in useEffect to clean up your mess!"
  },
  "po-12": {
    "prompt": "What is the result of using 'inline functions' as props for a component wrapped in 'React.memo'?",
    "explanation": "React.memo uses shallow comparison. `() => {} !== () => {}`, so the memoization check fails.",
    "interviewTip": "Pair 'React.memo' with 'useCallback' on the parent function to make the optimization work."
  },
  "mem-01": {
    "prompt": "What is the primary difference between useMemo and useCallback?",
    "explanation": "useMemo executes a function and remembers the returned value. useCallback returns the function itself so its reference remains stable between renders.",
    "interviewTip": "Remember: useCallback(fn, deps) is essentially the same as useMemo(() => fn, deps)."
  },
  "mem-02": {
    "prompt": "Analyze the code. How many times will 'Calculating...' be logged if the component re-renders but 'count' stays the same?",
    "explanation": "Because 'count' hasn't changed, useMemo returns the cached value and skips executing the function again.",
    "interviewTip": "This is perfect for avoiding 'heavy' logic (like sorting large arrays) on every render."
  },
  "mem-03": {
    "prompt": "What does React.memo do when wrapped around a component?",
    "explanation": "React.memo is a Higher Order Component that performs a shallow comparison of props. If they are the same as last time, React skips rendering that component.",
    "interviewTip": "By default, React re-renders all children when a parent renders. React.memo 'opts-out' of this behavior."
  },
  "mem-04": {
    "prompt": "Which of these scenarios can break memoization (causing an unexpected re-render)?",
    "explanation": "In JS, `{} !== {}` and `()=>{} !== ()=>{} `. These create new references on every render, which makes React.memo think the props have changed.",
    "interviewTip": "To fix this, use useMemo for the object and useCallback for the function."
  },
  "mem-05": {
    "prompt": "What is 'Referential Equality' in the context of React optimization?",
    "explanation": "React uses shallow equality (Object.is) for props and dependency arrays. If the reference changes, the optimization fails.",
    "interviewTip": "This is why stable references (via hooks) are the foundation of React performance."
  },
  "mem-06": {
    "prompt": "Why is the following 'useCallback' problematic?",
    "explanation": "The empty dependency array tells React to never update the function reference. It 'remembers' the version of 'text' from render #1 forever.",
    "interviewTip": "Always include every reactive value used inside the hook in the dependency array."
  },
  "mem-07": {
    "prompt": "When should you NOT use useMemo or useCallback?",
    "explanation": "Memoization has its own cost (memory and comparison time). If the logic is cheap, the overhead of the hook might be greater than the benefit.",
    "interviewTip": "Don't optimize prematurely. Profile your app first to see where the actual bottlenecks are."
  },
  "mem-08": {
    "prompt": "Identify the output of this component after a re-render:",
    "explanation": "Even though the values are the same, `[1,2,3] !== [1,2,3]` in JS. A new reference triggers the re-render.",
    "interviewTip": "Move static data outside the component or wrap it in useMemo."
  },
  "mem-09": {
    "prompt": "What does the second argument of React.memo(Component, arePropsEqual) allow you to do?",
    "explanation": "By default, React.memo does a shallow check. You can provide a custom function to do a deep check or ignore specific props.",
    "interviewTip": "Be careful: deep comparisons can be slower than the actual re-render!"
  },
  "mem-10": {
    "prompt": "Which of these hooks depend on referential stability to work effectively?",
    "explanation": "useEffect re-runs if a reference changes. Context consumers re-render if the provider value (often an object) is a new reference.",
    "interviewTip": "Referential stability is the 'bridge' that makes other hooks efficient."
  },
  "mem-11": {
    "prompt": "How do you memoize an expensive calculation that depends on 'a' and 'b'?",
    "explanation": "useMemo takes a 'create' function that returns the value you want to cache.",
    "interviewTip": "The function inside useMemo should be 'pure'—it shouldn't have side effects."
  },
  "mem-12": {
    "prompt": "What is the result of using a hook inside useMemo?",
    "explanation": "Hooks must be called at the top level of your component. You cannot nest hooks inside useMemo, useEffect, or any other function.",
    "interviewTip": "This follows the 'Rules of Hooks' call order requirements."
  },
  "le-01": {
    "prompt": "When does the code inside a useEffect block run by default if no dependency array is provided?",
    "explanation": "Without a dependency array, useEffect runs after every render cycle. This is usually avoided to prevent performance issues.",
    "interviewTip": "Always be intentional with your dependency array to avoid infinite loops."
  },
  "le-02": {
    "prompt": "How do you ensure a useEffect only runs once, similar to 'componentDidMount'?",
    "explanation": "An empty dependency array [] tells React that the effect doesn't depend on any values from props or state, so it never needs to re-run.",
    "interviewTip": "Even with an empty array, in React 18 'Strict Mode' development, effects might run twice to help you find cleanup bugs."
  },
  "le-03": {
    "prompt": "What is the purpose of the function returned from a useEffect hook?",
    "explanation": "The cleanup function is essential for preventing memory leaks (like intervals, event listeners, or active API subscriptions).",
    "interviewTip": "Always clean up side effects that persist beyond the component's lifecycle."
  },
  "le-04": {
    "prompt": "Which of the following are valid reasons to use the useEffect hook?",
    "explanation": "Calculating values from props should be done during render (or via useMemo). Effects are specifically for 'side effects' that touch things outside the React ecosystem.",
    "interviewTip": "If you can calculate it during render, you don't need useEffect."
  },
  "le-05": {
    "prompt": "What will happen if you update a state variable inside a useEffect without a dependency array?",
    "explanation": "The render triggers the effect, the effect updates state, the state update triggers a render, and the cycle repeats infinitely.",
    "interviewTip": "If you see your CPU fans spinning up during dev, check for a missing dependency array in a useEffect that calls a setter."
  },
  "le-06": {
    "prompt": "Analyze the dependency array below. When will this effect re-run?",
    "explanation": "React performs a shallow comparison (Object.is) on each item in the array. If any item changes between renders, the effect re-runs.",
    "interviewTip": "Be careful when passing objects or arrays in the dependency array, as new references will trigger the effect every time."
  },
  "le-07": {
    "prompt": "What is the console output when the component unmounts?",
    "explanation": "The cleanup function (B) runs only when the component is being removed from the DOM if the dependency array is empty.",
    "interviewTip": "If the array had dependencies, 'B' would run before every re-run of 'A' AND at unmount."
  },
  "le-08": {
    "prompt": "How does React handle multiple useEffect hooks in a single component?",
    "explanation": "React relies on the order of Hook calls to maintain state. They are executed sequentially after the render is committed to the screen.",
    "interviewTip": "Use multiple effects to separate unrelated logic (e.g., one for data fetching, one for an event listener)."
  },
  "le-09": {
    "prompt": "Why is it important to include all reactive values (props, state) used inside the effect in the dependency array?",
    "explanation": "If a value is used inside but not listed in the dependencies, the effect function 'remembers' the version of that value from when it was last created, leading to bugs.",
    "interviewTip": "The 'eslint-plugin-react-hooks' is your best friend for catching missing dependencies automatically."
  },
  "le-10": {
    "prompt": "What is the 'Effect Lifecycle' order when dependencies change?",
    "explanation": "React cleans up the previous render's effect before applying the new one to ensure no stale side effects overlap.",
    "interviewTip": "This is why cleaning up a subscription before starting a new one prevents 'duplicate listener' bugs."
  },
  "le-11": {
    "prompt": "What happens if you return a string instead of a function from useEffect?",
    "explanation": "useEffect expects the return value to be either a function (for cleanup) or nothing (undefined). Returning anything else is a mistake.",
    "interviewTip": "Returning an async function is a common mistake because async functions return a Promise, not a cleanup function."
  },
  "le-12": {
    "prompt": "Which hook is used for side effects that need to happen synchronously *before* the browser paints the screen?",
    "explanation": "useLayoutEffect runs at the same time as the old 'componentDidMount'—after DOM mutations but before the user sees them. Useful for measuring DOM elements.",
    "interviewTip": "Prefer useEffect for 99% of cases to avoid blocking visual updates."
  },
  "le-13": {
    "prompt": "How should you handle an async function inside useEffect?",
    "explanation": "You cannot make the effect callback itself async because it would return a Promise instead of a cleanup function. You must define the async function inside the effect.",
    "interviewTip": "Defining it inside the effect also makes it easier to handle cleanup (like AbortController)."
  },
  "le-14": {
    "prompt": "What is the 'Mounting' phase in React?",
    "explanation": "Mounting is the start of a component's life in the DOM.",
    "interviewTip": "useEffect with [] is the most common way to handle 'onMount' logic."
  },
  "le-15": {
    "prompt": "Which of these will trigger a re-run of an effect with [data] as a dependency?",
    "explanation": "React uses shallow equality. A new object literal `{}` is always a different reference, even if the properties look the same.",
    "interviewTip": "This is why we spread: `setData({...data})`."
  },
  "le-16": {
    "prompt": "What is the console output when the dependency 'count' changes from 1 to 2?",
    "explanation": "When dependencies change, React first runs the cleanup of the previous effect, then the new effect.",
    "interviewTip": "This ensures the 'old' world is cleaned up before the 'new' world starts."
  },
  "le-17": {
    "prompt": "Is it safe to omit a function from the dependency array if it's defined inside the component?",
    "explanation": "In JS, `function a(){}` !== `function a(){}` if they are created in different render cycles. Use `useCallback` to keep function references stable.",
    "interviewTip": "Moving the function *inside* the useEffect is often the simplest fix."
  },
  "jc-01": {
    "prompt": "What happens if you define a React component with a lowercase first letter (e.g., function myHeader())?",
    "explanation": "React uses capitalization to distinguish between native HTML tags (strings) and custom components (functions/classes).",
    "interviewTip": "Always follow PascalCase for component names (e.g., MyComponent)."
  },
  "jc-02": {
    "prompt": "What is the result of the following component code?",
    "explanation": "JSX must have exactly one root element. You cannot return multiple adjacent tags without a wrapper.",
    "interviewTip": "You can fix this using a <div> or a Fragment (<>...</>)."
  },
  "jc-03": {
    "prompt": "How do you pass a JavaScript variable as an attribute in JSX?",
    "explanation": "To pass a variable as a prop or attribute, you must use curly braces without quotes.",
    "interviewTip": "If you put quotes around the braces, React will treat the whole thing as a literal string."
  },
  "jc-04": {
    "prompt": "What will be rendered by the following code snippet?",
    "explanation": "React does not render booleans, null, or undefined. Since isAdmin is false, the && operator stops, and nothing is displayed.",
    "interviewTip": "Be careful with 0; unlike false, React *will* render the number 0."
  },
  "jc-05": {
    "prompt": "What is the purpose of using React Fragments (<> ... </>)?",
    "explanation": "Fragments allow you to satisfy the 'single root' rule without bloating the HTML with unnecessary <div> tags.",
    "interviewTip": "Fragments are especially useful when working with CSS Flexbox or Grid where extra parent divs can break the layout."
  },
  "jc-06": {
    "prompt": "Which of these are valid ways to apply inline styles in JSX?",
    "explanation": "Inline styles must be objects. You can use camelCase (fontSize) or quoted kebab-case ('background-color').",
    "interviewTip": "The double curly braces {{ }} represent a JS object inside a JSX expression."
  },
  "jc-07": {
    "prompt": "How do you write a comment inside a JSX template?",
    "explanation": "JSX comments must be wrapped in curly braces and use the JavaScript multi-line comment syntax.",
    "interviewTip": "Single line // comments inside braces can sometimes accidentally comment out the closing brace."
  },
  "jc-08": {
    "prompt": "What is the output of this component?",
    "explanation": "React can render arrays directly. It simply concatenates the elements in the UI.",
    "interviewTip": "Usually, you'll use .map() to wrap each item in a tag like <li> to avoid this joined-text behavior."
  },
  "jc-09": {
    "prompt": "In JSX, which attribute is used instead of the standard HTML 'for' for labels?",
    "explanation": "'for' is a reserved keyword in JavaScript (used in loops), so JSX uses 'htmlFor' to avoid conflicts.",
    "interviewTip": "This is the same reason why 'class' becomes 'className'."
  },
  "jc-10": {
    "prompt": "What does the following return?",
    "explanation": "Expressions inside curly braces are evaluated and the result is rendered.",
    "interviewTip": "You can perform any JS calculation or call functions inside these braces."
  },
  "jc-11": {
    "prompt": "Why must you close all tags in JSX, even self-closing ones like <img> or <br>?",
    "explanation": "JSX is not HTML; it is a syntax extension that follows XML rules where every tag must be closed (e.g., <br />).",
    "interviewTip": "This is a common 'gotcha' for developers moving from plain HTML to React."
  },
  "jc-12": {
    "prompt": "Which of the following are valid ways to render 'nothing' from a component?",
    "explanation": "Returning null, false, or undefined tells React not to render any UI. An empty div renders an actual DOM node.",
    "interviewTip": "return null is the industry standard for 'conditionally hiding' a component."
  },
  "jc-13": {
    "prompt": "What is the result of the console log in this component?",
    "explanation": "JSX tags are transformed into objects that describe the UI. This is what 'console.log' will show.",
    "interviewTip": "These objects are the building blocks of the Virtual DOM."
  },
  "jc-14": {
    "prompt": "How do you render a string that contains HTML without escaping it?",
    "explanation": "React escapes all strings by default for security. 'dangerouslySetInnerHTML' is the intentional way to render raw HTML.",
    "interviewTip": "The name is a reminder that this can expose your app to XSS attacks if the string comes from an untrusted source."
  },
  "jc-15": {
    "prompt": "What is wrong with the following component?",
    "explanation": "JavaScript stops executing a function after the 'return' keyword. The code below it is dead code.",
    "interviewTip": "Always wrap multi-line UI in parentheses to ensure the whole block is returned."
  },
  "jc-16": {
    "prompt": "Can you use a JavaScript 'if' statement directly inside a JSX block?",
    "explanation": "Braces {} only accept expressions. Statements like 'if', 'for', and 'switch' are not allowed inside JSX.",
    "interviewTip": "This is why ternaries (condition ? a : b) are so popular in React."
  },
  "jc-17": {
    "prompt": "What does the 'typeof' check return for a Fragment?",
    "explanation": "React Fragments (and other built-in types like Suspense or Profiler) are internal React Symbols.",
    "interviewTip": "Fragments are special 'empty' types that the renderer knows how to handle without a DOM node."
  },
  "jc-18": {
    "prompt": "Which of these is the correct way to pass a boolean prop 'isActive' as true?",
    "explanation": "Passing a prop name alone defaults to true. {true} is also explicit and correct.",
    "interviewTip": "Most developers prefer the shorthand <Tab isActive /> for boolean flags."
  },
  "dp-01": {
    "prompt": "What is the primary goal of the 'Compound Components' pattern?",
    "explanation": "Compound components (like <Select> and <Option>) share state behind the scenes, giving the consumer more control over the rendered structure while keeping logic encapsulated.",
    "interviewTip": "Think of the HTML <select> and <option> tags. They work together as a unit; that is a native compound component."
  },
  "dp-02": {
    "prompt": "In the Compound Component pattern, how is the internal state usually shared among children?",
    "explanation": "While cloneElement was used in the past, React Context is now the preferred way to share state within a compound component group.",
    "interviewTip": "Mention that Context is safer and more flexible than cloneElement because it works even if children are wrapped in other divs."
  },
  "dp-03": {
    "prompt": "What is a 'Higher-Order Component' (HOC)?",
    "explanation": "HOCs are a pattern for reusing component logic. They act as wrappers that 'enhance' the original component with new props or behaviors.",
    "interviewTip": "While HOCs are less common since Hooks were introduced, they are still used for Cross-Cutting Concerns like Authentication or Logging."
  },
  "dp-04": {
    "prompt": "Analyze the 'Render Prop' pattern. What is being passed to the Child?",
    "explanation": "A render prop is a prop that is a function which a component uses to know what to render. It 'shares' its internal state with the function.",
    "interviewTip": "Render props are highly flexible but can sometimes lead to 'wrapper hell' if over-nested."
  },
  "dp-05": {
    "prompt": "Which of the following are characteristics of a 'Controlled Component'?",
    "explanation": "Controlled components allow React to be the 'Single Source of Truth'. Uncontrolled components rely on the DOM (and Refs) to hold the data.",
    "interviewTip": "Use controlled components for almost everything unless you have a specific performance reason to use a Ref."
  },
  "dp-06": {
    "prompt": "How do you implement the 'Controlled Props' pattern to allow a user to 'take over' a component's internal state?",
    "explanation": "This pattern allows a component to manage its own state by default, but gives the parent the option to 'control' it if a prop is provided.",
    "interviewTip": "This is a common pattern in advanced UI libraries like Downshift or Material UI."
  },
  "dp-07": {
    "prompt": "What is the 'Container/Presentational' pattern?",
    "explanation": "Presentational components are 'dumb' and only care about how things look. Containers are 'smart' and care about how things work (API calls, state logic).",
    "interviewTip": "Hooks have largely replaced this pattern because you can now put 'smart' logic in a custom hook instead of a wrapper component."
  },
  "dp-08": {
    "prompt": "Identify the issue when using HOCs:",
    "explanation": "Heavily nested HOCs make debugging difficult because it's unclear which HOC is passing which prop. Hooks solve this by providing a flat structure.",
    "interviewTip": "This is one of the main reasons the React community shifted from HOCs to Hooks."
  },
  "dp-09": {
    "prompt": "What does the 'Slot' pattern achieve in React?",
    "explanation": "Slots are a form of composition that allows a parent to define specific UI 'holes' that a child component fills.",
    "interviewTip": "Slots are often easier to manage than complex boolean flags within a component."
  },
  "dp-10": {
    "prompt": "How do you avoid 'prop drilling' in a deeply nested component tree using patterns?",
    "explanation": "Compound components use Context to broadcast state to all descendants, effectively ending the need for drilling.",
    "interviewTip": "Mention that this keeps the component API 'clean' as users don't see the state being passed."
  },
  "dp-11": {
    "prompt": "Which patterns are considered 'Obsolete' or 'Legacy' due to the introduction of Hooks?",
    "explanation": "Mixins are completely obsolete. HOCs and Render Props are still valid but are much less common as Hooks solve the same problems with less nesting.",
    "interviewTip": "Compound Components are still very much alive and well because they solve a different problem (UI structure/API design)."
  },
  "dp-12": {
    "prompt": "What is the 'Prop Collection' pattern?",
    "explanation": "This pattern simplifies the consumer's work by bundling accessibility, event handlers, and attributes into a single spreadable object.",
    "interviewTip": "This is widely used in 'Headless UI' libraries like Radix UI or Reach UI."
  },
  "ch-01": {
    "prompt": "What is the mandatory naming convention for custom hooks in React?",
    "explanation": "The 'use' prefix is essential because it allows React's linter to automatically check for violations of the Rules of Hooks.",
    "interviewTip": "If you don't start with 'use', React won't know it's a hook and won't be able to guarantee its call order stability."
  },
  "ch-02": {
    "prompt": "What is the primary benefit of creating a custom hook?",
    "explanation": "Custom hooks let you hide complex logic (like data fetching, form handling, or event listeners) behind a simple API that multiple components can share.",
    "interviewTip": "Think of custom hooks as 'Logic Composition' rather than 'UI Composition'."
  },
  "ch-03": {
    "prompt": "If two components use the same custom hook, do they share the same state?",
    "explanation": "Hooks are a way to reuse *logic*, not *data*. Every time you call a hook, all state and effects inside it are isolated to that specific caller.",
    "interviewTip": "If you need to share data, you still need Context or a state management library like Redux."
  },
  "ch-04": {
    "prompt": "What can you call inside a custom hook?",
    "explanation": "Custom hooks are essentially regular functions that have 'superpowers'—they can use any other React hooks inside them.",
    "interviewTip": "This is why custom hooks are so powerful; they are the glue that combines multiple built-in hooks into a single feature."
  },
  "ch-05": {
    "prompt": "Analyze the custom hook below. What is its return type?",
    "explanation": "Custom hooks can return anything (arrays, objects, or even single values). Returning an array is a common pattern modeled after useState.",
    "interviewTip": "Returning an array is great for renaming values during destructuring. Returning an object is better if there are many return values."
  },
  "ch-06": {
    "prompt": "Which of the following are valid Rules of Hooks that apply to custom hooks?",
    "explanation": "Custom hooks are bound by the same rules as built-in hooks: they must be called at the top level and must not be conditional.",
    "interviewTip": "The call order must remain identical between every render for React to track state correctly."
  },
  "ch-07": {
    "prompt": "Identify the potential issue in this custom hook:",
    "explanation": "Side effects like event listeners must be inside a useEffect with a cleanup function to avoid adding thousands of listeners as the component re-renders.",
    "interviewTip": "Always pair 'add' with 'remove' in a cleanup function."
  },
  "ch-08": {
    "prompt": "How do you pass parameters to a custom hook?",
    "explanation": "Since custom hooks are just functions, you can pass any data (strings, objects, or even other functions) as arguments.",
    "interviewTip": "If the arguments change, make sure the hooks *inside* your custom hook (like useEffect) react to those changes by adding them to dependency arrays."
  },
  "ch-09": {
    "prompt": "What is the main advantage of the following pattern?",
    "explanation": "This is a classic 'useForm' hook. Instead of every component writing its own handleChange logic, they just import this hook.",
    "interviewTip": "Standardizing common UI logic like forms or modals into custom hooks is a sign of a senior-level codebase."
  },
  "ch-10": {
    "prompt": "Can a custom hook be called from inside another custom hook?",
    "explanation": "Hooks are composable. For example, a `useAuthenticatedFetch` hook might call a `useAuth` hook and a `useFetch` hook internally.",
    "interviewTip": "Composition is the 'secret sauce' of React's flexibility."
  },
  "ch-11": {
    "prompt": "Why should you use 'useCallback' or 'useMemo' inside a custom hook that returns functions or objects?",
    "explanation": "If your hook returns a function like `() => {}`, that function is a new reference on every render. If that function is a dependency in a component's useEffect, the component will enter an infinite loop.",
    "interviewTip": "Providing 'referential stability' is a key responsibility of a well-written custom hook."
  },
  "ch-12": {
    "prompt": "Which of these are good candidates for a custom hook?",
    "explanation": "Simple math is a regular function. Anything that requires 'State' or 'Lifecycle' (like online status, pagination, or IntersectionObserver) should be a custom hook.",
    "interviewTip": "If it doesn't use any React hooks (useState, useEffect, etc.), it probably shouldn't be a hook—just a regular utility function."
  },
  "ch-13": {
    "prompt": "What happens if you use a custom hook inside an 'if' statement?",
    "explanation": "React maps state to hooks based on their *index* in the call order. If you skip a hook because of a condition, the internal indexes shift, and the wrong state is assigned to the wrong hooks.",
    "interviewTip": "Remember: The order of hooks must be identical on every single render."
  },
  "ca-09": {
    "prompt": "How do you provide a function through Context to allow children to update the state?",
    "explanation": "Context values can be any JS type. Passing an object containing both the state and its setter is the most common pattern for global state management.",
    "interviewTip": "Always ensure the object passed to 'value' is memoized if it's defined inside a component, otherwise it creates a new reference on every render."
  },
  "ca-10": {
    "prompt": "Identify the error in this Consumer logic:",
    "explanation": "The context object itself is just a descriptor. You must use the 'useContext' hook to 'pull' the value out of that context.",
    "interviewTip": "Think of the Context object as a 'Key' and 'useContext' as the 'Lock' that opens it."
  },
  "ca-11": {
    "prompt": "Which of these are valid ways to avoid performance issues with Context?",
    "explanation": "Splitting and memoization are the two most effective strategies. Moving a provider higher actually increases the number of potential components affected by a render.",
    "interviewTip": "If 'React.memo' doesn't help, the bottleneck is likely the context value itself changing too often."
  },
  "ca-12": {
    "prompt": "What happens if a component calls 'useContext' but its parent Provider is later unmounted?",
    "explanation": "When the Provider is gone, the hook searches up the tree and, finding nothing, falls back to the original default value.",
    "interviewTip": "This ensures the component stays 'safe' even during dynamic layout changes."
  },
  "cr-01": {
    "prompt": "What will be rendered if 'isLoaded' is false?",
    "explanation": "The ternary operator is the most common way to perform 'either-or' conditional rendering in JSX.",
    "interviewTip": "Ternaries are preferred over 'if-else' statements inside JSX because they are expressions."
  },
  "cr-02": {
    "prompt": "What is a potential 'gotcha' when using the && operator with a numeric 0?",
    "explanation": "In JS, '0 && anything' evaluates to 0. React does not render booleans, but it *does* render the number 0.",
    "interviewTip": "To avoid this, use a boolean check: `{count > 0 && <p>Items found</p>}` or a ternary."
  },
  "cr-03": {
    "prompt": "How do you render nothing at all based on a condition?",
    "explanation": "Returning 'null' is the standard way to tell React to render no output for a component or part of the UI.",
    "interviewTip": "Returning null still triggers the component's lifecycle hooks; it just doesn't produce DOM nodes."
  },
  "cr-04": {
    "prompt": "Which of these are valid ways to conditionally render JSX?",
    "explanation": "React doesn't have directives like v-if. It relies on standard JS logic.",
    "interviewTip": "For complex conditions, using a helper function or a variable outside the return statement is often cleaner."
  },
  "cr-05": {
    "prompt": "What is the result of the following component?",
    "explanation": "This is called an 'Early Return'. It prevents the rest of the component logic from executing if a condition isn't met.",
    "interviewTip": "Early returns are excellent for handling loading states or missing data."
  },
  "cr-06": {
    "prompt": "What is the 'Logical OR' (||) operator used for in conditional rendering?",
    "explanation": "The || operator is perfect for displaying default text or components when data is missing.",
    "interviewTip": "Remember that if userName is an empty string \"\", it will also trigger the fallback."
  },
  "cr-07": {
    "prompt": "Identify the output of this code:",
    "explanation": "Ternary operators can be used inside attribute values to conditionally apply CSS classes or other props.",
    "interviewTip": "This is the primary way to handle dynamic styling in basic React."
  },
  "cr-08": {
    "prompt": "Why can't you use a 'for' loop or 'if' statement directly inside the JSX return?",
    "explanation": "JSX is transformed into React.createElement() calls. Arguments to a function must be expressions (values), not statements.",
    "interviewTip": "Expressions evaluate to a value (like 2+2); statements perform an action (like if/for)."
  },
  "cr-09": {
    "prompt": "What will be rendered here?",
    "explanation": "Since items.length is 0, the expression evaluates to 0. However, in this specific case, 0 && ... is false, and React renders nothing (unless it's just the number 0 directly).",
    "interviewTip": "Always ensure the left side of your && is a true boolean if you want to be safe."
  },
  "cr-10": {
    "prompt": "How do you handle 'Loading', 'Error', and 'Data' states in a single component return?",
    "explanation": "While nested ternaries work, they are hard to read. Early returns for error and loading states are much cleaner.",
    "interviewTip": "Pattern: `if (loading) return <Spinner />; if (error) return <Error />; return <Data />;`"
  },
  "cr-11": {
    "prompt": "What is the purpose of the 'Nullish Coalescing' operator (??) in React?",
    "explanation": "This is safer than || when 0 is a valid value you want to display.",
    "interviewTip": "Use ?? when you want to treat 0 and empty strings as 'data'."
  },
  "cr-12": {
    "prompt": "Analyze the output:",
    "explanation": "While React ignores raw booleans, converting them to a string will force them to render.",
    "interviewTip": "This is a useful debugging trick to see boolean states in the UI."
  },
  "cr-13": {
    "prompt": "How do you conditionally apply multiple props using the spread operator?",
    "explanation": "Spreading an empty object {} adds no props, while spreading an object with keys applies them dynamically.",
    "interviewTip": "This is a clean way to handle 'Admin-only' or 'Special' props."
  },
  "cr-14": {
    "prompt": "What happens when a component unmounts because it is no longer being rendered conditionally?",
    "explanation": "Unmounting is a full destruction of the component instance.",
    "interviewTip": "If you need to keep state alive, 'lift' it to the parent or hide the component with CSS (display: none) instead."
  },
  "cr-15": {
    "prompt": "Which component is better for performance when toggling frequently?",
    "explanation": "Conditional rendering (&&) destroys/re-creates the component. CSS 'display' keeps it in the DOM, making toggles faster at the cost of initial memory.",
    "interviewTip": "Use CSS hiding for components with expensive 'mount' logic that flip often."
  },
  "rtk-01": {
    "prompt": "What is the primary purpose of a 'Slice' in Redux Toolkit?",
    "explanation": "createSlice automatically generates action creators and action types based on the reducers you provide, drastically reducing boilerplate code.",
    "interviewTip": "In legacy Redux, you had to write actions and reducers in separate files. Slices make it modular and concise."
  },
  "rtk-02": {
    "prompt": "How does Redux Toolkit allow you to 'mutate' state safely inside a reducer?",
    "explanation": "RTK uses Immer, which tracks changes to a 'draft' state and produces a brand new immutable state object for you.",
    "interviewTip": "This is a key benefit: you get the simplicity of mutation syntax with the safety of immutability."
  },
  "rtk-03": {
    "prompt": "Which hook is used to extract data from the Redux store state?",
    "explanation": "useSelector takes a selector function that receives the entire store state and returns the specific part you need.",
    "interviewTip": "useSelector also creates a subscription to the store and re-renders the component when the selected data changes."
  },
  "rtk-04": {
    "prompt": "What is the correct way to trigger a state change from a component?",
    "explanation": "The useDispatch hook returns the dispatch function from the Redux store. You call it with an action object to trigger a reducer.",
    "interviewTip": "Dispatching is the *only* way to trigger a state change in Redux, following the 'Single Source of Truth' principle."
  },
  "rtk-05": {
    "prompt": "What are the core principles of Redux?",
    "explanation": "Redux relies on predictability. The global state is stored in a single tree, and reducers must be pure functions that take (state, action) and return a new state.",
    "interviewTip": "Predictability makes features like 'Time Travel Debugging' possible."
  },
  "rtk-06": {
    "prompt": "What is 'createAsyncThunk' used for in Redux Toolkit?",
    "explanation": "createAsyncThunk generates promise lifecycle action types (pending, fulfilled, rejected) and handles the dispatching logic for you.",
    "interviewTip": "Handle the results of a thunk in the 'extraReducers' section of your slice."
  },
  "rtk-07": {
    "prompt": "Where do you combine all your slices to create the global store?",
    "explanation": "configureStore simplifies store setup. It automatically adds the Redux DevTools extension and the 'thunk' middleware.",
    "interviewTip": "configureStore is the RTK replacement for the legacy createStore function."
  },
  "rtk-08": {
    "prompt": "What happens if a reducer is not a 'pure function' (e.g., it uses Math.random() or calls an API)?",
    "explanation": "Reducers must be deterministic. Given the same state and action, they must always return the same result. Side effects belong in thunks or middleware.",
    "interviewTip": "Reducers = 'Logic/Calculation'; Thunks = 'Side Effects/Asynchronous work'."
  },
  "rtk-09": {
    "prompt": "How do you access the 'payload' of an action inside a reducer?",
    "explanation": "In Redux Toolkit, the data sent with an action is automatically placed in the 'payload' property of the action object.",
    "interviewTip": "Example call: dispatch(incrementByAmount(10)) results in action.payload being 10."
  },
  "rtk-10": {
    "prompt": "What is the purpose of the <Provider> component in Redux?",
    "explanation": "Just like Context API, the Redux Provider uses React's context mechanism to pass the store down to hooks like useSelector.",
    "interviewTip": "Usually, you wrap the <Provider> around the <App /> in your main entry file (index.js)."
  },
  "rtk-11": {
    "prompt": "Which of these are benefits of using Redux DevTools?",
    "explanation": "DevTools provides a visual dashboard to see exactly how actions change the state, making debugging much easier.",
    "interviewTip": "It’s one of the strongest reasons to choose Redux for complex apps."
  },
  "rtk-12": {
    "prompt": "Identify the error in this selector usage:",
    "explanation": "Always consider the initial state. If the data hasn't loaded yet, accessing an index of an empty/undefined list will throw an error.",
    "interviewTip": "Use optional chaining: state.users?.[0]."
  },
  "js-scope-01": {
    "prompt": "What will be logged?",
    "explanation": "`var a` is hoisted inside the function, shadowing the outer `a`.",
    "interviewTip": "Classic hoisting + shadowing question."
  },
  "js-scope-02": {
    "prompt": "What is block scope?",
    "explanation": "`let` and `const` are block-scoped.",
    "interviewTip": "Contrast with `var`."
  },
  "js-scope-03": {
    "prompt": "What will be logged?",
    "explanation": "`x` exists only inside the block.",
    "interviewTip": "Block scope enforcement."
  },
  "js-scope-04": {
    "prompt": "What happens?",
    "explanation": "`let` is hoisted but in the Temporal Dead Zone.",
    "interviewTip": "TDZ is often misunderstood."
  },
  "js-scope-05": {
    "prompt": "What is the scope of a variable declared with var?",
    "explanation": "`var` ignores block scope.",
    "interviewTip": "Reason why `let` was introduced."
  },
  "js-scope-06": {
    "prompt": "What will be logged?",
    "explanation": "`var` leaks out of the loop.",
    "interviewTip": "Loop scoping bug."
  },
  "js-scope-07": {
    "prompt": "What will be logged?",
    "explanation": "`let` is block-scoped.",
    "interviewTip": "Per-iteration scope."
  },
  "js-scope-08": {
    "prompt": "What is lexical scope?",
    "explanation": "Scope is fixed at definition time.",
    "interviewTip": "JS is lexically scoped."
  },
  "js-scope-09": {
    "prompt": "What will be logged?",
    "explanation": "`foo` closes over the outer lexical scope.",
    "interviewTip": "Lexical vs dynamic scope."
  },
  "js-scope-10": {
    "prompt": "What is a closure?",
    "explanation": "Closures preserve access to outer variables.",
    "interviewTip": "One of the most important JS concepts."
  },
  "js-scope-11": {
    "prompt": "What will be logged?",
    "explanation": "Closure keeps `a` alive.",
    "interviewTip": "Memory retention."
  },
  "js-scope-12": {
    "prompt": "What causes a global variable leak?",
    "explanation": "Without strict mode, undeclared vars become global.",
    "interviewTip": "Always use strict mode or modules."
  },
  "js-scope-13": {
    "prompt": "What will be logged?",
    "explanation": "Strict mode forbids implicit globals.",
    "interviewTip": "Why strict mode matters."
  },
  "js-scope-14": {
    "prompt": "What is the scope of variables in ES modules?",
    "explanation": "Each module has its own top-level scope.",
    "interviewTip": "Modules prevent global pollution."
  },
  "js-scope-15": {
    "prompt": "What will be logged?",
    "explanation": "Inner `a` is block-scoped.",
    "interviewTip": "Shadowing example."
  },
  "js-scope-16": {
    "prompt": "What is variable shadowing?",
    "explanation": "Inner variable hides outer one.",
    "interviewTip": "Can reduce readability."
  },
  "js-scope-17": {
    "prompt": "What will be logged?",
    "explanation": "`const` works like `let` in scope rules.",
    "interviewTip": "const ≠ immutable binding."
  },
  "js-scope-18": {
    "prompt": "What does the scope chain represent?",
    "explanation": "Scope chain resolves identifiers.",
    "interviewTip": "Not the same as prototype chain."
  },
  "js-scope-19": {
    "prompt": "What will be logged?",
    "explanation": "Hoisting inside IIFE.",
    "interviewTip": "Very common interview trap."
  },
  "js-scope-20": {
    "prompt": "What creates a new scope?",
    "explanation": "All listed constructs create scope.",
    "interviewTip": "Be precise when explaining."
  },
  "js-scope-21": {
    "prompt": "Why are closures useful?",
    "explanation": "Closures enable private state.",
    "interviewTip": "Connect to real-world examples."
  },
  "js-scope-22": {
    "prompt": "What will be logged?",
    "explanation": "Closures reference variables, not values.",
    "interviewTip": "Important closure nuance."
  },
  "js-scope-23": {
    "prompt": "What is the Temporal Dead Zone?",
    "explanation": "Access before initialization throws error.",
    "interviewTip": "Key difference from var."
  },
  "js-scope-24": {
    "prompt": "What happens if you redeclare let in same scope?",
    "explanation": "`let` cannot be redeclared in same scope.",
    "interviewTip": "Helps prevent bugs."
  },
  "js-scope-25": {
    "prompt": "Why is global scope dangerous?",
    "explanation": "Global scope increases coupling and bugs.",
    "interviewTip": "Good architectural question."
  },
  "js-proto-01": {
    "prompt": "What is a JavaScript prototype?",
    "explanation": "Every JS object has an internal link to a prototype object.",
    "interviewTip": "JS uses prototypal inheritance, not classical."
  },
  "js-proto-02": {
    "prompt": "What does `__proto__` point to?",
    "explanation": "`__proto__` references the internal [[Prototype]].",
    "interviewTip": "Preferred API is `Object.getPrototypeOf`."
  },
  "js-proto-03": {
    "prompt": "What is `Function.prototype`?",
    "explanation": "All functions inherit from Function.prototype.",
    "interviewTip": "Functions are objects."
  },
  "js-proto-04": {
    "prompt": "What is the result?",
    "explanation": "`new` links instance to constructor's prototype.",
    "interviewTip": "`prototype` exists only on functions."
  },
  "js-proto-05": {
    "prompt": "Where are methods usually defined for all instances?",
    "explanation": "Methods on prototype are shared.",
    "interviewTip": "Memory optimization."
  },
  "js-proto-06": {
    "prompt": "What will be logged?",
    "explanation": "Plain objects inherit from Object.prototype.",
    "interviewTip": "Base of prototype chain."
  },
  "js-proto-07": {
    "prompt": "What ends the prototype chain?",
    "explanation": "`Object.prototype.__proto__ === null`.",
    "interviewTip": "Important chain termination."
  },
  "js-proto-08": {
    "prompt": "What does `hasOwnProperty` check?",
    "explanation": "Does not check prototypes.",
    "interviewTip": "Avoid false positives."
  },
  "js-proto-09": {
    "prompt": "What will be logged?",
    "explanation": "Property resolved via prototype chain.",
    "interviewTip": "Property lookup order."
  },
  "js-proto-10": {
    "prompt": "What happens when you overwrite prototype?",
    "explanation": "Prototype is set at creation time.",
    "interviewTip": "Common pitfall."
  },
  "js-proto-11": {
    "prompt": "What does `Object.create(proto)` do?",
    "explanation": "Direct prototype assignment.",
    "interviewTip": "Clean inheritance."
  },
  "js-proto-12": {
    "prompt": "What will be logged?",
    "explanation": "b inherits from a.",
    "interviewTip": "Delegation, not copying."
  },
  "js-proto-13": {
    "prompt": "What is `constructor` property?",
    "explanation": "Points back to constructor function.",
    "interviewTip": "May be lost when overwriting prototype."
  },
  "js-proto-14": {
    "prompt": "What will be logged?",
    "explanation": "`instanceof` checks prototype chain.",
    "interviewTip": "Not type-safe."
  },
  "js-proto-15": {
    "prompt": "Why avoid modifying native prototypes?",
    "explanation": "Prototype pollution risks.",
    "interviewTip": "Never extend Array/Object prototypes."
  },
  "js-proto-16": {
    "prompt": "What does method lookup do?",
    "explanation": "Stops when found or reaches null.",
    "interviewTip": "Performance implication."
  },
  "js-proto-17": {
    "prompt": "What will be logged?",
    "explanation": "Property assignment happens on object itself.",
    "interviewTip": "Shadowing prototype properties."
  },
  "js-proto-18": {
    "prompt": "What is prototype delegation?",
    "explanation": "JS uses delegation, not copying.",
    "interviewTip": "Mental model shift."
  },
  "js-proto-19": {
    "prompt": "What is `Object.setPrototypeOf`?",
    "explanation": "Allows changing prototype at runtime.",
    "interviewTip": "Slow, avoid in hot paths."
  },
  "js-proto-20": {
    "prompt": "What happens when method exists on both object and prototype?",
    "explanation": "Own property has priority.",
    "interviewTip": "Lookup order."
  },
  "js-proto-21": {
    "prompt": "What will be logged?",
    "explanation": "Prototype chain includes A.prototype.",
    "interviewTip": "Manual inheritance."
  },
  "js-proto-22": {
    "prompt": "What is the prototype of an arrow function?",
    "explanation": "Arrow functions are still functions.",
    "interviewTip": "They just lack `prototype` property."
  },
  "js-proto-23": {
    "prompt": "What will be logged?",
    "explanation": "Prototypes are objects.",
    "interviewTip": "Not functions."
  },
  "js-proto-24": {
    "prompt": "What is prototype pollution?",
    "explanation": "Security risk when prototypes are mutated.",
    "interviewTip": "Common vulnerability."
  },
  "js-proto-25": {
    "prompt": "Why is prototypal inheritance powerful?",
    "explanation": "Enables dynamic behavior sharing.",
    "interviewTip": "Better mental model than classes."
  },
  "js-mm-01": {
    "prompt": "Where are primitive values stored?",
    "explanation": "Primitives are stored on the stack.",
    "interviewTip": "Objects live on the heap."
  },
  "js-mm-02": {
    "prompt": "Where are objects stored?",
    "explanation": "Objects are allocated on the heap.",
    "interviewTip": "References are stored on the stack."
  },
  "js-mm-03": {
    "prompt": "What is garbage collection?",
    "explanation": "GC frees unreachable memory.",
    "interviewTip": "JS is GC-based."
  },
  "js-mm-04": {
    "prompt": "Which algorithm is commonly used by JS engines?",
    "explanation": "Modern engines use mark-and-sweep variants.",
    "interviewTip": "V8 uses generational GC."
  },
  "js-mm-05": {
    "prompt": "What makes an object eligible for GC?",
    "explanation": "Reachability determines GC.",
    "interviewTip": "Scope alone is not enough."
  },
  "js-mm-06": {
    "prompt": "What is a memory leak?",
    "explanation": "Leaked memory stays reachable.",
    "interviewTip": "Common in closures."
  },
  "js-mm-07": {
    "prompt": "Which is a common source of memory leaks?",
    "explanation": "Detached DOM nodes keep references.",
    "interviewTip": "Check event listeners."
  },
  "js-mm-08": {
    "prompt": "Why are global variables dangerous?",
    "explanation": "Globals are always reachable.",
    "interviewTip": "Avoid accidental globals."
  },
  "js-mm-09": {
    "prompt": "What happens during mark phase?",
    "explanation": "GC traverses object graph.",
    "interviewTip": "Starts from roots."
  },
  "js-mm-10": {
    "prompt": "What are GC roots?",
    "explanation": "GC starts from roots.",
    "interviewTip": "window, stack, closures."
  },
  "js-mm-11": {
    "prompt": "What is generational GC?",
    "explanation": "Young objects collected more often.",
    "interviewTip": "Most objects die young."
  },
  "js-mm-12": {
    "prompt": "What is a closure-related leak?",
    "explanation": "Closures may retain memory.",
    "interviewTip": "Clear references."
  },
  "js-mm-13": {
    "prompt": "Which structure prevents GC?",
    "explanation": "Strong references keep objects alive.",
    "interviewTip": "WeakMap doesn't."
  },
  "js-mm-14": {
    "prompt": "Why use WeakMap?",
    "explanation": "Keys are weakly held.",
    "interviewTip": "Great for caching."
  },
  "js-mm-15": {
    "prompt": "Can WeakMap keys be primitives?",
    "explanation": "Keys must be objects.",
    "interviewTip": "WeakSet too."
  },
  "js-mm-16": {
    "prompt": "What is heap fragmentation?",
    "explanation": "Impacts allocation performance.",
    "interviewTip": "Compaction fixes it."
  },
  "js-mm-17": {
    "prompt": "What is stop-the-world GC?",
    "explanation": "JS execution pauses.",
    "interviewTip": "Causes jank."
  },
  "js-mm-18": {
    "prompt": "Which tool helps detect memory leaks?",
    "explanation": "Heap snapshots reveal leaks.",
    "interviewTip": "Compare snapshots."
  },
  "js-mm-19": {
    "prompt": "What causes excessive GC?",
    "explanation": "Short-lived objects increase GC pressure.",
    "interviewTip": "Reuse objects."
  },
  "js-mm-20": {
    "prompt": "What is object pooling?",
    "explanation": "Reduces allocations.",
    "interviewTip": "Use carefully."
  },
  "js-mm-21": {
    "prompt": "Why avoid large arrays kept globally?",
    "explanation": "GC cannot free them.",
    "interviewTip": "Release references."
  },
  "js-mm-22": {
    "prompt": "What does nulling a reference do?",
    "explanation": "GC still decides.",
    "interviewTip": "Common misconception."
  },
  "js-mm-23": {
    "prompt": "Which API allows weak references?",
    "explanation": "Introduced for advanced cases.",
    "interviewTip": "Use with caution."
  },
  "js-mm-24": {
    "prompt": "Why is WeakRef dangerous?",
    "explanation": "Non-deterministic lifecycle.",
    "interviewTip": "Expert-level topic."
  },
  "js-mm-25": {
    "prompt": "Best rule for memory optimization?",
    "explanation": "Profiling is key.",
    "interviewTip": "Senior answer."
  },
  "js-hc-01": {
    "prompt": "What will be logged?",
    "explanation": "![] is false, [] == false → '' == 0 → true.",
    "interviewTip": "Classic coercion trap."
  },
  "js-hc-02": {
    "prompt": "What will this output?",
    "explanation": "NaN is a numeric value.",
    "interviewTip": "Use Number.isNaN."
  },
  "js-hc-03": {
    "prompt": "What happens?",
    "explanation": "Floating point precision issue.",
    "interviewTip": "IEEE 754."
  },
  "js-hc-04": {
    "prompt": "What will be logged?",
    "explanation": "Objects are reference-based.",
    "interviewTip": "Mutation awareness."
  },
  "js-hc-05": {
    "prompt": "What is logged?",
    "explanation": "Loose equality special case.",
    "interviewTip": "One of few == exceptions."
  },
  "js-hc-06": {
    "prompt": "What happens?",
    "explanation": "typeof always returns a string.",
    "interviewTip": "Very common trick."
  },
  "js-hc-07": {
    "prompt": "What will this print?",
    "explanation": "Arrays convert to strings.",
    "interviewTip": "Implicit toString."
  },
  "js-hc-08": {
    "prompt": "What is the result?",
    "explanation": "Non-empty strings are truthy.",
    "interviewTip": "Truthy vs semantic value."
  },
  "js-hc-09": {
    "prompt": "What will happen?",
    "explanation": "Prototype chain removed.",
    "interviewTip": "Used for pure dictionaries."
  },
  "js-hc-10": {
    "prompt": "What is logged?",
    "explanation": "Strings are iterable.",
    "interviewTip": "Iterator protocol."
  },
  "js-hc-11": {
    "prompt": "What happens?",
    "explanation": "Classes are functions.",
    "interviewTip": "Syntactic sugar."
  },
  "js-hc-12": {
    "prompt": "What is logged?",
    "explanation": "Max of empty set is -Infinity.",
    "interviewTip": "Edge case math."
  },
  "js-hc-13": {
    "prompt": "What is logged?",
    "explanation": "Different references.",
    "interviewTip": "Reference equality."
  },
  "js-hc-14": {
    "prompt": "What is the output?",
    "explanation": "'12' - 1 = 11.",
    "interviewTip": "Order matters."
  },
  "js-hc-15": {
    "prompt": "What does this return?",
    "explanation": "Object.is handles NaN correctly.",
    "interviewTip": "Difference vs ===."
  },
  "js-hc-16": {
    "prompt": "What happens?",
    "explanation": "Arrow returns undefined by default.",
    "interviewTip": "Implicit returns."
  },
  "js-hc-17": {
    "prompt": "What is logged?",
    "explanation": "Unary plus converts to number.",
    "interviewTip": "Coercion operator."
  },
  "js-hc-18": {
    "prompt": "What happens?",
    "explanation": "Both coerce to 0.",
    "interviewTip": "== pitfalls."
  },
  "js-hc-19": {
    "prompt": "What will be logged?",
    "explanation": "Primitive passed by value.",
    "interviewTip": "Contrast with objects."
  },
  "js-hc-20": {
    "prompt": "What happens?",
    "explanation": "Wrapper object.",
    "interviewTip": "Avoid constructors."
  },
  "js-hc-21": {
    "prompt": "What is logged?",
    "explanation": "Arrays are truthy.",
    "interviewTip": "Even empty arrays."
  },
  "js-hc-22": {
    "prompt": "What happens?",
    "explanation": "true < 3 → 1 < 3.",
    "interviewTip": "Comparison chaining trap."
  },
  "js-hc-23": {
    "prompt": "What is logged?",
    "explanation": "undefined vs object.",
    "interviewTip": "Historical bug again."
  },
  "js-hc-24": {
    "prompt": "What happens?",
    "explanation": "Unary plus converts string.",
    "interviewTip": "Operator precedence."
  },
  "js-hc-25": {
    "prompt": "Hard rule for interviews?",
    "explanation": "Reasoning > speed.",
    "interviewTip": "Senior mindset."
  },
  "js-fn-01": {
    "prompt": "What will be logged?",
    "explanation": "In JavaScript, functions are first-class objects but `typeof` returns `function`.",
    "interviewTip": "Mention that functions are callable objects with internal [[Call]]."
  },
  "js-fn-02": {
    "prompt": "What is the output?",
    "explanation": "Function declarations are hoisted with their body.",
    "interviewTip": "Contrast with function expressions."
  },
  "js-fn-03": {
    "prompt": "What happens?",
    "explanation": "`bar` exists but is undefined at call time.",
    "interviewTip": "Function expressions are not hoisted like declarations."
  },
  "js-fn-04": {
    "prompt": "What will be logged?",
    "explanation": "Parentheses allow implicit return of an object.",
    "interviewTip": "Common arrow function pitfall."
  },
  "js-fn-05": {
    "prompt": "Arrow functions differ from regular functions because they…",
    "explanation": "Arrow functions capture `this` from lexical scope.",
    "interviewTip": "Great question to test understanding of `this`."
  },
  "js-fn-06": {
    "prompt": "What is logged?",
    "explanation": "`arguments` contains passed arguments only.",
    "interviewTip": "Mention that arrow functions don’t have `arguments`."
  },
  "js-fn-07": {
    "prompt": "What will this output?",
    "explanation": "Default parameters apply when argument is `undefined`.",
    "interviewTip": "Different from passing `null`."
  },
  "js-fn-08": {
    "prompt": "What does this return?",
    "explanation": "Automatic semicolon insertion ends the return.",
    "interviewTip": "Classic JS gotcha."
  },
  "js-fn-09": {
    "prompt": "What is a higher-order function?",
    "explanation": "Higher-order functions operate on other functions.",
    "interviewTip": "Examples: map, filter, reduce."
  },
  "js-fn-10": {
    "prompt": "What will be logged?",
    "explanation": "In strict mode, `this` is undefined.",
    "interviewTip": "Always ask about strict mode."
  },
  "js-fn-11": {
    "prompt": "What does bind do?",
    "explanation": "`bind` returns a new function.",
    "interviewTip": "bind ≠ call ≠ apply."
  },
  "js-fn-12": {
    "prompt": "What is logged?",
    "explanation": "`rest` collects remaining arguments.",
    "interviewTip": "Rest vs arguments."
  },
  "js-fn-13": {
    "prompt": "What will happen?",
    "explanation": "Arrow functions cannot be used as constructors.",
    "interviewTip": "No [[Construct]] method."
  },
  "js-fn-14": {
    "prompt": "What is recursion?",
    "explanation": "Recursion is self-invocation.",
    "interviewTip": "Always mention base case."
  },
  "js-fn-15": {
    "prompt": "What will be logged?",
    "explanation": "Closure preserves x.",
    "interviewTip": "Closures are core JS concept."
  },
  "js-fn-16": {
    "prompt": "Which is true about closures?",
    "explanation": "Closures reference outer scope variables.",
    "interviewTip": "Explain memory implications."
  },
  "js-fn-17": {
    "prompt": "What does IIFE stand for?",
    "explanation": "IIFE executes immediately after definition.",
    "interviewTip": "Used for scope isolation."
  },
  "js-fn-18": {
    "prompt": "What is logged?",
    "explanation": "`arguments` is array-like object.",
    "interviewTip": "Not a real array."
  },
  "js-fn-19": {
    "prompt": "What is tail recursion?",
    "explanation": "Tail call optimization can reuse stack.",
    "interviewTip": "Not widely optimized in JS engines."
  },
  "js-fn-20": {
    "prompt": "What does this log?",
    "explanation": "Default params can reference previous params.",
    "interviewTip": "Order matters."
  },
  "js-fn-21": {
    "prompt": "What happens if a function has no return?",
    "explanation": "Implicit return is undefined.",
    "interviewTip": "Common beginner mistake."
  },
  "js-fn-22": {
    "prompt": "What does call do?",
    "explanation": "`call` invokes immediately.",
    "interviewTip": "Difference between call/apply/bind."
  },
  "js-fn-23": {
    "prompt": "What is function arity?",
    "explanation": "`fn.length` shows arity.",
    "interviewTip": "Useful for functional patterns."
  },
  "js-fn-24": {
    "prompt": "What will be logged?",
    "explanation": "Functions have a prototype property.",
    "interviewTip": "Arrow functions don’t."
  },
  "js-fn-25": {
    "prompt": "Why are functions called first-class citizens?",
    "explanation": "Functions behave like regular values.",
    "interviewTip": "This enables functional programming."
  },
  "js-el-adv-01": {
    "prompt": "Which queue has higher priority in the event loop?",
    "explanation": "Microtasks run before the next macrotask.",
    "interviewTip": "Promises can starve rendering."
  },
  "js-el-adv-02": {
    "prompt": "Which API schedules a microtask?",
    "explanation": "Promise callbacks go to microtask queue.",
    "interviewTip": "queueMicrotask exists."
  },
  "js-el-adv-03": {
    "prompt": "What happens if microtasks keep scheduling new microtasks?",
    "explanation": "This causes starvation.",
    "interviewTip": "Common performance pitfall."
  },
  "js-el-adv-04": {
    "prompt": "When does rendering occur?",
    "explanation": "Rendering happens after microtasks drain.",
    "interviewTip": "Why promises can block paint."
  },
  "js-el-adv-05": {
    "prompt": "Where does requestAnimationFrame run?",
    "explanation": "Runs before the next paint.",
    "interviewTip": "Use for animations."
  },
  "js-el-adv-06": {
    "prompt": "Which callback may never run under heavy load?",
    "explanation": "Idle time may never occur.",
    "interviewTip": "Not guaranteed."
  },
  "js-el-adv-07": {
    "prompt": "What queue does MutationObserver use?",
    "explanation": "Runs as microtask.",
    "interviewTip": "Often forgotten."
  },
  "js-el-adv-08": {
    "prompt": "Which task blocks rendering the most?",
    "explanation": "Main thread is blocked.",
    "interviewTip": "Chunk long tasks."
  },
  "js-el-adv-09": {
    "prompt": "What is a long task?",
    "explanation": "Used in performance metrics.",
    "interviewTip": "Related to TBT."
  },
  "js-el-adv-10": {
    "prompt": "Which API helps split long tasks?",
    "explanation": "Runs work in idle periods.",
    "interviewTip": "Not supported everywhere."
  },
  "js-el-adv-11": {
    "prompt": "What happens after a macrotask finishes?",
    "explanation": "Microtasks drain first.",
    "interviewTip": "Key interview flow."
  },
  "js-el-adv-12": {
    "prompt": "Which is a macrotask?",
    "explanation": "Timers create macrotasks.",
    "interviewTip": "Know examples."
  },
  "js-el-adv-13": {
    "prompt": "Why is setTimeout(fn, 0) not immediate?",
    "explanation": "Subject to clamping.",
    "interviewTip": "4ms rule."
  },
  "js-el-adv-14": {
    "prompt": "Which can delay input handling?",
    "explanation": "Main thread contention.",
    "interviewTip": "INP metric."
  },
  "js-el-adv-15": {
    "prompt": "Best way to avoid starvation?",
    "explanation": "Break work into chunks.",
    "interviewTip": "Cooperative scheduling."
  },
  "js-el-adv-16": {
    "prompt": "Which runs outside the event loop?",
    "explanation": "Separate thread.",
    "interviewTip": "No DOM access."
  },
  "js-el-adv-17": {
    "prompt": "What is cooperative scheduling?",
    "explanation": "JS must yield explicitly.",
    "interviewTip": "Contrast with threads."
  },
  "js-el-adv-18": {
    "prompt": "What does await do internally?",
    "explanation": "Continuation via promise.",
    "interviewTip": "Syntactic sugar."
  },
  "js-el-adv-19": {
    "prompt": "Which affects paint timing?",
    "explanation": "Microtasks delay paint.",
    "interviewTip": "Subtle bug source."
  },
  "js-el-adv-20": {
    "prompt": "What metric measures JS blocking?",
    "explanation": "Part of Core Web Vitals.",
    "interviewTip": "Performance interviews."
  },
  "js-el-adv-21": {
    "prompt": "What happens if JS never yields?",
    "explanation": "Single-threaded limitation.",
    "interviewTip": "Classic explanation."
  },
  "js-el-adv-22": {
    "prompt": "Which callback runs first?",
    "explanation": "Microtasks first.",
    "interviewTip": "Order questions common."
  },
  "js-el-adv-23": {
    "prompt": "What is task batching?",
    "explanation": "Improves responsiveness.",
    "interviewTip": "React uses it."
  },
  "js-el-adv-24": {
    "prompt": "Which API is frame-aligned?",
    "explanation": "Synced with refresh rate.",
    "interviewTip": "Avoid jank."
  },
  "js-el-adv-25": {
    "prompt": "Best rule for event loop optimization?",
    "explanation": "Always profile.",
    "interviewTip": "Senior-level answer."
  },
  "js-err-01": {
    "prompt": "What is an Error object in JavaScript?",
    "explanation": "Error objects carry message and stack trace.",
    "interviewTip": "Used for exception handling."
  },
  "js-err-02": {
    "prompt": "Which error occurs at parse time?",
    "explanation": "SyntaxError happens before execution.",
    "interviewTip": "Code won't run at all."
  },
  "js-err-03": {
    "prompt": "What will be thrown?",
    "explanation": "Accessing undeclared variable.",
    "interviewTip": "Different from undefined variable."
  },
  "js-err-04": {
    "prompt": "When does TypeError occur?",
    "explanation": "Calling non-function, accessing invalid property.",
    "interviewTip": "Very common runtime error."
  },
  "js-err-05": {
    "prompt": "What will be logged?",
    "explanation": "Invalid JSON throws SyntaxError.",
    "interviewTip": "Always validate JSON."
  },
  "js-err-06": {
    "prompt": "What does try/catch catch?",
    "explanation": "Only synchronous runtime errors.",
    "interviewTip": "Async needs await or .catch."
  },
  "js-err-07": {
    "prompt": "What will be logged?",
    "explanation": "Async errors are not caught.",
    "interviewTip": "Classic async pitfall."
  },
  "js-err-08": {
    "prompt": "How to catch async errors with async/await?",
    "explanation": "Await throws inside try/catch.",
    "interviewTip": "Preferred pattern."
  },
  "js-err-09": {
    "prompt": "What is finally used for?",
    "explanation": "Runs regardless of outcome.",
    "interviewTip": "Close resources."
  },
  "js-err-10": {
    "prompt": "What does `throw` do?",
    "explanation": "Interrupts normal execution.",
    "interviewTip": "Can throw any value."
  },
  "js-err-11": {
    "prompt": "What should you throw?",
    "explanation": "Errors include stack trace.",
    "interviewTip": "Best practice."
  },
  "js-err-12": {
    "prompt": "What will be logged?",
    "explanation": "message property holds text.",
    "interviewTip": "Access useful fields."
  },
  "js-err-13": {
    "prompt": "What is ReferenceError?",
    "explanation": "Variable not found in scope.",
    "interviewTip": "Common bug source."
  },
  "js-err-14": {
    "prompt": "What will be logged?",
    "explanation": "Calling method on null.",
    "interviewTip": "TypeError is common."
  },
  "js-err-15": {
    "prompt": "How to create custom error?",
    "explanation": "Extend Error class.",
    "interviewTip": "Preserve name & stack."
  },
  "js-err-16": {
    "prompt": "What does Error.stack contain?",
    "explanation": "Useful for debugging.",
    "interviewTip": "Not standardized but common."
  },
  "js-err-17": {
    "prompt": "What is an unhandled promise rejection?",
    "explanation": "Leads to warnings or crashes.",
    "interviewTip": "Always handle rejections."
  },
  "js-err-18": {
    "prompt": "What will be logged?",
    "explanation": "Rejected value is passed.",
    "interviewTip": "Can reject any value."
  },
  "js-err-19": {
    "prompt": "What does `catch` return?",
    "explanation": "Allows chaining.",
    "interviewTip": "Promise chain continues."
  },
  "js-err-20": {
    "prompt": "What happens if you throw inside catch?",
    "explanation": "Error propagates.",
    "interviewTip": "Re-throw pattern."
  },
  "js-err-21": {
    "prompt": "What is RangeError?",
    "explanation": "E.g. invalid array length.",
    "interviewTip": "Less common."
  },
  "js-err-22": {
    "prompt": "Can try/catch catch JSON.parse errors?",
    "explanation": "JSON.parse throws synchronously.",
    "interviewTip": "Wrap parsing logic."
  },
  "js-err-23": {
    "prompt": "What is best practice for errors?",
    "explanation": "Errors should be explicit.",
    "interviewTip": "Production mindset."
  },
  "js-err-24": {
    "prompt": "What will be logged?",
    "explanation": "Any value can be thrown.",
    "interviewTip": "But don't do this."
  },
  "js-err-25": {
    "prompt": "Why prefer Error over strings?",
    "explanation": "Errors carry more context.",
    "interviewTip": "Interview gold answer."
  },
  "js-br-01": {
    "prompt": "What is the first step in the rendering pipeline?",
    "explanation": "HTML is parsed into the DOM first.",
    "interviewTip": "Start of critical render path."
  },
  "js-br-02": {
    "prompt": "What is created from parsing CSS?",
    "explanation": "CSSOM represents parsed CSS.",
    "interviewTip": "DOM + CSSOM = Render Tree."
  },
  "js-br-03": {
    "prompt": "What does the render tree contain?",
    "explanation": "Hidden nodes are excluded.",
    "interviewTip": "display:none nodes skipped."
  },
  "js-br-04": {
    "prompt": "What is layout (reflow)?",
    "explanation": "Layout computes geometry.",
    "interviewTip": "Very expensive step."
  },
  "js-br-05": {
    "prompt": "What triggers a reflow?",
    "explanation": "Geometry changes require reflow.",
    "interviewTip": "Avoid layout thrashing."
  },
  "js-br-06": {
    "prompt": "What is repaint?",
    "explanation": "Visual-only updates.",
    "interviewTip": "Cheaper than reflow."
  },
  "js-br-07": {
    "prompt": "Which CSS property avoids reflow and repaint?",
    "explanation": "Transforms are compositor-only.",
    "interviewTip": "Key animation trick."
  },
  "js-br-08": {
    "prompt": "What is compositing?",
    "explanation": "Final step before display.",
    "interviewTip": "GPU-accelerated."
  },
  "js-br-09": {
    "prompt": "Which properties are typically GPU-accelerated?",
    "explanation": "They skip layout.",
    "interviewTip": "Smooth animations."
  },
  "js-br-10": {
    "prompt": "What causes layout thrashing?",
    "explanation": "Forces sync layout.",
    "interviewTip": "Classic performance bug."
  },
  "js-br-11": {
    "prompt": "What is forced synchronous layout?",
    "explanation": "Triggered by layout reads.",
    "interviewTip": "Avoid offsetHeight after writes."
  },
  "js-br-12": {
    "prompt": "When does requestAnimationFrame run?",
    "explanation": "Frame-synced callback.",
    "interviewTip": "Use for animations."
  },
  "js-br-13": {
    "prompt": "What is a render layer?",
    "explanation": "Used in compositing.",
    "interviewTip": "Too many layers hurt memory."
  },
  "js-br-14": {
    "prompt": "What promotes an element to its own layer?",
    "explanation": "Hints browser optimization.",
    "interviewTip": "Use will-change sparingly."
  },
  "js-br-15": {
    "prompt": "What is the critical render path?",
    "explanation": "From HTML to pixels.",
    "interviewTip": "Optimize for FCP."
  },
  "js-br-16": {
    "prompt": "Why inline critical CSS?",
    "explanation": "CSS blocks rendering.",
    "interviewTip": "Common optimization."
  },
  "js-br-17": {
    "prompt": "Which metric measures layout stability?",
    "explanation": "Cumulative Layout Shift.",
    "interviewTip": "Web Vitals."
  },
  "js-br-18": {
    "prompt": "Which metric reflects render performance best?",
    "explanation": "Largest Contentful Paint.",
    "interviewTip": "User-centric."
  },
  "js-br-19": {
    "prompt": "What blocks first paint?",
    "explanation": "CSS must be parsed first.",
    "interviewTip": "Critical CSS again."
  },
  "js-br-20": {
    "prompt": "What is paint flashing used for?",
    "explanation": "DevTools feature.",
    "interviewTip": "Helps optimize UI."
  },
  "js-br-21": {
    "prompt": "What happens if JS blocks main thread?",
    "explanation": "Single-threaded rendering.",
    "interviewTip": "Chunk JS work."
  },
  "js-br-22": {
    "prompt": "Why avoid large DOM trees?",
    "explanation": "Layout cost grows.",
    "interviewTip": "Virtualization helps."
  },
  "js-br-23": {
    "prompt": "Which tool profiles rendering?",
    "explanation": "Shows frames and paint.",
    "interviewTip": "Know how to read flame charts."
  },
  "js-br-24": {
    "prompt": "What is frame budget at 60fps?",
    "explanation": "1000ms / 60 ≈ 16ms.",
    "interviewTip": "Includes JS + render."
  },
  "js-br-25": {
    "prompt": "Golden rule of rendering optimization?",
    "explanation": "Data-driven optimization.",
    "interviewTip": "Senior-level answer."
  },
  "js-browser-01": {
    "prompt": "What is the main responsibility of the browser?",
    "explanation": "Browser renders UI and runs JS engine.",
    "interviewTip": "Rendering pipeline matters."
  },
  "js-browser-02": {
    "prompt": "What happens first when loading a webpage?",
    "explanation": "HTML is parsed into DOM.",
    "interviewTip": "Critical render path."
  },
  "js-browser-03": {
    "prompt": "What is the DOM?",
    "explanation": "DOM is a node tree.",
    "interviewTip": "JS manipulates DOM."
  },
  "js-browser-04": {
    "prompt": "What is the CSSOM?",
    "explanation": "CSSOM is created from CSS.",
    "interviewTip": "DOM + CSSOM = Render Tree."
  },
  "js-browser-05": {
    "prompt": "What blocks HTML parsing?",
    "explanation": "Blocking scripts stop parsing.",
    "interviewTip": "Use defer/async."
  },
  "js-browser-06": {
    "prompt": "Difference between async and defer?",
    "explanation": "Defer preserves order.",
    "interviewTip": "Classic interview question."
  },
  "js-browser-07": {
    "prompt": "What is reflow?",
    "explanation": "Reflow recalculates layout.",
    "interviewTip": "Expensive operation."
  },
  "js-browser-08": {
    "prompt": "What triggers repaint?",
    "explanation": "Color/visibility changes.",
    "interviewTip": "Cheaper than reflow."
  },
  "js-browser-09": {
    "prompt": "What is the render tree?",
    "explanation": "Used for layout and paint.",
    "interviewTip": "Invisible nodes excluded."
  },
  "js-browser-10": {
    "prompt": "What does the event loop handle?",
    "explanation": "Manages task execution order.",
    "interviewTip": "Macro vs micro tasks."
  },
  "js-browser-11": {
    "prompt": "Which task has higher priority?",
    "explanation": "Promises resolve first.",
    "interviewTip": "Critical for async bugs."
  },
  "js-browser-12": {
    "prompt": "What is same-origin policy?",
    "explanation": "Prevents cross-origin access.",
    "interviewTip": "CORS exists because of it."
  },
  "js-browser-13": {
    "prompt": "What is CORS?",
    "explanation": "Controls cross-origin requests.",
    "interviewTip": "Server-controlled."
  },
  "js-browser-14": {
    "prompt": "Which storage is synchronous?",
    "explanation": "Blocks main thread.",
    "interviewTip": "Avoid heavy usage."
  },
  "js-browser-15": {
    "prompt": "Best storage for large data?",
    "explanation": "Async and large capacity.",
    "interviewTip": "Used by PWAs."
  },
  "js-browser-16": {
    "prompt": "What is a Service Worker?",
    "explanation": "Intercepts network requests.",
    "interviewTip": "Offline support."
  },
  "js-browser-17": {
    "prompt": "What enables offline support?",
    "explanation": "Core PWA feature.",
    "interviewTip": "Ask about caching strategies."
  },
  "js-browser-18": {
    "prompt": "What is HTTP/2 advantage?",
    "explanation": "Multiple streams over one connection.",
    "interviewTip": "Improves performance."
  },
  "js-browser-19": {
    "prompt": "Why minimize critical CSS?",
    "explanation": "Speeds up rendering.",
    "interviewTip": "Inline critical CSS."
  },
  "js-browser-20": {
    "prompt": "What is First Contentful Paint?",
    "explanation": "User-perceived performance.",
    "interviewTip": "Web Vitals."
  },
  "js-browser-21": {
    "prompt": "What is layout shift?",
    "explanation": "Measured by CLS.",
    "interviewTip": "Avoid dynamic content jumps."
  },
  "js-browser-22": {
    "prompt": "Which API runs off main thread?",
    "explanation": "True multithreading.",
    "interviewTip": "Cannot access DOM."
  },
  "js-browser-23": {
    "prompt": "What is the JS heap?",
    "explanation": "Used for dynamic allocations.",
    "interviewTip": "Leaks live here."
  },
  "js-browser-24": {
    "prompt": "What causes forced synchronous layout?",
    "explanation": "Triggers immediate reflow.",
    "interviewTip": "Avoid layout thrashing."
  },
  "js-browser-25": {
    "prompt": "Best way to optimize rendering?",
    "explanation": "Profiling first.",
    "interviewTip": "Never guess."
  },
  "js-basics-01": {
    "prompt": "What will be logged?",
    "explanation": "`typeof null` returns `object` due to a historical bug.",
    "interviewTip": "Mention backward compatibility and proper null checks."
  },
  "js-basics-02": {
    "prompt": "What will be logged?",
    "explanation": "Uninitialized variables have value `undefined`.",
    "interviewTip": "Explain `undefined` vs `not defined`."
  },
  "js-basics-03": {
    "prompt": "What will be the result?",
    "explanation": "Once a string is involved, `+` becomes concatenation.",
    "interviewTip": "Explain left-to-right evaluation."
  },
  "js-basics-04": {
    "prompt": "What will be logged?",
    "explanation": "`-` triggers numeric coercion.",
    "interviewTip": "Contrast `+` vs other operators."
  },
  "js-basics-05": {
    "prompt": "Which value is falsy?",
    "explanation": "`0` is falsy; objects and non-empty strings are truthy.",
    "interviewTip": "List all falsy values."
  },
  "js-basics-06": {
    "prompt": "What will be logged?",
    "explanation": "All objects are truthy.",
    "interviewTip": "Arrays are objects in JS."
  },
  "js-basics-07": {
    "prompt": "Which statements are correct?",
    "explanation": "`const` prevents reassignment, not mutation.",
    "interviewTip": "Clarify reassignment vs mutation."
  },
  "js-basics-08": {
    "prompt": "What will be logged?",
    "explanation": "Loose equality triggers complex coercion.",
    "interviewTip": "Recommend avoiding `==`."
  },
  "js-basics-09": {
    "prompt": "What will be logged?",
    "explanation": "Empty string converts to 0.",
    "interviewTip": "Explain numeric coercion rules."
  },
  "js-basics-10": {
    "prompt": "What will be logged?",
    "explanation": "`NaN` is of type `number`.",
    "interviewTip": "Mention `Number.isNaN`."
  },
  "js-basics-11": {
    "prompt": "What will be logged?",
    "explanation": "`null` and `undefined` are equal only to each other.",
    "interviewTip": "Explain special case in `==`."
  },
  "js-basics-12": {
    "prompt": "What will be logged?",
    "explanation": "Objects are compared by reference.",
    "interviewTip": "Stress reference equality."
  },
  "js-basics-13": {
    "prompt": "What will be logged?",
    "explanation": "Non-empty strings are truthy.",
    "interviewTip": "Explain double negation."
  },
  "js-basics-14": {
    "prompt": "What will be logged?",
    "explanation": "`undefined` has its own type.",
    "interviewTip": "Contrast with `null`."
  },
  "js-basics-15": {
    "prompt": "What will be logged?",
    "explanation": "`0` and `-0` are equal in JS.",
    "interviewTip": "Mention `Object.is` difference."
  },
  "js-basics-16": {
    "prompt": "What will be logged?",
    "explanation": "`Object.is` treats `0` and `-0` as different.",
    "interviewTip": "Compare `===` vs `Object.is`."
  },
  "js-basics-17": {
    "prompt": "What will be logged?",
    "explanation": "Arrow functions are still functions.",
    "interviewTip": "Arrow is syntax, not type."
  },
  "js-basics-18": {
    "prompt": "What will be logged?",
    "explanation": "`isNaN` coerces values before checking.",
    "interviewTip": "Recommend `Number.isNaN`."
  },
  "js-basics-19": {
    "prompt": "What will be logged?",
    "explanation": "`Number.isNaN` does not coerce.",
    "interviewTip": "Explain strict NaN check."
  },
  "js-basics-20": {
    "prompt": "What will be logged?",
    "explanation": "Classes are functions under the hood.",
    "interviewTip": "Explain syntactic sugar."
  },
  "js-basics-21": {
    "prompt": "What will be logged?",
    "explanation": "Unary plus converts to number.",
    "interviewTip": "Mention unary operators."
  },
  "js-basics-22": {
    "prompt": "What will be logged?",
    "explanation": "Arrays convert to empty strings.",
    "interviewTip": "Explain `toString` coercion."
  },
  "js-basics-23": {
    "prompt": "What will be logged?",
    "explanation": "Object converts to string, then concatenates.",
    "interviewTip": "Context matters (`{}` as block vs object)."
  },
  "js-basics-24": {
    "prompt": "What will be logged?",
    "explanation": "Infinity is a number.",
    "interviewTip": "Mention IEEE 754."
  },
  "js-basics-25": {
    "prompt": "What will be logged?",
    "explanation": "Invalid numeric conversion results in NaN.",
    "interviewTip": "Explain arithmetic coercion."
  },
  "js-async-01": {
    "prompt": "What is asynchronous programming in JavaScript?",
    "explanation": "Async code allows non-blocking operations.",
    "interviewTip": "JS is single-threaded but async."
  },
  "js-async-02": {
    "prompt": "Which API is used to handle async tasks?",
    "explanation": "Event Loop coordinates async execution.",
    "interviewTip": "Critical interview topic."
  },
  "js-async-03": {
    "prompt": "What will be logged?",
    "explanation": "setTimeout is async.",
    "interviewTip": "Macro-task behavior."
  },
  "js-async-04": {
    "prompt": "What is a Promise?",
    "explanation": "Promise represents future value.",
    "interviewTip": "Pending / fulfilled / rejected."
  },
  "js-async-05": {
    "prompt": "Which state does a Promise NOT have?",
    "explanation": "`resolved` is informal term.",
    "interviewTip": "Precise terminology matters."
  },
  "js-async-06": {
    "prompt": "What will be logged?",
    "explanation": "Microtasks run after sync code.",
    "interviewTip": "Microtask queue."
  },
  "js-async-07": {
    "prompt": "What is async/await?",
    "explanation": "Built on top of Promises.",
    "interviewTip": "Still async."
  },
  "js-async-08": {
    "prompt": "What does `await` do?",
    "explanation": "Pauses only current async function.",
    "interviewTip": "Does not block event loop."
  },
  "js-async-09": {
    "prompt": "What will be logged?",
    "explanation": "Async functions return Promises.",
    "interviewTip": "Return is wrapped."
  },
  "js-async-10": {
    "prompt": "Which runs first?",
    "explanation": "Microtasks have higher priority.",
    "interviewTip": "Promise.then vs setTimeout."
  },
  "js-async-11": {
    "prompt": "What does `Promise.all` do?",
    "explanation": "Rejects if any promise rejects.",
    "interviewTip": "Fail-fast."
  },
  "js-async-12": {
    "prompt": "What does `Promise.race` do?",
    "explanation": "First settled wins.",
    "interviewTip": "Useful for timeouts."
  },
  "js-async-13": {
    "prompt": "What will be logged?",
    "explanation": "Await throws on rejection.",
    "interviewTip": "Use try/catch."
  },
  "js-async-14": {
    "prompt": "How to handle errors in async/await?",
    "explanation": "try/catch catches rejected promises.",
    "interviewTip": "Local error handling."
  },
  "js-async-15": {
    "prompt": "What will be logged?",
    "explanation": "Microtasks before macrotasks.",
    "interviewTip": "Classic interview question."
  },
  "js-async-16": {
    "prompt": "What does `finally` do?",
    "explanation": "Runs after resolve or reject.",
    "interviewTip": "No access to result."
  },
  "js-async-17": {
    "prompt": "What is callback hell?",
    "explanation": "Hard to read and maintain.",
    "interviewTip": "Promises solve it."
  },
  "js-async-18": {
    "prompt": "What does `await Promise.all([...])` do?",
    "explanation": "Promises start immediately.",
    "interviewTip": "Performance optimization."
  },
  "js-async-19": {
    "prompt": "Why avoid `await` inside loops?",
    "explanation": "Use Promise.all instead.",
    "interviewTip": "Common performance issue."
  },
  "js-async-20": {
    "prompt": "What will be logged?",
    "explanation": "Promise is flattened.",
    "interviewTip": "Promise resolution."
  },
  "js-async-21": {
    "prompt": "What is a macrotask?",
    "explanation": "Scheduled via task queue.",
    "interviewTip": "Lower priority than microtasks."
  },
  "js-async-22": {
    "prompt": "What happens if Promise rejects and no catch?",
    "explanation": "Leads to warnings/errors.",
    "interviewTip": "Always handle rejections."
  },
  "js-async-23": {
    "prompt": "What does `queueMicrotask` do?",
    "explanation": "Runs before next macrotask.",
    "interviewTip": "Advanced topic."
  },
  "js-async-24": {
    "prompt": "Why is async code hard to debug?",
    "explanation": "Async flow is harder to trace.",
    "interviewTip": "Use async stack traces."
  },
  "js-async-25": {
    "prompt": "Best practice for async code?",
    "explanation": "Readable and maintainable.",
    "interviewTip": "Production-ready approach."
  },
  "js-arr-01": {
    "prompt": "What is an array in JavaScript?",
    "explanation": "Arrays are ordered, zero-indexed objects.",
    "interviewTip": "Arrays are objects internally."
  },
  "js-arr-02": {
    "prompt": "What will be logged?",
    "explanation": "Arrays are a type of object.",
    "interviewTip": "Use Array.isArray()."
  },
  "js-arr-03": {
    "prompt": "How to correctly check if value is an array?",
    "explanation": "Array.isArray is the safest method.",
    "interviewTip": "Works across realms."
  },
  "js-arr-04": {
    "prompt": "Which method mutates the array?",
    "explanation": "push mutates the original array.",
    "interviewTip": "Mutation vs immutability."
  },
  "js-arr-05": {
    "prompt": "What will be logged?",
    "explanation": "Reducing length truncates the array.",
    "interviewTip": "Length is writable."
  },
  "js-arr-06": {
    "prompt": "What does `slice` do?",
    "explanation": "slice is non-mutating.",
    "interviewTip": "Common interview distinction."
  },
  "js-arr-07": {
    "prompt": "Which method removes the last element?",
    "explanation": "pop removes last element.",
    "interviewTip": "Mutates array."
  },
  "js-arr-08": {
    "prompt": "What will be logged?",
    "explanation": "map returns a new array.",
    "interviewTip": "Reference comparison."
  },
  "js-arr-09": {
    "prompt": "What does `splice` do?",
    "explanation": "splice mutates the array.",
    "interviewTip": "Often confused with slice."
  },
  "js-arr-10": {
    "prompt": "What will be logged?",
    "explanation": "Array length becomes highest index + 1.",
    "interviewTip": "Sparse arrays."
  },
  "js-arr-11": {
    "prompt": "Which creates a shallow copy?",
    "explanation": "slice returns a new array.",
    "interviewTip": "Still shallow."
  },
  "js-arr-12": {
    "prompt": "What does `forEach` return?",
    "explanation": "forEach always returns undefined.",
    "interviewTip": "Not chainable."
  },
  "js-arr-13": {
    "prompt": "What will be logged?",
    "explanation": "includes checks value existence.",
    "interviewTip": "Uses SameValueZero."
  },
  "js-arr-14": {
    "prompt": "Which method flattens arrays?",
    "explanation": "flat flattens nested arrays.",
    "interviewTip": "Depth can be specified."
  },
  "js-arr-15": {
    "prompt": "What will be logged?",
    "explanation": "Arrays are coerced to strings.",
    "interviewTip": "Implicit coercion."
  },
  "js-arr-16": {
    "prompt": "Which method does NOT mutate?",
    "explanation": "filter returns a new array.",
    "interviewTip": "sort mutates!"
  },
  "js-arr-17": {
    "prompt": "What does `reduce` do?",
    "explanation": "reduce accumulates to a single value.",
    "interviewTip": "Very powerful method."
  },
  "js-arr-18": {
    "prompt": "What will be logged?",
    "explanation": "Both references point to same array.",
    "interviewTip": "Reference vs copy."
  },
  "js-arr-19": {
    "prompt": "What does `Array.from` do?",
    "explanation": "Converts array-like objects.",
    "interviewTip": "Useful for NodeList."
  },
  "js-arr-20": {
    "prompt": "What will be logged?",
    "explanation": "Empty array length is 0.",
    "interviewTip": "Basic but common."
  },
  "js-arr-21": {
    "prompt": "What does `every` return?",
    "explanation": "Checks all elements against condition.",
    "interviewTip": "Stops early."
  },
  "js-arr-22": {
    "prompt": "What does `some` do?",
    "explanation": "Returns true if any element matches.",
    "interviewTip": "Short-circuit."
  },
  "js-arr-23": {
    "prompt": "What will be logged?",
    "explanation": "Sparse arrays count empty slots.",
    "interviewTip": "Empty slots exist."
  },
  "js-arr-24": {
    "prompt": "What does `concat` do?",
    "explanation": "concat does not mutate.",
    "interviewTip": "Immutable pattern."
  },
  "js-arr-25": {
    "prompt": "Why avoid mutating arrays in React?",
    "explanation": "Immutability helps change detection.",
    "interviewTip": "Key React concept."
  },
  "js-adv-01": {
    "prompt": "What will be logged?",
    "explanation": "Variable is hoisted but not initialized.",
    "interviewTip": "var hoisting vs let/const."
  },
  "js-adv-02": {
    "prompt": "What happens?",
    "explanation": "Function declarations are hoisted.",
    "interviewTip": "Diff vs function expressions."
  },
  "js-adv-03": {
    "prompt": "What is logged?",
    "explanation": "Temporal Dead Zone.",
    "interviewTip": "let/const behavior."
  },
  "js-adv-04": {
    "prompt": "What will this output?",
    "explanation": "Closure preserves lexical scope.",
    "interviewTip": "Closures & memory."
  },
  "js-adv-05": {
    "prompt": "What is currying?",
    "explanation": "Currying = f(a,b) → f(a)(b).",
    "interviewTip": "Functional patterns."
  },
  "js-adv-06": {
    "prompt": "What will be logged?",
    "explanation": "Curried function.",
    "interviewTip": "Partial application."
  },
  "js-adv-07": {
    "prompt": "Main difference between debounce and throttle?",
    "explanation": "Debounce waits, throttle limits calls.",
    "interviewTip": "Scroll / resize handlers."
  },
  "js-adv-08": {
    "prompt": "What happens?",
    "explanation": "`this` is lost.",
    "interviewTip": "Bind context."
  },
  "js-adv-09": {
    "prompt": "How to fix previous issue?",
    "explanation": "bind fixes context.",
    "interviewTip": "call/apply/bind."
  },
  "js-adv-10": {
    "prompt": "Arrow function this refers to?",
    "explanation": "Arrow has no own this.",
    "interviewTip": "Event handlers."
  },
  "js-adv-11": {
    "prompt": "What will be logged?",
    "explanation": "NaN is number.",
    "interviewTip": "Use Number.isNaN."
  },
  "js-adv-12": {
    "prompt": "What does this return?",
    "explanation": "Object.is distinguishes -0 and 0.",
    "interviewTip": "Difference vs ===."
  },
  "js-adv-13": {
    "prompt": "What is memoization?",
    "explanation": "Performance optimization.",
    "interviewTip": "Pure functions."
  },
  "js-adv-14": {
    "prompt": "What happens?",
    "explanation": "true → 1 < 3.",
    "interviewTip": "Comparison coercion."
  },
  "js-adv-15": {
    "prompt": "What is a pure function?",
    "explanation": "Deterministic behavior.",
    "interviewTip": "Functional programming."
  },
  "js-adv-16": {
    "prompt": "What does TDZ mean?",
    "explanation": "Temporal Dead Zone.",
    "interviewTip": "let/const."
  },
  "js-adv-17": {
    "prompt": "Which is NOT hoisted?",
    "explanation": "Function expressions are not hoisted.",
    "interviewTip": "Execution order."
  },
  "js-adv-18": {
    "prompt": "What is throttling best for?",
    "explanation": "Limit execution frequency.",
    "interviewTip": "UX optimization."
  },
  "js-adv-19": {
    "prompt": "What does bind return?",
    "explanation": "bind returns a new function.",
    "interviewTip": "Does not execute."
  },
  "js-adv-20": {
    "prompt": "What happens?",
    "explanation": "Arrow returns undefined.",
    "interviewTip": "Implicit return."
  },
  "js-adv-21": {
    "prompt": "Why debounce is useful?",
    "explanation": "Reduces unnecessary executions.",
    "interviewTip": "Search inputs."
  },
  "js-adv-22": {
    "prompt": "What is partial application?",
    "explanation": "Pre-filling arguments.",
    "interviewTip": "Diff vs currying."
  },
  "js-adv-23": {
    "prompt": "Which breaks referential transparency?",
    "explanation": "Mutation causes side effects.",
    "interviewTip": "Functional design."
  },
  "js-adv-24": {
    "prompt": "What does call do?",
    "explanation": "call invokes immediately.",
    "interviewTip": "apply vs bind."
  },
  "js-adv-25": {
    "prompt": "Senior-level advice?",
    "explanation": "Thinking matters more than speed.",
    "interviewTip": "Interview mindset."
  }
}
