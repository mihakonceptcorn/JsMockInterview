{
  "js-br-01": {
    "prompt": "¿Cuál es el primer paso en el rendering pipeline?",
    "explanation": "El HTML se parsea primero para construir el DOM.",
    "interviewTip": "Inicio del critical render path.",
    "options": ["Parsing de HTML", "Parsing de CSS", "Layout", "Paint"]
  },
  "js-br-02": {
    "prompt": "¿Qué se crea al parsear el CSS?",
    "explanation": "El CSSOM representa el CSS parseado.",
    "interviewTip": "DOM + CSSOM = Render Tree.",
    "options": ["CSSOM", "DOM", "Render Tree", "Layer Tree"]
  },
  "js-br-03": {
    "prompt": "¿Qué contiene el render tree?",
    "explanation": "Los nodos ocultos están excluidos.",
    "interviewTip": "Los nodos con display:none se omiten.",
    "options": [
      "Nodos visibles con estilos",
      "Todos los nodos del DOM",
      "Solo nodos de texto",
      "Solo información de layout"
    ]
  },
  "js-br-04": {
    "prompt": "¿Qué es el layout (reflow)?",
    "explanation": "El layout calcula la geometría.",
    "interviewTip": "Es un paso muy costoso.",
    "options": [
      "Calcular tamaños y posiciones de elementos",
      "Dibujar píxeles",
      "Aplicar estilos",
      "Ejecutar JS"
    ]
  },
  "js-br-05": {
    "prompt": "¿Qué dispara un reflow?",
    "explanation": "Los cambios de geometría requieren un reflow.",
    "interviewTip": "Evita el layout thrashing.",
    "options": [
      "Cambiar width o height",
      "Cambiar color",
      "Cambiar opacity",
      "Cambiar visibility"
    ]
  },
  "js-br-06": {
    "prompt": "¿Qué es el repaint?",
    "explanation": "Actualizaciones puramente visuales.",
    "interviewTip": "Es más barato que el reflow.",
    "options": [
      "Redibujar píxeles sin afectar el layout",
      "Recalcular el layout",
      "Reconstruir el DOM",
      "Ejecutar JS"
    ]
  },
  "js-br-07": {
    "prompt": "¿Qué propiedad CSS evita el reflow y el repaint?",
    "explanation": "Las transforms solo afectan al compositor.",
    "interviewTip": "Truco clave para animaciones.",
    "options": ["transform", "width", "top", "margin"]
  },
  "js-br-08": {
    "prompt": "¿Qué es el compositing?",
    "explanation": "Paso final antes de mostrar la imagen.",
    "interviewTip": "Acelerado por GPU.",
    "options": [
      "Combinar capas en la imagen final",
      "Parsear CSS",
      "Calcular layout",
      "Ejecutar JS"
    ]
  },
  "js-br-09": {
    "prompt": "¿Qué propiedades suelen estar aceleradas por GPU?",
    "explanation": "Estas propiedades saltan el paso de layout.",
    "interviewTip": "Animaciones fluidas.",
    "options": [
      "transform y opacity",
      "width y height",
      "top y left",
      "margin y padding"
    ]
  },
  "js-br-10": {
    "prompt": "¿Qué causa el layout thrashing?",
    "explanation": "Fuerza un layout síncrono.",
    "interviewTip": "Bug de rendimiento clásico.",
    "options": [
      "Leer el layout después de escribir estilos",
      "Agrupar (batching) actualizaciones del DOM",
      "Usar rAF",
      "Usar transforms"
    ]
  },
  "js-br-11": {
    "prompt": "¿Qué es el forced synchronous layout?",
    "explanation": "Se dispara al leer propiedades de layout.",
    "interviewTip": "Evita leer offsetHeight después de escribir.",
    "options": [
      "Recálculo inmediato del layout",
      "Layout diferido",
      "Renderizado asíncrono",
      "GPU compositing"
    ]
  },
  "js-br-12": {
    "prompt": "¿Cuándo se ejecuta requestAnimationFrame?",
    "explanation": "Callback sincronizado con el frame.",
    "interviewTip": "Úsalo para animaciones.",
    "options": [
      "Antes del próximo repaint",
      "Después del repaint",
      "Como microtask",
      "Como macrotask"
    ]
  },
  "js-br-13": {
    "prompt": "¿Qué es una render layer?",
    "explanation": "Se utiliza en el compositing.",
    "interviewTip": "Demasiadas capas consumen mucha memoria.",
    "options": [
      "Elemento promovido para compositing",
      "Nodo del DOM",
      "Regla CSS",
      "Objeto JS"
    ]
  },
  "js-br-14": {
    "prompt": "¿Qué promueve un elemento a su propia capa?",
    "explanation": "Informa al navegador para optimizar.",
    "interviewTip": "Usa will-change con moderación.",
    "options": [
      "transform o will-change",
      "cambio de color",
      "font-size",
      "cambio de margin"
    ]
  },
  "js-br-15": {
    "prompt": "¿Qué es el critical render path?",
    "explanation": "Desde el HTML hasta los píxeles.",
    "interviewTip": "Optimiza para el FCP.",
    "options": [
      "Pasos hasta el primer pintado",
      "Orden de ejecución de JS",
      "Ciclo del event loop",
      "Network waterfall"
    ]
  },
  "js-br-16": {
    "prompt": "¿Por qué incluir el CSS crítico inline?",
    "explanation": "El CSS bloquea el renderizado.",
    "interviewTip": "Optimización común.",
    "options": [
      "Evitar el render blocking",
      "Reducir tamaño del bundle",
      "Mejorar el caching",
      "Reducir JS"
    ]
  },
  "js-br-17": {
    "prompt": "¿Qué métrica mide la estabilidad del layout?",
    "explanation": "Cumulative Layout Shift.",
    "interviewTip": "Web Vitals.",
    "options": ["CLS", "FCP", "LCP", "TTFB"]
  },
  "js-br-18": {
    "prompt": "¿Qué métrica refleja mejor el rendimiento de renderizado?",
    "explanation": "Largest Contentful Paint.",
    "interviewTip": "Centrada en el usuario.",
    "options": ["LCP", "TTFB", "DNS", "Uso de CPU"]
  },
  "js-br-19": {
    "prompt": "¿Qué bloquea el primer pintado (first paint)?",
    "explanation": "El CSS debe parsearse primero.",
    "interviewTip": "CSS crítico de nuevo.",
    "options": [
      "CSS que bloquea el renderizado",
      "Imágenes",
      "JS asíncrono",
      "Fuentes siempre"
    ]
  },
  "js-br-20": {
    "prompt": "¿Para qué se usa el paint flashing?",
    "explanation": "Función de las DevTools.",
    "interviewTip": "Ayuda a optimizar la UI.",
    "options": [
      "Depurar áreas de repaint",
      "Medir FPS",
      "Detectar fugas",
      "Perfilado de JS"
    ]
  },
  "js-br-21": {
    "prompt": "¿Qué sucede si JS bloquea el thread principal?",
    "explanation": "El renderizado es single-threaded.",
    "interviewTip": "Divide el trabajo de JS.",
    "options": [
      "El renderizado se pausa",
      "El CSS continúa",
      "La red se detiene",
      "La GPU falla"
    ]
  },
  "js-br-22": {
    "prompt": "¿Por qué evitar árboles DOM grandes?",
    "explanation": "El coste del layout aumenta.",
    "interviewTip": "La virtualización ayuda.",
    "options": [
      "Layout y paint más lentos",
      "Más errores de JS",
      "Sobrecarga de red",
      "Fugas de memoria"
    ]
  },
  "js-br-23": {
    "prompt": "¿Qué herramienta analiza el renderizado?",
    "explanation": "Muestra los frames y el pintado.",
    "interviewTip": "Aprende a leer flame charts.",
    "options": [
      "Pestaña Performance de Chrome DevTools",
      "Consola",
      "Pestaña Network",
      "Lighthouse SEO"
    ]
  },
  "js-br-24": {
    "prompt": "¿Cuál es el presupuesto de tiempo por frame a 60fps?",
    "explanation": "1000ms / 60 ≈ 16ms.",
    "interviewTip": "Incluye JS + renderizado.",
    "options": ["~16ms", "~8ms", "~32ms", "~60ms"]
  },
  "js-br-25": {
    "prompt": "¿Regla de oro de la optimización de renderizado?",
    "explanation": "Optimización basada en datos.",
    "interviewTip": "Respuesta de nivel Senior.",
    "options": [
      "Medir, luego optimizar",
      "Usar GPU en todas partes",
      "Evitar CSS",
      "Evitar el DOM"
    ]
  }
}
