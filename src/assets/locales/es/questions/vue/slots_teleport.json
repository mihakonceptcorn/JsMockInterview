{
  "sl-01": {
    "prompt": "¿Cuál es el propósito del elemento <slot> en un componente hijo?",
    "explanation": "Los slots actúan como marcadores de posición. Cualquier contenido que el padre coloque entre las etiquetas del componente hijo reemplazará la etiqueta <slot> en el renderizado final.",
    "interviewTip": "El contenido dentro de los slots tiene acceso al scope de datos del padre, no del hijo (a menos que se usen Scoped Slots).",
    "options": [
      "Para definir un lugar donde el padre puede inyectar su propio HTML o componentes.",
      "Para crear un nuevo estado reactivo.",
      "Para teletransportar el componente al footer.",
      "Para vincular el componente a un archivo CSS externo."
    ]
  },
  "sl-02": {
    "prompt": "Analiza el código. ¿Cómo pasas contenido específicamente al slot 'header'?",
    "explanation": "v-slot:header es la sintaxis completa, y #header es la abreviatura. Ambos se usan en una etiqueta <template> dentro del padre para apuntar a un slot nombrado.",
    "interviewTip": "Los slots nombrados son esenciales para construir componentes de diseño (como Cards o Page Shells).",
    "options": [
      "<template #header>",
      "<template v-slot:header>",
      "Ambos de arriba son correctos.",
      "<header-slot>"
    ]
  },
  "sl-03": {
    "prompt": "¿Para qué se usan los 'Scoped Slots'?",
    "explanation": "Los scoped slots permiten que un hijo proporcione datos al contenido inyectado por el padre. Por ejemplo, un componente List que proporciona datos individuales de 'item' a una plantilla de fila personalizada proporcionada por el padre.",
    "interviewTip": "Este es un patrón de alto nivel para crear componentes flexibles y reutilizables como Data Tables.",
    "options": [
      "Para prevenir que el CSS se filtre fuera del slot.",
      "Para permitir que el componente hijo pase datos 'hacia arriba' al contenido del slot del padre.",
      "Para hacer el contenido del slot privado al componente.",
      "Para traducir automáticamente el texto en el slot."
    ]
  },
  "sl-04": {
    "prompt": "Analiza el código. ¿Qué le pasará al componente 'Modal' en el DOM?",
    "explanation": "Teleport permite mantener la posición lógica del componente (props/state) en el árbol de Vue mientras lo renderiza en otro lugar en el DOM HTML.",
    "interviewTip": "Esta es la forma 'correcta' de manejar Modals/Dialogs para evitar problemas de `z-index` y `overflow: hidden` de contenedores padres.",
    "options": [
      "Se renderizará dentro del div del componente actual.",
      "Se moverá físicamente en el DOM y se renderizará como hijo directo de la etiqueta <body>.",
      "Estará oculto hasta que el usuario haga clic en 'body'.",
      "Vue lanzará un error si 'body' no es un componente Vue."
    ]
  },
  "sl-05": {
    "prompt": "¿Cómo proporcionas contenido 'fallback' que solo se muestre si el padre no proporciona ningún contenido de slot?",
    "explanation": "Cualquier contenido colocado entre <slot> y </slot> en el componente hijo sirve como contenido predeterminado si el padre deja las etiquetas vacías.",
    "interviewTip": "Esto es genial para botones donde quieres una etiqueta predeterminada 'Submit' pero permitir personalización.",
    "options": [
      "v-else=\"default\"",
      "Simplemente coloca texto/etiquetas dentro de las etiquetas <slot>.",
      "Usando la prop 'fallback'.",
      "Vue no soporta contenido fallback."
    ]
  },
  "sl-06": {
    "prompt": "¿Cuáles de las siguientes afirmaciones sobre <Teleport> son verdaderas?",
    "explanation": "Los objetivos de Teleport pueden ser selectores CSS (como '#app', '.container', o 'body'). Aunque el DOM se mueve, el árbol lógico de Vue permanece intacto.",
    "interviewTip": "Confirma que Teleport no rompe el 'flujo de datos unidireccional' o la propagación de eventos en el árbol de Vue.",
    "options": [
      "El objetivo 'to' debe existir en el DOM antes de que el componente sea montado.",
      "Las props y eventos aún funcionan normalmente a través de la jerarquía de componentes de Vue.",
      "Solo puede teletransportarse a IDs, no a nombres de etiquetas.",
      "Múltiples Teleports pueden mover contenido al mismo objetivo."
    ]
  },
  "sl-07": {
    "prompt": "Analiza la sintaxis de Scoped Slot. ¿Cómo accede el padre a los datos del hijo?",
    "explanation": "El valor de v-slot (aquí 'slotProps') es un objeto que contiene todas las props pasadas al slot desde el hijo. También puedes desestructurarlo: v-slot=\"{ user }\".",
    "interviewTip": "Desestructurar las props de scoped slots es práctica estándar para templates más limpios.",
    "options": ["v-data", "slotProps", "props", "defineProps"]
  },
  "sl-08": {
    "prompt": "¿Qué sucede con el estado de un componente dentro de <Teleport> si está deshabilitado?",
    "explanation": "Teleport tiene una prop 'disabled'. Esto es útil para cosas como una ventana 'PIP' (Picture-in-Picture) que podría alternar entre estar en el diseño o flotante.",
    "interviewTip": "Mencionar la prop 'disabled' muestra que has leído la documentación avanzada de Teleport.",
    "options": [
      "El estado se pierde.",
      "El componente se desmonta.",
      "Teleport no tiene una prop 'disabled'; siempre teletransporta.",
      "Si :disabled=\"true\", el contenido se renderiza en su ubicación original en lugar del objetivo."
    ]
  },
  "st-09": {
    "prompt": "¿Cuál es el propósito del componente <Teleport> en Vue 3?",
    "explanation": "Teleport es útil para modales, toasts o tooltips que necesitan ser renderizados a nivel del body del documento para evitar problemas de z-index u overflow.",
    "interviewTip": "Teleport se llamaba Portal en el RFC pero fue renombrado antes del lanzamiento de Vue 3.",
    "options": [
      "Para mover datos entre componentes.",
      "Para renderizar el template de un componente en una parte diferente del árbol DOM, fuera de su jerarquía padre.",
      "Para hacer lazy-load de componentes.",
      "Para crear portales a otras páginas."
    ]
  },
  "st-10": {
    "prompt": "¿Cómo accedes al contenido del slot en el componente padre?",
    "explanation": "Los scoped slots permiten que los componentes hijos pasen datos de vuelta al contenido del slot del padre, habilitando patrones poderosos como componentes renderless.",
    "interviewTip": "Los scoped slots son la base de muchas bibliotecas de UI de Vue para máxima flexibilidad.",
    "options": [
      "Los slots son solo de una vía; no puedes acceder a ellos desde el padre.",
      "Usa scoped slots para pasar datos del hijo al padre.",
      "Usa la propiedad $slots.",
      "Usa v-model."
    ]
  }
}
