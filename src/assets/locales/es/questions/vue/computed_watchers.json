{
  "cw-01": {
    "prompt": "What is the primary advantage of using a 'computed' property over a regular 'method' in a template?",
    "explanation": "Caching is the killer feature. If you have an expensive calculation in a computed property, it will only run once and reuse that result until its source data changes. Methods run every time the component re-renders.",
    "interviewTip": "Use computed for data transformation (getters) and methods for event handling or actions."
  },
  "cw-02": {
    "prompt": "Analyze the code. How many times will 'Calculating...' be logged if the component re-renders 5 times, but 'count' never changes?",
    "explanation": "Because of caching, the computed function only executes once. As long as 'count' is the same, Vue returns the stored value immediately.",
    "interviewTip": "Computed properties are 'lazy'. If they aren't used in a template or another effect, they don't even run once!"
  },
  "cw-03": {
    "prompt": "When should you use a 'watcher' (watch) instead of a 'computed' property?",
    "explanation": "Computed properties must be 'pure' (no side effects) and return a value. Watchers are designed to execute logic (like saving to localStorage or fetching data) when a value changes.",
    "interviewTip": "Rule of thumb: Computed = Getters; Watchers = Side Effects."
  },
  "cw-04": {
    "prompt": "How do you make a watcher trigger immediately upon component creation, rather than waiting for the first change?",
    "explanation": "The 'immediate: true' option forces the watcher callback to run once with the initial value right when the watcher is initialized.",
    "interviewTip": "This is very useful for fetching data based on a prop as soon as the component mounts."
  },
  "cw-05": {
    "prompt": "What does the 'deep: true' option do in a watcher?",
    "explanation": "By default, watchers only track 'shallow' changes (the reference of the object). 'deep' recursively traverses the object to catch changes in sub-properties.",
    "interviewTip": "Warning: Deep watching large objects can be very expensive for performance."
  },
  "cw-06": {
    "prompt": "Analyze the code. Why is the watcher NOT triggering when 'user.name' changes?",
    "explanation": "When watching a 'ref' containing an object, the watcher is triggered only if the entire object is replaced. Internal property changes are ignored unless 'deep' is used or you watch a getter: `() => user.value.name`.",
    "interviewTip": "In Vue 3, watching a 'reactive' object automatically creates a deep watcher, but watching a 'ref' does not."
  },
  "cw-07": {
    "prompt": "Which of these are valid ways to create a 'Writable Computed' property (getter and setter)?",
    "explanation": "While most computed properties are getters, you can provide a setter to handle updates (e.g., parsing a 'fullName' string into 'firstName' and 'lastName').",
    "interviewTip": "Writable computed properties are excellent for wrapping state management (like Pinia) into a clean v-model."
  },
  "cw-08": {
    "prompt": "What is the difference between 'watch' and 'watchEffect'?",
    "explanation": "watchEffect is more concise because you don't list dependencies; it 'discovers' them during execution. However, 'watch' is more precise and gives you access to 'oldValue'.",
    "interviewTip": "Use 'watch' if you need the previous value; use 'watchEffect' for simpler dependency tracking."
  },
  "cw-09": {
    "prompt": "What is the difference between a computed property and a method in Vue?",
    "explanation": "Computed properties are only re-evaluated when their dependencies change. Methods run on every render, making them less efficient for expensive operations.",
    "interviewTip": "Use computed for derived state, methods for actions or when you need to pass arguments."
  },
  "cw-10": {
    "prompt": "When should you use a watcher with the `immediate: true` option?",
    "explanation": "By default, watchers only run when the watched value changes. `immediate: true` makes the callback run once immediately with the current value.",
    "interviewTip": "This is useful for initializing data based on props or performing initial API calls."
  }
}
