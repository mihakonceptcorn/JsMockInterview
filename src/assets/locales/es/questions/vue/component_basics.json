{
  "cb-01": {
    "prompt": "En Vue, ¿cuál es el principio de 'One-Way Data Flow' con respecto a las props?",
    "explanation": "Esto evita que los componentes hijos muten accidentalmente el estado del padre, lo que haría que el flujo de datos sea difícil de entender y depurar.",
    "interviewTip": "Si intentas mutar una prop en un hijo, Vue lanzará una advertencia en la consola. Si necesitas cambiarla, usa un 'ref' local o emite un evento.",
    "options": [
      "Las props solo pueden pasarse a componentes padres, nunca a hijos.",
      "Un componente hijo no debe mutar una prop directamente; en su lugar, debe emitir un evento para pedirle al padre que cambie los datos.",
      "Los datos solo pueden fluir a través de un gestor de estado central como Pinia.",
      "Las props se sincronizan automáticamente en ambas direcciones entre padre e hijo."
    ]
  },
  "cb-02": {
    "prompt": "Analiza el código. ¿Cómo notifica el componente hijo al padre que se hizo clic en un botón?",
    "explanation": "Los eventos personalizados usan la sintaxis v-on (o @) igual que los eventos nativos del DOM. El padre escucha el nombre del evento definido en la llamada $emit del hijo.",
    "interviewTip": "Vue 3 recomienda declarar los eventos emitidos usando la opción 'emits' o 'defineEmits' para una mejor documentación y validación.",
    "options": [
      ":custom-event",
      "@custom-event",
      "v-model:custom-event",
      "on-custom-event"
    ]
  },
  "cb-03": {
    "prompt": "¿Cómo defines props con validación en un componente Vue 3 con <script setup>?",
    "explanation": "defineProps es una macro del compilador disponible dentro de <script setup>. No necesita importarse y permite la validación en tiempo de ejecución de los datos pasados.",
    "interviewTip": "La validación de props es tu primera línea de defensa contra errores en equipos grandes. Siempre usa la sintaxis de objeto para las props en lugar de arrays.",
    "options": ["useProps", "defineProps", "setProps", "injectProps"]
  },
  "cb-04": {
    "prompt": "¿Qué son los 'Fallthrough Attributes' en Vue 3?",
    "explanation": "Si un componente tiene un único elemento raíz, los atributos que se le pasan (que no están declarados como props) 'se trasladan' ('fall through') a ese elemento raíz.",
    "interviewTip": "Puedes desactivar este comportamiento estableciendo 'inheritAttrs: false' y vinculando manualmente los atributos usando '$attrs'.",
    "options": [
      "Atributos como 'class', 'style' e 'id' pasados a un componente que se aplican automáticamente al elemento raíz del componente.",
      "Un error donde las props se filtran accidentalmente al ámbito global.",
      "Variables que evaden el Virtual DOM.",
      "Una forma de pasar props directamente a nietos."
    ]
  },
  "cb-05": {
    "prompt": "Analiza el código. ¿Cuál es la forma correcta para que el padre pase un valor numérico dinámico al hijo?",
    "explanation": "Sin los dos puntos (:), '42' se pasa como una cadena estática. Con los dos puntos (:), se evalúa como una expresión JavaScript, pasándolo como número.",
    "interviewTip": "Este es un error común de principiantes. Usa v-bind (:) para cualquier valor que no sea una cadena literal.",
    "options": ["count", ":count", "v-bind.count", "count.number"]
  },
  "cb-06": {
    "prompt": "¿Cuáles de las siguientes son formas válidas de comunicarse entre componentes que NO están en una relación directa padre-hijo?",
    "explanation": "Provide/Inject es excelente para evitar el 'Prop Drilling'. Pinia es para estado global. La mutación directa de $parent está muy desaconsejada porque crea un acoplamiento fuerte.",
    "interviewTip": "Menciona Provide/Inject como el equivalente en Vue al Context API de React.",
    "options": [
      "Provide / Inject (Inyección de dependencias)",
      "Gestión de estado global (Pinia)",
      "Un Event Bus externo (usando una librería como mitt)",
      "Mutar directamente 'this.$parent'"
    ]
  },
  "cb-07": {
    "prompt": "¿Qué pasa si un hijo emite un evento pero el padre no está escuchándolo?",
    "explanation": "A diferencia de los eventos del DOM, los eventos personalizados de Vue no hacen 'bubble' por defecto. Si no hay un listener en el padre inmediato, el evento simplemente se pierde.",
    "interviewTip": "Por eso, al depurar eventos que no llegan, lo primero suele ser verificar la ortografía del nombre del evento en el @listener.",
    "options": [
      "Vue lanzará un error en tiempo de ejecución.",
      "El evento se ignora y no pasa nada.",
      "El evento sube hasta el objeto 'window'.",
      "La aplicación se cae (crashea)."
    ]
  },
  "cb-08": {
    "prompt": "Analiza el código. ¿Por qué se usa 'defineEmits' aquí?",
    "explanation": "Usar defineEmits hace que el 'contrato' de tu componente sea explícito, ayudando a los desarrolladores (y a los IDEs) a entender cómo interactuar con él.",
    "interviewTip": "En TypeScript, incluso puedes definir los tipos de los argumentos pasados con el evento usando defineEmits<{ (e: 'change', id: number): void }>.",
    "options": [
      "Para registrar el componente en el ámbito global.",
      "Para proporcionar seguridad de tipos y documentación sobre los eventos que este componente puede emitir.",
      "Para permitir que el componente reciba datos del padre.",
      "Para estilizar los botones del componente."
    ]
  },
  "cb-09": {
    "prompt": "¿Cuál es el propósito del atributo `key` al renderizar listas en Vue?",
    "explanation": "Las keys le dan a Vue una pista sobre la identidad de cada nodo. Sin keys, Vue usa un algoritmo que minimiza el movimiento de elementos pero puede causar problemas con componentes con estado o transiciones.",
    "interviewTip": "Siempre usa keys únicas y estables (como IDs) en lugar de índices de array para listas dinámicas.",
    "options": [
      "Para encriptar los datos del componente.",
      "Para ayudar a Vue a identificar qué elementos han cambiado, sido añadidos o eliminados para actualizaciones eficientes del DOM.",
      "Para establecer el ID del componente.",
      "Para mejorar el estilo CSS."
    ]
  },
  "cb-10": {
    "prompt": "¿Cómo emites un evento personalizado desde un componente hijo hacia su padre en Vue 3?",
    "explanation": "En <script setup>, usas defineEmits para declarar eventos y luego llamas a emit con el nombre del evento y un payload opcional.",
    "interviewTip": "Vue 3 fomenta las declaraciones explícitas de eventos para una mejor seguridad de tipos y documentación.",
    "options": [
      "'update'",
      "\"update\", newValue",
      "update",
      "$emit(\"update\")"
    ]
  }
}
