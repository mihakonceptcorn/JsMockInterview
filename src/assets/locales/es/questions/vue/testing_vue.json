{
  "tv-01": {
    "prompt": "Which tool is currently recommended by the Vue team as the primary test runner, replacing Jest in most modern setups?",
    "explanation": "Vitest is built on top of Vite. It is extremely fast, shares the same configuration as your development environment, and has a Jest-compatible API.",
    "interviewTip": "Highlight Vitest's 'Hot Module Replacement' (HMR) for tests, which makes the TDD (Test Driven Development) cycle feel much faster.",
    "options": [
      "Mocha",
      "Vitest",
      "Cypress",
      "Jasmine"
    ]
  },
  "tv-02": {
    "prompt": "What is the difference between 'mount' and 'shallowMount' in Vue Test Utils?",
    "explanation": "shallowMount is ideal for unit testing because it isolates the component from its children, ensuring that a bug in a child component doesn't cause the parent's test to fail.",
    "interviewTip": "Use 'mount' for integration tests and 'shallowMount' for pure unit tests of a single component's logic.",
    "options": [
      "mount is for Vue 3, shallowMount is for Vue 2.",
      "mount renders the component and all its children; shallowMount renders only the component, stubbing out all child components.",
      "shallowMount is only for testing CSS.",
      "mount is faster than shallowMount."
    ]
  },
  "tv-03": {
    "prompt": "Analyze the code. How do you simulate a user clicking a button in a Vitest test?",
    "explanation": "The 'trigger' method simulates a DOM event. Because Vue updates the DOM asynchronously, you should 'await' the trigger to ensure the DOM has updated before making assertions.",
    "interviewTip": "Always await 'trigger' and 'setValue' to avoid flaky tests caused by Vue's async rendering.",
    "options": [
      "button.click()",
      "button.trigger('click')",
      "button.emit('click')",
      "button.fire('click')"
    ]
  },
  "tv-04": {
    "prompt": "Analyze the code. How do you verify that a component emitted a specific event?",
    "explanation": "wrapper.emitted() returns an object containing all events emitted by the component and the arguments passed with them.",
    "interviewTip": "You can check the arguments like this: expect(wrapper.emitted().myEvent[0]).toEqual(['expectedData']).",
    "options": [
      "emitted().myEvent",
      "events('myEvent')",
      "fired('myEvent')",
      "getEvent('myEvent')"
    ]
  },
  "tv-05": {
    "prompt": "How do you test a component that depends on a global plugin like 'Pinia' or 'Vue Router'?",
    "explanation": "Vue Test Utils allows you to provide 'mocks' or 'stubs' for global features using the 'global' property in the second argument of mount().",
    "interviewTip": "For Pinia, it is best to use 'createTestingPinia()', which automatically mocks all your actions.",
    "options": [
      "You cannot test these components.",
      "By passing a 'global.plugins' array in the mounting options.",
      "By importing the real router into the test file.",
      "By hardcoding the data inside the component."
    ]
  },
  "tv-06": {
    "prompt": "Which of these are valid ways to find an element using Vue Test Utils 'find' or 'get'?",
    "explanation": "find() supports CSS selectors and component definitions. It is a best practice to use 'data-testid' for tests to decouple them from CSS classes or HTML structure.",
    "interviewTip": "Explain that 'get' throws an error if the element is not found, while 'find' returns an empty wrapper, making 'get' safer for assertions.",
    "options": [
      "wrapper.find('.my-class')",
      "wrapper.findComponent(MyChildComponent)",
      "wrapper.find({ ref: 'myRef' })",
      "wrapper.find('[data-testid=\"submit\"]')"
    ]
  },
  "tv-07": {
    "prompt": "What is 'Snapshot Testing' in Vitest?",
    "explanation": "Snapshots catch regression in the HTML structure. If you change a class name, the snapshot will fail, forcing you to verify if the change was intentional.",
    "interviewTip": "Warn that snapshots can be 'brittle' if your UI changes frequently; use them sparingly for stable components.",
    "options": [
      "Taking a screenshot of the app's UI.",
      "Comparing the rendered HTML output of a component against a previously saved 'master' version to detect unexpected changes.",
      "Testing the app's speed.",
      "A way to store user passwords."
    ]
  },
  "tv-08": {
    "prompt": "How do you test code that uses 'nextTick()'?",
    "explanation": "Since nextTick returns a promise, awaiting it in your test ensures that you are inspecting the DOM after Vue has completed its reactive update cycle.",
    "interviewTip": "This is crucial for testing components that change their DOM structure based on a reactive state change.",
    "options": [
      "Using a while loop.",
      "By awaiting 'nextTick()' inside your test function.",
      "Vitest handles nextTick automatically.",
      "You must use a setTimeout of 1000ms."
    ]
  },
  "tv-09": {
    "prompt": "What is the recommended testing library for Vue 3 components?",
    "explanation": "Vue Test Utils is the official testing utility library for Vue, providing methods to mount components and interact with them in tests.",
    "interviewTip": "Combine Vue Test Utils with Jest or Vitest for a complete testing solution.",
    "options": [
      "Enzyme",
      "Vue Test Utils",
      "React Testing Library",
      "Jasmine"
    ]
  },
  "tv-10": {
    "prompt": "What is the difference between shallow and full mounting in Vue Test Utils?",
    "explanation": "Shallow mounting (shallowMount) is useful for unit testing a component in isolation, while full mounting (mount) is better for integration tests.",
    "interviewTip": "Vue Test Utils v2 (for Vue 3) recommends using mount more often as shallow mounting can hide integration issues.",
    "options": [
      "Shallow mounting renders only the component, stubbing child components; full mounting renders the entire component tree.",
      "Shallow mounting is faster but less accurate.",
      "Full mounting is deprecated.",
      "There is no difference."
    ]
  }
}