{
  "perf-v-01": {
    "prompt": "Which directive should be used for content that never changes after the initial render to skip Virtual DOM tracking and patching?",
    "explanation": "v-once treats the element and its children as static content. Once rendered, Vue skips it entirely during update cycles, reducing the work of the Virtual DOM.",
    "interviewTip": "Use v-once for static help text or icons inside heavy components.",
    "options": [
      "v-memo",
      "v-once",
      "v-static",
      "v-pre"
    ]
  },
  "perf-v-02": {
    "prompt": "Analyze the code. What is the benefit of using 'v-memo' here?",
    "explanation": "v-memo (Vue 3.2+) memoizes a sub-tree of the template. It only updates if the dependencies in the array change. This is a massive optimization for large lists where only one item changes at a time.",
    "interviewTip": "v-memo is essentially 'React.memo' but for a specific piece of a template.",
    "options": [
      "It prevents the item from ever being deleted.",
      "It only re-renders the specific item if its 'selected' state changes, even if other properties in the 'item' object change.",
      "It automatically saves the list to LocalStorage.",
      "It converts the div into a canvas element for faster drawing."
    ]
  },
  "perf-v-03": {
    "prompt": "How does 'shallowRef' help with performance when dealing with massive objects (e.g., a huge JSON response)?",
    "explanation": "Standard 'ref' is deep. For a list of 10,000 items, Vue has to set up thousands of Proxies. 'shallowRef' avoids this overhead, only triggering an update if you replace the entire object.",
    "interviewTip": "This is the go-to solution for integrating large third-party instances (like OpenLayers or Three.js) into Vue.",
    "options": [
      "It compresses the object in memory.",
      "It only makes the .value property reactive and does not recursively make all nested properties reactive.",
      "It moves the object to a Web Worker.",
      "It prevents the object from being garbage collected."
    ]
  },
  "perf-v-04": {
    "prompt": "Analyze the code. Why might this 'computed' property cause performance issues?",
    "explanation": "Computed caching only works if the result is accessed again *without* the dependency changing. If the source data is a stream or updates rapidly, you are performing a heavy sort 60 times a second.",
    "interviewTip": "Consider debouncing the input data or moving the sort to a Web Worker if the calculation is too heavy.",
    "options": [
      "Computed properties should not return arrays.",
      "If 'heavyData' changes frequently, the expensive sort runs on every update, potentially blocking the main thread.",
      "Computed properties cannot use spread syntax.",
      "The code is perfectly optimized as is."
    ]
  },
  "perf-v-05": {
    "prompt": "Which of the following are 'Tree Shaking' friendly practices in Vue 3?",
    "explanation": "Tree shaking allows the bundler to remove unused Vue features from your final JS file. Vue 3 was rewritten to be modular specifically for this reason.",
    "interviewTip": "Mention that Vue 3's core is 'tree-shakable,' meaning if you don't use `<Transition>`, it won't be in your final bundle.",
    "options": [
      "Using the Composition API (importing only what you need).",
      "Using the Options API exclusively.",
      "Avoiding the use of global 'Vue.prototype' (Vue 2 style).",
      "Using 'defineAsyncComponent' for large modules."
    ]
  },
  "perf-v-06": {
    "prompt": "What is the purpose of the 'markRaw' utility?",
    "explanation": "Some objects (like complex class instances or React components being used inside Vue) should not be reactive. markRaw tags them so Vue ignores them, saving performance.",
    "interviewTip": "This is vital when wrapping external libraries that have their own internal state management.",
    "options": [
      "To make a variable accessible in the console.",
      "To explicitly prevent an object from ever being converted into a reactive proxy.",
      "To color-code the object in DevTools.",
      "To convert an object into a string."
    ]
  },
  "perf-v-07": {
    "prompt": "Analyze the code. Which directive is better for a component that toggles visibility 100 times per minute?",
    "explanation": "v-show only toggles CSS 'display: none'. v-if would destroy and re-create the component 100 times, which is very CPU intensive.",
    "interviewTip": "Always relate the choice to 'Initialization cost' vs 'Runtime cost'.",
    "options": [
      "v-if",
      "v-show",
      "v-once",
      "v-cloak"
    ]
  },
  "perf-v-08": {
    "prompt": "What is 'Virtual List Rendering' (or Windowing)?",
    "explanation": "If you have 10,000 items, rendering 10,000 DOM nodes will crash the browser. Virtual lists only render the ~10 items the user actually sees.",
    "interviewTip": "Mention libraries like `vue-virtual-scroller` for high-performance lists.",
    "options": [
      "A list that only works on VR headsets.",
      "A technique where only the visible items in a long list are rendered in the DOM to save memory and CPU.",
      "Using v-for on a Virtual DOM node.",
      "A way to hide lists from the user."
    ]
  },
  "pov-09": {
    "prompt": "What is the purpose of v-memo directive in Vue 3?",
    "explanation": "v-memo is similar to React.memo but for templates. It's particularly useful for optimizing large v-for lists.",
    "interviewTip": "v-memo was introduced in Vue 3.2 and is most effective when combined with v-for.",
    "options": [
      "To memoize component methods.",
      "To memoize a template sub-tree and skip re-rendering if dependencies haven't changed.",
      "To improve memory usage.",
      "To cache API responses."
    ]
  },
  "pov-10": {
    "prompt": "How can you reduce the bundle size of a Vue application?",
    "explanation": "Code splitting through dynamic imports allows you to load only the code needed for the current route, reducing initial bundle size.",
    "interviewTip": "Combine with tree-shaking, proper build configuration, and analyzing bundle size with tools like webpack-bundle-analyzer.",
    "options": [
      "Use lazy loading for routes and components.",
      "Remove all comments from code.",
      "Use only inline styles.",
      "Avoid using components."
    ]
  }
}