{
  "perf-v-01": {
    "prompt": "¿Qué directiva debe usarse para contenido que nunca cambia después del renderizado inicial para omitir el seguimiento y parcheado del Virtual DOM?",
    "explanation": "v-once trata el elemento y sus hijos como contenido estático. Una vez renderizado, Vue lo omite por completo durante los ciclos de actualización, reduciendo el trabajo del Virtual DOM.",
    "interviewTip": "Usa v-once para texto de ayuda estático o iconos dentro de componentes pesados.",
    "options": ["v-memo", "v-once", "v-static", "v-pre"]
  },
  "perf-v-02": {
    "prompt": "Analiza el código. ¿Cuál es el beneficio de usar 'v-memo' aquí?",
    "explanation": "v-memo (Vue 3.2+) memoriza un sub-árbol del template. Solo se actualiza si las dependencias en el array cambian. Esta es una optimización masiva para listas grandes donde solo un elemento cambia a la vez.",
    "interviewTip": "v-memo es esencialmente 'React.memo' pero para una pieza específica de un template.",
    "options": [
      "Previene que el elemento sea eliminado alguna vez.",
      "Solo re-renderiza el elemento específico si su estado 'selected' cambia, incluso si otras propiedades en el objeto 'item' cambian.",
      "Guarda automáticamente la lista en LocalStorage.",
      "Convierte el div en un elemento canvas para un dibujado más rápido."
    ]
  },
  "perf-v-03": {
    "prompt": "¿Cómo ayuda 'shallowRef' con el rendimiento al tratar con objetos masivos (por ejemplo, una respuesta JSON enorme)?",
    "explanation": "El 'ref' estándar es profundo. Para una lista de 10,000 elementos, Vue tiene que configurar miles de Proxies. 'shallowRef' evita esta sobrecarga, solo activando una actualización si reemplazas el objeto completo.",
    "interviewTip": "Esta es la solución de referencia para integrar instancias grandes de terceros (como OpenLayers o Three.js) en Vue.",
    "options": [
      "Comprime el objeto en memoria.",
      "Solo hace reactiva la propiedad .value y no hace recursivamente reactivas todas las propiedades anidadas.",
      "Mueve el objeto a un Web Worker.",
      "Previene que el objeto sea recolectado por el garbage collector."
    ]
  },
  "perf-v-04": {
    "prompt": "Analiza el código. ¿Por qué esta propiedad 'computed' podría causar problemas de rendimiento?",
    "explanation": "El almacenamiento en caché de computed solo funciona si el resultado se accede nuevamente *sin* que la dependencia cambie. Si los datos de origen son un stream o se actualizan rápidamente, estás realizando una ordenación pesada 60 veces por segundo.",
    "interviewTip": "Considera hacer debounce de los datos de entrada o mover la ordenación a un Web Worker si el cálculo es demasiado pesado.",
    "options": [
      "Las propiedades computed no deben devolver arrays.",
      "Si 'heavyData' cambia frecuentemente, la ordenación costosa se ejecuta en cada actualización, potencialmente bloqueando el hilo principal.",
      "Las propiedades computed no pueden usar sintaxis spread.",
      "El código está perfectamente optimizado tal como está."
    ]
  },
  "perf-v-05": {
    "prompt": "¿Cuáles de las siguientes son prácticas amigables con 'Tree Shaking' en Vue 3?",
    "explanation": "Tree shaking permite al bundler eliminar características de Vue no usadas de tu archivo JS final. Vue 3 fue reescrito para ser modular específicamente por esta razón.",
    "interviewTip": "Menciona que el núcleo de Vue 3 es 'tree-shakable', lo que significa que si no usas `<Transition>`, no estará en tu bundle final.",
    "options": [
      "Usar la Composition API (importando solo lo que necesitas).",
      "Usar la Options API exclusivamente.",
      "Evitar el uso del 'Vue.prototype' global (estilo Vue 2).",
      "Usar 'defineAsyncComponent' para módulos grandes."
    ]
  },
  "perf-v-06": {
    "prompt": "¿Cuál es el propósito de la utilidad 'markRaw'?",
    "explanation": "Algunos objetos (como instancias de clases complejas o componentes React siendo usados dentro de Vue) no deberían ser reactivos. markRaw los etiqueta para que Vue los ignore, ahorrando rendimiento.",
    "interviewTip": "Esto es vital al envolver bibliotecas externas que tienen su propia gestión de estado interno.",
    "options": [
      "Para hacer una variable accesible en la consola.",
      "Para prevenir explícitamente que un objeto sea convertido en un proxy reactivo.",
      "Para codificar con colores el objeto en DevTools.",
      "Para convertir un objeto en un string."
    ]
  },
  "perf-v-07": {
    "prompt": "Analiza el código. ¿Qué directiva es mejor para un componente que alterna visibilidad 100 veces por minuto?",
    "explanation": "v-show solo alterna el CSS 'display: none'. v-if destruiría y recrearía el componente 100 veces, lo cual es muy intensivo para el CPU.",
    "interviewTip": "Siempre relaciona la elección con 'Costo de inicialización' vs 'Costo de tiempo de ejecución'.",
    "options": ["v-if", "v-show", "v-once", "v-cloak"]
  },
  "perf-v-08": {
    "prompt": "¿Qué es 'Virtual List Rendering' (o Windowing)?",
    "explanation": "Si tienes 10,000 elementos, renderizar 10,000 nodos del DOM hará que el navegador se bloquee. Las listas virtuales solo renderizan los ~10 elementos que el usuario realmente ve.",
    "interviewTip": "Menciona bibliotecas como `vue-virtual-scroller` para listas de alto rendimiento.",
    "options": [
      "Una lista que solo funciona en cascos VR.",
      "Una técnica donde solo los elementos visibles en una lista larga son renderizados en el DOM para ahorrar memoria y CPU.",
      "Usar v-for en un nodo del Virtual DOM.",
      "Una forma de ocultar listas del usuario."
    ]
  },
  "pov-09": {
    "prompt": "¿Cuál es el propósito de la directiva v-memo en Vue 3?",
    "explanation": "v-memo es similar a React.memo pero para templates. Es particularmente útil para optimizar listas grandes con v-for.",
    "interviewTip": "v-memo fue introducido en Vue 3.2 y es más efectivo cuando se combina con v-for.",
    "options": [
      "Para memorizar métodos de componentes.",
      "Para memorizar un sub-árbol de template y omitir el re-renderizado si las dependencias no han cambiado.",
      "Para mejorar el uso de memoria.",
      "Para cachear respuestas de API."
    ]
  },
  "pov-10": {
    "prompt": "¿Cómo puedes reducir el tamaño del bundle de una aplicación Vue?",
    "explanation": "La división de código a través de importaciones dinámicas te permite cargar solo el código necesario para la ruta actual, reduciendo el tamaño del bundle inicial.",
    "interviewTip": "Combina con tree-shaking, configuración de build adecuada, y análisis del tamaño del bundle con herramientas como webpack-bundle-analyzer.",
    "options": [
      "Usar lazy loading para rutas y componentes.",
      "Eliminar todos los comentarios del código.",
      "Usar solo estilos inline.",
      "Evitar usar componentes."
    ]
  }
}
