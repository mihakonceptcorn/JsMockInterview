{
  "vr-01": {
    "prompt": "¿Cómo defines un segmento de ruta dinámico que captura un valor específico, como un ID de usuario?",
    "explanation": "Los dos puntos denotan segmentos dinámicos. El valor pasado en la URL (por ejemplo, /user/123) será accesible mediante 'route.params.id'.",
    "interviewTip": "Puedes usar Regex en rutas para coincidencia más estricta, como /user/:id(\\\\d+).",
    "options": [":id", "{id}", "*id", "?id"]
  },
  "vr-02": {
    "prompt": "Analiza el código. ¿Cuál es la diferencia entre estos dos métodos de navegación?",
    "explanation": "Replace se usa cuando no quieres que el usuario pueda 'volver' a la pantalla anterior (por ejemplo, después de un login exitoso).",
    "interviewTip": "Usa 'replace' para redirecciones o estados transitorios para mantener limpia la pila de historial.",
    "options": [
      "La Opción A es para enlaces externos; la Opción B es para internos.",
      "La Opción A agrega una nueva entrada a la pila de historial; la Opción B sobrescribe la entrada actual.",
      "La Opción B es más rápida que la Opción A.",
      "No hay diferencia."
    ]
  },
  "vr-03": {
    "prompt": "¿Qué hook debes usar dentro de un componente para realizar lógica *antes* de que un usuario abandone la página actual?",
    "explanation": "onBeforeRouteLeave es un hook especializado del router. Te permite prevenir la navegación (por ejemplo, si el usuario tiene cambios sin guardar en un formulario).",
    "interviewTip": "Puedes devolver 'false' desde este hook para cancelar la navegación.",
    "options": [
      "onUnmounted",
      "onBeforeRouteLeave",
      "onBeforeRouteUpdate",
      "watchEffect"
    ]
  },
  "vr-04": {
    "prompt": "¿Cuál es el beneficio principal de hacer 'Lazy Loading' de rutas en la configuración del router?",
    "explanation": "Las importaciones dinámicas () => import(...) crean un bundle separado para esa ruta, mejorando significativamente el tiempo de carga inicial de la aplicación.",
    "interviewTip": "Para aplicaciones empresariales grandes, hacer lazy loading de cada ruta no crítica es una optimización de rendimiento obligatoria.",
    "options": [
      "Hace que los componentes carguen más lentamente.",
      "Divide la aplicación en fragmentos más pequeños, solo descargando el código de una página cuando el usuario realmente la visita.",
      "Comprime automáticamente las imágenes en esa página.",
      "Permite que la página funcione offline."
    ]
  },
  "vr-05": {
    "prompt": "¿Cómo accedes a los parámetros de la ruta actual dentro de un bloque <script setup>?",
    "explanation": "useRoute te da acceso al estado actual (params, query, path). useRouter te da la capacidad de navegar (push, back).",
    "interviewTip": "¡No los confundas! UseRoute es para '¿Qué está pasando ahora?'; UseRouter es para '¿Qué debería pasar después?'.",
    "options": ["useRouter", "useRoute", "getParams", "routeLink"]
  },
  "vr-06": {
    "prompt": "¿Cuáles de estos son Navigation Guards Globales válidos?",
    "explanation": "Los navigation guards se usan para proteger rutas (por ejemplo, verificar tokens de autenticación).",
    "interviewTip": "Menciona 'beforeEach' como el lugar principal para implementar verificaciones de autenticación.",
    "options": [
      "router.beforeEach (se ejecuta antes de cada navegación)",
      "router.afterEach (se ejecuta después de que la navegación está completa)",
      "router.beforeResolve (se ejecuta antes de que la navegación sea confirmada, después de los guards dentro del componente)",
      "router.onMount (se ejecuta cuando la aplicación inicia)"
    ]
  },
  "vr-07": {
    "prompt": "¿Cuál es el propósito del componente <router-view>?",
    "explanation": "RouterView es donde ocurre la magia. Sin él, podrías cambiar la URL, pero la UI no se actualizará para mostrar el nuevo componente.",
    "interviewTip": "Puedes usar múltiples componentes <router-view> con nombres para crear diseños complejos.",
    "options": [
      "Para mostrar una lista de todas las rutas disponibles.",
      "Como un marcador de posición que renderiza el componente coincidente con la URL actual.",
      "Para crear un enlace a otra página.",
      "Para depurar el estado de enrutamiento."
    ]
  },
  "vr-08": {
    "prompt": "Analiza el código. ¿Cuál es el valor de establecer 'props' en true?",
    "explanation": "Establecer 'props: true' desacopla el componente del router. El componente User puede declarar 'props: ['id']' y usarlo sin saber sobre 'this.$route'.",
    "interviewTip": "Esto hace que los componentes sean mucho más fáciles de testear unitariamente porque no dependen del estado global del router.",
    "options": [
      "Permite al componente usar props CSS.",
      "Pasa los parámetros de ruta (como :id) directamente como props al componente.",
      "Hace la ruta pública.",
      "Valida automáticamente los tipos de datos."
    ]
  },
  "vr-09": {
    "prompt": "¿Cómo navegas programáticamente a una ruta diferente en Vue Router?",
    "explanation": "$router es la instancia del router con métodos de navegación. $route es el objeto de información de la ruta actual.",
    "interviewTip": "En Composition API, usa useRouter() para acceder a la instancia del router.",
    "options": [
      "this.$router.push('/path')",
      "this.$route.push('/path')",
      "router.navigate('/path')",
      "window.location = '/path'"
    ]
  },
  "vr-10": {
    "prompt": "¿Cuál es el propósito de los route guards en Vue Router?",
    "explanation": "Los navigation guards (beforeEach, beforeEnter, beforeRouteEnter, etc.) te permiten implementar autenticación, autorización y otra lógica de navegación.",
    "interviewTip": "Los guards globales se ejecutan para todas las rutas, los guards por ruta se ejecutan para rutas específicas, y los guards dentro del componente se ejecutan dentro de componentes.",
    "options": [
      "Para proteger rutas de acceso no autorizado y controlar el flujo de navegación.",
      "Para proteger contra ataques XSS.",
      "Para prevenir cambios de ruta.",
      "Para encriptar parámetros de ruta."
    ]
  }
}
