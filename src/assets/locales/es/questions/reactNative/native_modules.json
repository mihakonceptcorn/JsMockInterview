{
  "nm-01": {
    "prompt": "En la arquitectura legada, ¿cuál es el rol de 'RCTBridgeModule' en iOS?",
    "explanation": "Para exponer una clase nativa a JS, esta debe implementar el protocolo RCTBridgeModule y usar la macro RCT_EXPORT_MODULE.",
    "interviewTip": "Recuerda que los datos pasados a través de este bridge deben serializarse en JSON, lo que puede ser un cuello de botella.",
    "options": [
      "Es una clase de JavaScript que define components de UI.",
      "Es un protocolo que una clase de Objective-C/Swift debe adoptar para ser accesible desde JavaScript.",
      "Es una herramienta que compila JS en machine code.",
      "Es el punto de entrada principal para el App Store."
    ]
  },
  "nm-02": {
    "prompt": "¿Cuál es la principal mejora técnica de los 'Turbo Modules' sobre los Native Modules legados?",
    "explanation": "Los módulos legados se inicializan todos al arrancar la app, ralentizando el inicio. Los Turbo Modules se cargan on demand y permiten llamadas síncronas a través de JSI (JavaScript Interface).",
    "interviewTip": "Si un entrevistador pregunta sobre el performance del inicio de la app, menciona el 'Lazy Loading' de los Turbo Modules.",
    "options": [
      "Están escritos en Python en lugar de Java.",
      "Se cargan de forma perezosa (solo cuando se necesitan) y usan JSI para comunicación directa.",
      "Suben datos automáticamente a la cloud.",
      "No requieren ningún native code."
    ]
  },
  "nm-03": {
    "prompt": "Analiza el código nativo de Android. ¿Cuál es el propósito de la anotación @ReactMethod?",
    "explanation": "Sin esta anotación, el método permanece invisible para el bridge de React Native, incluso si la clase misma está exportada.",
    "interviewTip": "Solo los métodos marcados con @ReactMethod pueden dispararse vía 'NativeModules.ModuleName.methodName()'.",
    "options": [
      "Marca el método como privado para la clase nativa.",
      "Exporta el método para que pueda ser llamado desde el JavaScript code.",
      "Le indica al Android OS que ejecute esto en el background.",
      "Encripta los parámetros."
    ]
  },
  "nm-04": {
    "prompt": "¿Cómo se comunica JavaScript con el lado nativo en la New Architecture sin serialización?",
    "explanation": "JSI permite que el JavaScript engine (Hermes) mantenga una referencia a un C++ object, habilitando llamadas a métodos directas y síncronas en lugar de pasar mensajes JSON.",
    "interviewTip": "JSI es lo que hace que 'Reanimated' sea tan rápido: permite que la UI se actualice sin esperar al bridge.",
    "options": [
      "A través de la Bridge queue.",
      "Usando JSI (JavaScript Interface) para mantener referencias C++ a objetos nativos.",
      "Escribiendo archivos en el disco.",
      "Usando WebSockets."
    ]
  },
  "nm-05": {
    "prompt": "¿Cuál es el propósito de 'Codegen' en la New Architecture?",
    "explanation": "Codegen garantiza la seguridad de tipos (type safety) entre el código JS y el nativo. Crea el código 'pegamento' (glue code) automáticamente para que no tengas que escribir boilerplate de C++ manualmente.",
    "interviewTip": "Codegen ayuda a prevenir runtime crashes causados por enviar tipos de datos incorrectos a través de la frontera JS-Nativo.",
    "options": [
      "Escribir la UI por ti usando AI.",
      "Generar el código de interfaz nativa (C++ / Java / Obj-C) basado en tus definiciones de TypeScript/Flow.",
      "Minificar el JS bundle.",
      "Verificar las versiones de los paquetes de npm."
    ]
  },
  "nm-06": {
    "prompt": "¿Cuáles de estas son formas válidas de enviar datos desde el lado Nativo de vuelta a JavaScript?",
    "explanation": "Los Callbacks y Promises son para respuestas a llamadas específicas. Los eventos (EventEmitter) son para acciones nativas que el JS no disparó, como una actualización de ubicación GPS.",
    "interviewTip": "Recuerda siempre eliminar los event listeners en la limpieza (cleanup) de 'useEffect' para evitar memory leaks.",
    "options": [
      "Usando un Callback (respuesta única).",
      "Usando Promises (respuesta única, moderno).",
      "Usando DeviceEventEmitter (para streaming de eventos).",
      "Modificando directamente la variable JS desde Java."
    ]
  },
  "nm-07": {
    "prompt": "¿Qué es un 'Native UI Component' (a diferencia de un Native Module)?",
    "explanation": "Mientras que los Native Modules proporcionan 'lógica', los Native UI Components proporcionan 'views'. Usas 'requireNativeComponent' para traerlos a tu JSX.",
    "interviewTip": "Si necesitas un elemento de UI muy complejo que no existe en RN, construyes un 'ViewManager' en el lado nativo.",
    "options": [
      "Una pieza de lógica como un API fetcher.",
      "Una vista nativa real (como un Video Player especializado o un Mapa) que se renderiza como un React component.",
      "Un botón proporcionado por el OS.",
      "Una base de datos de almacenamiento local."
    ]
  },
  "nm-08": {
    "prompt": "Identifica el problema en este método nativo de iOS:",
    "explanation": "Los métodos del bridge legado son asíncronos y devuelven 'void'. Para devolver un resultado a JS, debes pasar un RCTResponseSenderBlock o un RCTPromiseResolveBlock.",
    "interviewTip": "En la New Architecture con JSI, realmente *puedes* devolver valores de forma síncrona.",
    "options": [
      "Los tipos deben ser 'NSInteger'.",
      "Los métodos nativos en el bridge no pueden devolver valores directamente; deben usar callbacks o promises.",
      "El nombre del método es demasiado corto.",
      "No hay ningún problema."
    ]
  },
  "nm-09": {
    "prompt": "¿Qué hace la macro 'RCT_EXPORT_MODULE()'?",
    "explanation": "Sin esta macro, el bridge de React Native no sabrá que la clase existe en tiempo de ejecución.",
    "interviewTip": "Puedes pasar un nombre opcional a la macro (ej. RCT_EXPORT_MODULE(MyCustomName)) para cambiar cómo aparece en JS.",
    "options": [
      "Compila la clase en un binario.",
      "Registra la clase con React Native para que sea accesible vía NativeModules en JS.",
      "Exporta la clase al App Store.",
      "Convierte la clase en un singleton."
    ]
  },
  "nm-10": {
    "prompt": "¿Qué es 'Fabric' en la New Architecture y en qué se diferencia del renderizador legado?",
    "explanation": "El renderizador legado usaba un bridge asíncrono para enviar actualizaciones de UI. Fabric usa JSI para comunicarse síncronamente con el native UI thread, permitiendo características como priority-based rendering y layout animations.",
    "interviewTip": "Fabric es el equivalente al 'Concurrent Mode de React 18' para el lado nativo: permite que React Native interrumpa y priorice las actualizaciones de UI.",
    "options": [
      "Fabric es un nuevo framework de CSS para React Native.",
      "Fabric es el nuevo sistema de renderizado síncrono que reemplaza al UIManager asíncrono, permitiendo mejor performance y concurrent rendering.",
      "Fabric es una herramienta para desplegar apps a la cloud.",
      "Fabric es una base de datos para almacenar módulos nativos."
    ]
  }
}
