{
  "ab-01": {
    "prompt": "¿Qué tipo de component debes usar para que una View estándar sea animable con la Animated API?",
    "explanation": "Los components estándar no pueden manejar valores de Animated directamente. Debes usar las versiones 'Animated': View, Text, Image y ScrollView.",
    "interviewTip": "Si tienes un component personalizado, puedes envolverlo usando 'Animated.createAnimatedComponent(MyComponent)'.",
    "options": ["<View>", "<Animated.View>", "<Motion.View>", "<View.Animated>"]
  },
  "ab-02": {
    "prompt": "¿Cuál es el beneficio principal de configurar 'useNativeDriver: true' en una animación?",
    "explanation": "Al enviar la definición de la animación al lado nativo una sola vez, el native thread puede actualizar la UI de forma independiente del event loop de JavaScript.",
    "interviewTip": "Recuerda que 'useNativeDriver' solo funciona con properties que no afecten al layout, como 'opacity' y 'transform'.",
    "options": [
      "Hace que el código JavaScript sea más corto.",
      "Delega la ejecución de la animación al native UI thread, evitando lag incluso si el JS thread está ocupado.",
      "Permite que la animación funcione en la web.",
      "Calcula automáticamente los valores de interpolación."
    ]
  },
  "ab-03": {
    "prompt": "¿Cómo mapeas un valor que va de 0 a 1 a una property que va de 0 a 360 grados?",
    "explanation": "La interpolación permite mapear un rango de entrada a un rango de salida, incluyendo strings como colores o grados.",
    "interviewTip": "La interpolación es un concepto core en la Animated API para crear animaciones complejas de múltiples properties a partir de un solo valor.",
    "options": ["transform", "map", "interpolate", "extrapolate"]
  },
  "ab-04": {
    "prompt": "¿Qué método se utiliza para crear una animación basada en resortes (springs) que imite el movimiento físico?",
    "explanation": "Animated.spring() proporciona una sensación más natural al usar parámetros físicos como 'friction', 'tension', 'bounciness' o 'stiffness' en lugar de una duración fija.",
    "interviewTip": "Los springs suelen preferirse para interacciones de UI (como presionar botones o modales) porque se sienten más 'orgánicos' para los usuarios.",
    "options": [
      "Animated.timing()",
      "Animated.decay()",
      "Animated.spring()",
      "Animated.physics()"
    ]
  },
  "ab-05": {
    "prompt": "¿Cuál es la forma correcta de inicializar un animated value en un functional component para asegurar que persista entre renders?",
    "explanation": "useRef asegura que la instancia de Animated.Value se cree una sola vez y no se resetee cuando el component se vuelve a renderizar.",
    "interviewTip": "Inicializar en 'useRef' es el patrón estándar para functional components para evitar memory leaks y reseteos de estado.",
    "options": ["useState", "useMemo", "useRef", "useEffect"]
  },
  "ab-06": {
    "prompt": "¿Cómo ejecutas múltiples animaciones exactamente al mismo tiempo?",
    "explanation": "Animated.parallel inicia un array de animaciones de forma simultánea.",
    "interviewTip": "Usa esto cuando quieras que un elemento haga un fade-in y aumente su escala al mismo tiempo.",
    "options": [
      "Animated.sequence([])",
      "Animated.parallel([])",
      "Animated.stagger(0, [])",
      "Animated.group([])"
    ]
  },
  "ab-07": {
    "prompt": "¿Qué hace 'Animated.sequence([])'?",
    "explanation": "Sequence asegura que la siguiente animación en el array no comience hasta que la anterior se haya completado con éxito.",
    "interviewTip": "Esto es excelente para animaciones de 'onboarding' de varios pasos o transiciones de UI complejas.",
    "options": [
      "Inicia las animaciones una tras otra, esperando a que cada una termine.",
      "Inicia todas las animaciones a la vez.",
      "Repite la animación en un bucle.",
      "Aleatoriza el orden de las animaciones."
    ]
  },
  "ab-08": {
    "prompt": "¿Cómo inicias una animación una vez que está definida?",
    "explanation": "Las animaciones en React Native son declarativas. No se ejecutan hasta que llamas explícitamente al método '.start()'.",
    "interviewTip": "Puedes pasar un callback a .start(({ finished }) => { ... }) para manejar lógica después de que la animación termine.",
    "options": ["play", "begin", "start", "run"]
  },
  "ab-09": {
    "prompt": "¿Cuál de estas style properties NO se puede usar con 'useNativeDriver: true'?",
    "explanation": "En las versiones estables actuales, el driver nativo soporta principalmente 'transform' y 'opacity'. Las layout properties (width, height, flex) suelen requerir el JS thread.",
    "interviewTip": "Si necesitas animar layout properties de forma fluida, busca la API 'LayoutAnimation' o 'Reanimated'.",
    "options": ["opacity", "scale", "backgroundColor", "translateX"]
  },
  "ab-10": {
    "prompt": "¿Para qué se usa principalmente 'Animated.event'?",
    "explanation": "Animated.event permite interacciones ultra fluidas, como un header que se encoge al hacer scroll, vinculando el 'contentOffset' de un ScrollView a un Animated value.",
    "interviewTip": "Esta es la forma más eficiente de vincular gestos del usuario con cambios en la UI.",
    "options": [
      "Para disparar una función cuando una animación termina.",
      "Para mapear eventos nativos (como scroll o pan) directamente a un Animated Value sin pasar por el JS thread.",
      "Para escuchar cambios de orientación del dispositivo.",
      "Para crear touch events personalizados."
    ]
  },
  "ab-11": {
    "prompt": "¿Cómo creas una animación que se repita indefinidamente?",
    "explanation": "Animated.loop() toma una animación y la reinicia cada vez que llega al final.",
    "interviewTip": "Puedes usar esto para efectos de 'pulso' en botones o indicadores de carga.",
    "options": [
      "Animated.repeat()",
      "Animated.loop()",
      "Animated.forever()",
      "Llamando a .start() dentro del callback de finalización."
    ]
  },
  "ab-12": {
    "prompt": "¿Para qué se utiliza la API 'LayoutAnimation'?",
    "explanation": "LayoutAnimation es una API de tipo 'dispara y olvida'. La llamas antes de actualizar el estado y el lado nativo maneja la transición de todos los cambios de layout suavemente.",
    "interviewTip": "Es muy potente pero ofrece menos control granular que la API Animated.",
    "options": [
      "Para animar componentes individuales como un fade-in.",
      "Para animar automáticamente cualquier cambio en el layout (flex, width, height) en el siguiente ciclo de renderizado.",
      "Para manejar transformaciones 3D complejas.",
      "Para gestionar las transiciones de z-index."
    ]
  },
  "ab-13": {
    "prompt": "Analiza el código. ¿Qué le pasará a la caja después de 2 segundos?",
    "explanation": "toValue: 0 para una property de opacity resulta en que el elemento se vuelva completamente transparente.",
    "interviewTip": "Asegúrate siempre de que tu valor inicial coincida con el punto de partida deseado (ej. new Animated.Value(1) para un fade-out).",
    "options": [
      "Se volverá totalmente opaca.",
      "Desaparecerá (fade out).",
      "Se moverá 2000 píxeles a la izquierda.",
      "La caja cambiará su color a negro."
    ]
  },
  "ab-14": {
    "prompt": "¿Qué sucede con una animación si el component se desmonta mientras la animación se está ejecutando?",
    "explanation": "Aunque RN es generalmente estable, no detener las animaciones al desmontar puede ocasionalmente causar advertencias de 'actualización de estado en component desmontado' o problemas de memoria.",
    "interviewTip": "En las limpiezas (cleanups) de 'useEffect', deberías detener las animaciones activas si están vinculadas al estado local.",
    "options": [
      "Continúa ejecutándose en segundo plano.",
      "React Native maneja la limpieza automáticamente, pero es una buena práctica llamar a .stop() manualmente.",
      "La app se cerrará (crash).",
      "El teléfono vibrará."
    ]
  }
}
