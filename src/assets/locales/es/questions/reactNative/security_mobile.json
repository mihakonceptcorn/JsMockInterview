{
  "sec-01": {
    "prompt": "¿Qué es el 'SSL Pinning' y por qué se utiliza en aplicaciones React Native?",
    "explanation": "Incluso con HTTPS, un atacante a veces puede forzar a un dispositivo a confiar en un certificado falso. El SSL Pinning garantiza que la app rechace cualquier certificado que no coincida con el certificado 'anclado' de tu servidor.",
    "interviewTip": "Menciona librerías como 'react-native-ssl-pinning' o 'TrustKit'. Advertencia: si el certificado de tu servidor expira y no has actualizado la app, ¡dejará de funcionar!",
    "options": [
      "Una forma de fijar el ícono de la app en la pantalla de inicio.",
      "Una técnica para prevenir ataques Man-in-the-Middle (MITM) asegurando que la app solo confíe en un certificado de servidor específico y predefinido.",
      "Un método para cifrar el bundle de JavaScript.",
      "Una función que mantiene al usuario conectado para siempre."
    ]
  },
  "sec-02": {
    "prompt": "¿Cómo deben almacenarse las claves sensibles (como secretos de API) en una app React Native?",
    "explanation": "El almacenamiento estándar (AsyncStorage/MMKV) no está cifrado. El Keychain/Keystore proporciona cifrado a nivel de hardware diseñado específicamente para secretos.",
    "interviewTip": "Una gran respuesta incluye: 'Uso archivos .env para configuración en tiempo de build, pero los secretos específicos del dispositivo van en el Secure Keychain'.",
    "options": [
      "Codificadas directamente en un archivo 'constants.js'.",
      "Almacenadas en el 'package.json' para un acceso fácil.",
      "En el iOS Keychain o Android Keystore usando una librería como 'react-native-keychain'.",
      "En el estado local del componente."
    ]
  },
  "sec-03": {
    "prompt": "¿Cuál es el propósito de la detección de 'Jailbreak' o 'Root' en apps móviles?",
    "explanation": "En un dispositivo con root o jailbreak, los atacantes pueden eludir las restricciones del sandbox y leer los datos privados de tu app o interceptar la memoria. Los bancos y apps de alta seguridad a menudo bloquean el acceso en estos dispositivos.",
    "interviewTip": "Usa 'react-native-jail-monkey' o 'expo-device' para verificar si el entorno del dispositivo no es confiable.",
    "options": [
      "Acelerar la app en dispositivos modificados.",
      "Identificar si las capas de seguridad del dispositivo han sido comprometidas, permitiendo que la app desactive funciones sensibles (como pagos).",
      "Actualizar automáticamente el sistema operativo.",
      "Permitir que el usuario evite la App Store."
    ]
  },
  "sec-04": {
    "prompt": "Analiza la configuración de Android. ¿Qué hacen 'minifyEnabled true' y 'proguardFiles'?",
    "explanation": "Proguard/R8 reduce el código y renombra clases/métodos con nombres sin sentido (por ejemplo, 'a', 'b', 'c'), haciendo que el binario nativo sea difícil de leer.",
    "interviewTip": "Actívalo siempre para builds de release. Es la primera línea de defensa contra los decompiladores.",
    "options": [
      "Hace que los tamaños de fuente de la app sean más pequeños.",
      "Ofusca el código y elimina código no utilizado, haciendo mucho más difícil que los hackers realicen ingeniería inversa de tu lógica Java/Kotlin.",
      "Cifra las fotos del usuario.",
      "Habilita una depuración más rápida en Android."
    ]
  },
  "sec-05": {
    "prompt": "¿Por qué es peligroso usar 'console.log' en un build de producción de React Native?",
    "explanation": "Los logs no solo se muestran en tu terminal; se transmiten al log del sistema del dispositivo. Los builds de producción deberían eliminar los logs.",
    "interviewTip": "Usa 'babel-plugin-transform-remove-console' para eliminar automáticamente todos los logs durante el proceso de build de producción.",
    "options": [
      "Hace que la UI de la app se vea fea.",
      "Los logs son accesibles mediante herramientas del sistema (como logcat o Xcode) y pueden filtrar datos sensibles (tokens, información del usuario) a cualquiera con acceso al dispositivo.",
      "Hace que la app sea rechazada automáticamente por la App Store.",
      "Consume la batería extremadamente rápido."
    ]
  },
  "sec-06": {
    "prompt": "¿Cuáles de estos son métodos válidos para asegurar el bundle de JavaScript?",
    "explanation": "Hermes proporciona 'seguridad mediante compilación'. Los ofuscadores añaden una capa extra de complejidad a la lógica.",
    "interviewTip": "Explica que ningún código JS está 100% 'oculto', pero estos pasos hacen que sea significativamente más costoso para un atacante descifrarlo.",
    "options": [
      "Usar 'JSC' en lugar de 'Hermes'.",
      "Usar Hermes (compila JS a bytecode, que es más difícil de leer que texto plano).",
      "Usar un ofuscador como 'javascript-obfuscator' antes del bundling.",
      "Renombrar el archivo .js a .png."
    ]
  },
  "sec-07": {
    "prompt": "¿Qué es el 'Deep Link Hijacking'?",
    "explanation": "Los esquemas de URL (myapp://) no son exclusivos. Para prevenir el secuestro, debes usar 'Universal Links' (iOS) o 'App Links' (Android), que utilizan un dominio web verificado para demostrar la propiedad.",
    "interviewTip": "Prefiere siempre los 'Universal Links' basados en HTTPS en lugar de esquemas URI personalizados para flujos de autenticación.",
    "options": [
      "Cuando un sitio web enlaza a la página incorrecta.",
      "Cuando una app maliciosa registra el mismo esquema de URL que tu app (por ejemplo, myapp://) para interceptar datos sensibles enviados mediante enlaces.",
      "Cuando se cae internet durante un evento de navegación.",
      "Cuando el usuario hace clic en un enlace demasiadas veces."
    ]
  },
  "sec-08": {
    "prompt": "¿Cuál es el riesgo de seguridad de usar 'allowFileAccess' o 'javaScriptEnabled' en un WebView?",
    "explanation": "Los WebViews son esencialmente mini-navegadores. Si cargas URLs no confiables con permisos completos habilitados, corres el riesgo de dar a ese sitio acceso al sandbox interno de la app.",
    "interviewTip": "Habilita solo las funciones específicas que necesitas y usa siempre 'originWhitelist' para restringir qué dominios puede visitar el WebView.",
    "options": [
      "La app se quedará sin memoria.",
      "Puede abrir la puerta a ataques Cross-Site Scripting (XSS) donde contenido web malicioso accede a archivos locales del dispositivo.",
      "El WebView se renderizará demasiado lento.",
      "El usuario podrá ver el código fuente de la app."
    ]
  },
  "sec-09": {
    "prompt": "¿Cómo implementas autenticación biométrica (Face ID / Touch ID) en React Native?",
    "explanation": "Estas librerías proporcionan una API multiplataforma para verificar si la biometría está disponible y solicitar la autenticación del usuario.",
    "interviewTip": "Ten siempre un fallback a autenticación por PIN/contraseña en caso de que la biometría falle o no esté disponible en el dispositivo.",
    "options": [
      "Está integrada en React Native por defecto.",
      "Usa una librería como 'react-native-biometrics' o 'expo-local-authentication' para acceder a los sensores biométricos del dispositivo.",
      "Debes escribir código nativo en Swift/Kotlin para cada plataforma.",
      "La autenticación biométrica no es posible en React Native."
    ]
  },
  "sec-10": {
    "prompt": "¿Cuál es la forma recomendada de cifrar datos sensibles antes de almacenarlos localmente?",
    "explanation": "Base64 es codificación, no cifrado; puede revertirse fácilmente. AES-256 es un estándar de cifrado fuerte que requiere una clave para descifrar los datos.",
    "interviewTip": "Almacena la clave de cifrado en el Keychain/Keystore, nunca la codifiques directamente en tu bundle de JavaScript.",
    "options": [
      "Usar codificación Base64.",
      "Usar una librería como 'react-native-aes-crypto' para cifrar datos con AES-256 antes de guardarlos en AsyncStorage/MMKV.",
      "Almacenar los datos en texto plano pero ocultar el archivo.",
      "El cifrado no es necesario para apps móviles."
    ]
  }
}
