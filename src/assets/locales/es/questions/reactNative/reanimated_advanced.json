{
  "ra-01": {
    "prompt": "¿Qué es un 'Worklet' en el contexto de React Native Reanimated?",
    "explanation": "Los worklets son el núcleo de Reanimated. Permiten que el código JavaScript se ejecute de forma sincrónica en el UI thread, evitando el bridge asíncrono para actualizaciones inmediatas de la UI.",
    "interviewTip": "Menciona que Reanimated 2+ utiliza una VM de JavaScript separada en el UI thread para ejecutar estos worklets.",
    "options": [
      "Una tarea en segundo plano para obtener datos de una API.",
      "Una pequeña función JavaScript marcada con la directiva 'worklet' que se ejecuta en el UI thread.",
      "Un componente de UI que solo funciona en Android.",
      "Una herramienta de depuración para medir frame rates."
    ]
  },
  "ra-02": {
    "prompt": "¿Qué hook se utiliza para crear un valor mutable que puede compartirse entre el JS thread y el UI thread?",
    "explanation": "useSharedValue es la versión de state de Reanimated. Cuando cambias su propiedad '.value', se activan automáticamente animaciones o actualizaciones de estilos en el UI thread.",
    "interviewTip": "A diferencia de useState, cambiar un shared value no provoca un re-render del componente React en el JS thread principal.",
    "options": ["useRef", "useState", "useSharedValue", "useDerivedValue"]
  },
  "ra-03": {
    "prompt": "Analiza el código. ¿Cuál es la forma correcta de aplicar un shared value al estilo de un componente?",
    "explanation": "useAnimatedStyle devuelve un objeto de estilos que \"escucha\" los shared values. Cada vez que el shared value cambia, el UI thread actualiza la vista sin un viaje de ida y vuelta por el bridge.",
    "interviewTip": "Asegúrate siempre de que el componente sea una versión 'Animated' (por ejemplo, Animated.View) de la librería reanimated.",
    "options": ["useCallback", "useMemo", "useAnimatedStyle", "useUIStyle"]
  },
  "ra-04": {
    "prompt": "¿Cómo animas suavemente un shared value a una nueva posición usando un modelo de física de resorte?",
    "explanation": "withSpring es una función 'wrapper' que describe cómo debe verse la transición al nuevo valor. Utiliza física de resortes (stiffness, damping) en lugar de tiempo.",
    "interviewTip": "A diferencia de la API Animated estándar, Reanimated te permite asignar el nuevo valor directamente: `val.value = withSpring(target)`.",
    "options": ["withSpring", "withTiming", "withPhysics", "withTransition"]
  },
  "ra-05": {
    "prompt": "¿Cuál es el propósito de 'useDerivedValue'?",
    "explanation": "useDerivedValue crea un shared value de solo lectura que se actualiza automáticamente cuando cambian las dependencias dentro de su worklet.",
    "interviewTip": "Piénsalo como el 'useMemo' del UI thread.",
    "options": [
      "Calcular un nuevo shared value basado en otros shared values (por ejemplo, rotación basada en la posición de scroll).",
      "Convertir un shared value en un estado de React.",
      "Retrasar una animación.",
      "Obtener datos de un servidor durante una animación."
    ]
  },
  "ra-06": {
    "prompt": "¿Cuáles de estas características se introdujeron en Reanimated 3?",
    "explanation": "Reanimated 3 se centró fuertemente en la compatibilidad con la New Architecture y en Shared Element Transitions robustas entre pantallas de navegación.",
    "interviewTip": "Las Shared Element Transitions hacen que las apps se sientan de muy alta calidad, similares a App Store o Instagram.",
    "options": [
      "Shared Element Transitions (animar un componente de una pantalla a otra).",
      "Soporte para la arquitectura Bridge.",
      "Layout Animations (transiciones de Entry/Exit/Layout).",
      "Mejor soporte para la New Architecture (Fabric)."
    ]
  },
  "ra-07": {
    "prompt": "¿Cómo ejecutas un fragmento de código JavaScript en el JS thread principal después de que una animación finaliza en el UI thread?",
    "explanation": "Dado que el callback de finalización se ejecuta en el UI thread, debes usar runOnJS para \"volver a llamar\" al JS thread para acciones como alertas o actualizaciones de estado.",
    "interviewTip": "No usar runOnJS dentro de un worklet al llamar una función JS provocará un crash.",
    "options": ["runOnJS", "dispatchToJS", "callMainThread", "useMainThread"]
  },
  "ra-08": {
    "prompt": "¿Qué son las 'Layout Animations' en Reanimated?",
    "explanation": "Las layout animations proporcionan una forma simple de animar el montaje/desmontaje y los cambios de layout sin gestionar shared values complejos manualmente.",
    "interviewTip": "Usa `Layout.springify()` para que los movimientos de los elementos de una lista se vean elásticos y naturales.",
    "options": [
      "Una forma de calcular manualmente el tamaño de una View.",
      "Animaciones declarativas que se activan automáticamente cuando un componente entra al DOM, sale o cambia de posición.",
      "Un método para agrupar componentes en una cuadrícula.",
      "Animaciones que solo funcionan en la Web."
    ]
  },
  "ra-09": {
    "prompt": "¿Cuál es la función de 'interpolateColor' en Reanimated?",
    "explanation": "Similar a la interpolación estándar, pero específicamente optimizada para el UI thread para manejar transiciones de color de forma fluida.",
    "interviewTip": "Esto es perfecto para cambiar el color de un header de blanco a transparente a medida que el usuario hace scroll.",
    "options": [
      "Cambiar el contraste de una imagen.",
      "Transicionar suavemente entre dos o más strings de color hex/rgb basándose en un shared value.",
      "Generar un color aleatorio.",
      "Comprobar si un color es accesible."
    ]
  },
  "ra-10": {
    "prompt": "¿Por qué 'useAnimatedGestureHandler' (v2) o el uso de gestos con Reanimated (v3) es mejor que los eventos táctiles estándar?",
    "explanation": "Al vincular Gesture Handler con Reanimated, los datos de 'translation' de un gesto pueden actualizar un shared value y mover una View completamente en el UI thread.",
    "interviewTip": "Esta es la clave para construir interacciones tipo 'pull-to-dismiss' o 'swipe-to-delete' a 60/120 FPS.",
    "options": [
      "Soporta más dedos.",
      "Permite que los datos del gesto controlen las animaciones directamente en el UI thread sin lag.",
      "Previene automáticamente todo el scrolling.",
      "Solo está disponible en iOS."
    ]
  }
}
