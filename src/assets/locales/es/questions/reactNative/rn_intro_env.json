{
  "rn-env-01": {
    "prompt": "¿Cuál es la diferencia principal entre el 'Bridge' (Old Architecture) y 'JSI' (New Architecture)?",
    "explanation": "El Bridge heredado requiere que los datos se serialicen en JSON y se envíen a través de una cola asíncrona. JSI (JavaScript Interface) permite que JS mantenga referencias a host objects en C++, habilitando llamadas directas y sincrónicas.",
    "interviewTip": "Menciona que JSI es la base de la New Architecture (Fabric y TurboModules).",
    "options": [
      "JSI permite comunicación sincrónica entre JS y Native, mientras que el Bridge es asíncrono y serializado.",
      "El Bridge es más rápido porque usa JSON para toda la transferencia de datos.",
      "JSI requiere Expo, mientras que el Bridge funciona solo con React Native CLI.",
      "El Bridge usa Java exclusivamente, mientras que JSI usa Swift."
    ]
  },
  "rn-env-02": {
    "prompt": "¿Qué motor de layout utiliza React Native para calcular posiciones y tamaños de los componentes?",
    "explanation": "Yoga es un motor de layout multiplataforma desarrollado por Meta que implementa Flexbox para pantallas móviles nativas.",
    "interviewTip": "Yoga está escrito en C++ y es lo que traduce tus estilos 'flex: 1' en coordenadas reales de píxeles en iOS y Android.",
    "options": ["WebKit", "Gecko", "Yoga", "Flexbox-Native"]
  },
  "rn-env-03": {
    "prompt": "¿Qué hace el engine 'Hermes' para una aplicación React Native?",
    "explanation": "Hermes es un engine de JS pequeño y liviano. Utiliza precompilación a bytecode (AOT) para hacer que el arranque de la app sea significativamente más rápido.",
    "interviewTip": "A partir de React Native 0.70, Hermes es el engine predeterminado para todos los proyectos nuevos.",
    "options": [
      "Gestiona la conexión con Google Play Store.",
      "Es un engine de JavaScript optimizado para mobile que mejora el tiempo de inicio y reduce el tamaño de la app.",
      "Maneja todo el cacheo de imágenes y el almacenamiento local.",
      "Es una librería de UI que reemplaza los componentes core."
    ]
  },
  "rn-env-04": {
    "prompt": "¿Cuál será el resultado de este código al ejecutarse en un entorno React Native?",
    "explanation": "Los componentes core como View son componentes JavaScript (generalmente funciones u objetos) que actúan como wrappers de elementos de UI nativos.",
    "interviewTip": "Al final, estos componentes indican al lado nativo que renderice un 'UIView' en iOS o un 'android.view' en Android.",
    "options": [
      "\"string\"",
      "\"function\" (o \"object\" dependiendo de la implementación interna de la versión de RN)",
      "\"undefined\"",
      "\"native-element\""
    ]
  },
  "rn-env-05": {
    "prompt": "¿Cuáles de las siguientes son ventajas de usar 'Expo' sobre 'React Native CLI'?",
    "explanation": "Expo simplifica el desarrollo al abstraer el código nativo complejo, aunque el CLI sigue siendo preferido si necesitas modificaciones personalizadas de Native Modules que Expo no soporta.",
    "interviewTip": "Expo ya no es 'solo para principiantes'; con 'Development Builds', ahora es lo suficientemente potente para apps empresariales profesionales.",
    "options": [
      "Managed workflow: maneja automáticamente las configuraciones nativas y los certificados.",
      "Acceso directo para modificar AppDelegate.m y MainApplication.java sin soluciones alternativas.",
      "Testing más fácil en dispositivos físicos mediante la app Expo Go.",
      "EAS (Expo Application Services) para builds y envíos en la nube."
    ]
  },
  "rn-env-06": {
    "prompt": "¿Qué es el bundler 'Metro' en React Native?",
    "explanation": "Metro es similar a Webpack para la web. Resuelve dependencias y empaqueta tu código para el entorno mobile.",
    "interviewTip": "Metro es lo que impulsa Hot Module Replacement (HMR) / Fast Refresh durante el desarrollo.",
    "options": [
      "Una herramienta que compila código Java en APKs.",
      "El bundler de JavaScript que toma todos tus archivos JS y los combina en un solo bundle para la app.",
      "Una herramienta de debugging usada para inspeccionar el árbol de UI.",
      "La parte de la arquitectura que maneja push notifications."
    ]
  },
  "rn-env-07": {
    "prompt": "En la New Architecture, ¿qué reemplaza a 'UIManager'?",
    "explanation": "Fabric es el nuevo sistema de rendering. Es más eficiente porque permite que la UI se actualice de forma sincrónica y mejora la interoperabilidad con host views.",
    "interviewTip": "Fabric es al Rendering lo que TurboModules son a la lógica Native.",
    "options": ["TurboModules", "Fabric", "Hermes", "Metro"]
  },
  "rn-env-08": {
    "prompt": "¿Cuál es el propósito de 'npx react-native run-ios'?",
    "explanation": "Este comando inicia el proceso de build (a través de herramientas de Xcode) y despliega la aplicación en el target iOS.",
    "interviewTip": "Debes tener Xcode instalado en una máquina macOS para que este comando funcione.",
    "options": [
      "Instalar dependencias desde npm.",
      "Construir y lanzar la aplicación iOS en un simulador o dispositivo.",
      "Minificar el bundle de JavaScript.",
      "Generar un nuevo proyecto a partir de un template."
    ]
  },
  "rn-env-09": {
    "prompt": "Identifica los tres threads principales en una app React Native estándar (arquitectura Bridge):",
    "explanation": "El UI thread maneja el rendering de vistas nativas; el JS thread ejecuta la lógica; y el Shadow thread calcula el layout (Yoga) antes de enviarlo al UI thread.",
    "interviewTip": "Si el JS thread se bloquea por lógica pesada, la UI permanece responsiva (las animaciones pueden seguir funcionando), pero las interacciones del usuario como clicks no se procesarán.",
    "options": [
      "Main Thread (UI Thread)",
      "Database Thread",
      "JavaScript Thread",
      "Shadow Thread (Layout Thread)"
    ]
  },
  "rn-env-10": {
    "prompt": "¿Qué sucederá si ejecutas este código en un componente React Native estándar?",
    "explanation": "React Native no utiliza el DOM del navegador. Debes usar primitivas nativas como <View> y <Text>.",
    "interviewTip": "No existe 'div', 'span' o 'p' en React Native; todo lo relacionado con texto debe estar dentro de un componente <Text>.",
    "options": [
      "Funciona porque RN soporta todas las etiquetas HTML.",
      "Lanza un error porque 'div' no es un componente válido en React Native.",
      "Se renderiza automáticamente como una View.",
      "Solo funciona en la versión Web de React Native."
    ]
  },
  "rn-env-11": {
    "prompt": "¿Qué es 'Autolinking' en React Native?",
    "explanation": "Antes debías ejecutar 'react-native link'. Ahora, el CLI detecta los native modules en node_modules y los vincula automáticamente durante el build.",
    "interviewTip": "Para iOS, aún necesitas ejecutar 'pod install' después de agregar una librería para finalizar el autolinking.",
    "options": [
      "Una funcionalidad que actualiza automáticamente tus paquetes npm.",
      "Un mecanismo que vincula automáticamente dependencias nativas a tus proyectos iOS/Android sin pasos manuales.",
      "Una forma de enlazar dos pantallas diferentes en la navegación.",
      "Una herramienta de IA para escribir boilerplate code."
    ]
  },
  "rn-env-12": {
    "prompt": "¿Cuál es el punto de entrada para la configuración nativa en un proyecto Android React Native?",
    "explanation": "AndroidManifest.xml es donde defines permisos, activities y metadata de la app para el sistema operativo Android.",
    "interviewTip": "Saber dónde están estos archivos nativos (android/app/src/main/...) es esencial para configurar cosas como deep links o permisos de cámara.",
    "options": [
      "AppDelegate.m",
      "AndroidManifest.xml",
      "index.js",
      "metro.config.js"
    ]
  },
  "rn-env-13": {
    "prompt": "En React Native, ¿en qué se diferencia un 'TurboModule' de un Native Module estándar?",
    "explanation": "Los módulos estándar se inicializan al iniciar la app incluso si no se usan. Los TurboModules solo se cargan cuando se requieren y se comunican directamente vía JSI.",
    "interviewTip": "Esta es una parte clave de la New Architecture orientada a mejorar el rendimiento del arranque de la app.",
    "options": [
      "Los TurboModules están escritos en JavaScript, mientras que los Native Modules están escritos en Java.",
      "Los TurboModules se cargan de forma lazy y usan JSI para una comunicación más rápida y sincrónica.",
      "Los TurboModules solo funcionan en iOS.",
      "Los TurboModules son la forma antigua de escribir código nativo."
    ]
  },
  "rn-env-14": {
    "prompt": "¿Qué comando se utiliza para iniciar manualmente el bundler Metro?",
    "explanation": "Esto inicia el servidor local que provee el bundle de JS y los assets a tu app en ejecución durante el desarrollo.",
    "interviewTip": "Si recibes un error 'Could not connect to development server', verificar si este proceso está corriendo es tu primer paso.",
    "options": [
      "npm build",
      "npx react-native start",
      "npx metro-run",
      "expo-cli build"
    ]
  },
  "rn-env-15": {
    "prompt": "¿Cuál de estas es una forma válida de especificar una versión de React Native en un proyecto?",
    "explanation": "La versión de React Native se gestiona como cualquier otro paquete npm en el archivo package.json.",
    "interviewTip": "Actualizar versiones de React Native a menudo requiere la herramienta 'React Native Upgrade Helper' debido a cambios en los archivos nativos subyacentes.",
    "options": [
      "El código anterior es correcto.",
      "Las versiones se especifican en el archivo 'native-config.json'.",
      "Configuras la versión solo en los ajustes del proyecto Xcode.",
      "Las versiones de React Native son gestionadas por el engine Hermes."
    ]
  },
  "rn-env-16": {
    "prompt": "¿Qué representa el 'Shadow Tree'?",
    "explanation": "El Shadow Tree es donde React Native almacena la información de layout (flex, margin, padding) para que Yoga haga su magia.",
    "interviewTip": "En la New Architecture, el Shadow Tree es inmutable y se gestiona en C++ para un mejor rendimiento.",
    "options": [
      "Una copia oculta del DOM.",
      "Una estructura en árbol utilizada por Yoga para calcular el layout antes de traducirlo a vistas nativas.",
      "La lista de todos los componentes eliminados.",
      "Una capa de seguridad que protege el JS thread."
    ]
  },
  "rn-env-17": {
    "prompt": "¿Cómo habilitas la New Architecture en un proyecto React Native moderno (iOS)?",
    "explanation": "En la mayoría de las versiones actuales, debes habilitarla explícitamente durante el proceso de instalación de pods para iOS o en gradle.properties para Android.",
    "interviewTip": "Ten en cuenta que algunas librerías de terceros pueden no ser compatibles aún con la New Architecture.",
    "options": [
      "Cambiando una configuración en el dashboard de Expo.",
      "Ejecutando 'bundle exec pod install' con la variable de entorno 'RCT_NEW_ARCH_ENABLED=1'.",
      "Siempre está habilitada y no se puede desactivar.",
      "Eliminando el archivo Bridge.js."
    ]
  },
  "rn-env-18": {
    "prompt": "¿Qué sucede cuando se activa 'Fast Refresh'?",
    "explanation": "Fast Refresh combina 'hot reloading' y 'live reloading' para proporcionar una experiencia de actualización fluida sin perder el estado del componente cuando es posible.",
    "interviewTip": "Si modificas un archivo que exporta algo distinto a un componente React, Fast Refresh puede realizar un reload completo por seguridad.",
    "options": [
      "Toda la app se recarga y se pierde todo el estado.",
      "React Native intenta actualizar solo los componentes modificados preservando su estado.",
      "El código nativo (Java/Swift) se recompila.",
      "El dispositivo vibra para indicar una actualización."
    ]
  }
}
