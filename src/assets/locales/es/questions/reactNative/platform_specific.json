{
  "ps-01": {
    "prompt": "¿Qué built-in module se utiliza para detectar el sistema operativo en runtime dentro de tu JavaScript code?",
    "explanation": "El módulo 'Platform' proporciona una property 'Platform.OS' que devuelve 'ios' o 'android'.",
    "interviewTip": "También puedes usar 'Platform.Version' para verificar el nivel de API específico del dispositivo.",
    "options": ["Device", "OS", "Platform", "System"]
  },
  "ps-02": {
    "prompt": "¿Cómo aplicas diferentes estilos para iOS y Android usando el método Platform.select?",
    "explanation": "Platform.select recibe un object donde las keys son las plataformas y devuelve el valor correspondiente a la plataforma en la que se ejecuta la app.",
    "interviewTip": "Esto es mucho más limpio que usar múltiples operadores ternarios (Platform.OS === 'ios' ? ... : ...).",
    "options": ["paddingTop", "marginTop", "safeArea", "topOffset"]
  },
  "ps-03": {
    "prompt": "¿Cuál es la convención de nomenclatura para crear archivos separados para iOS y Android que React Native detectará automáticamente?",
    "explanation": "El packager de React Native (Metro) detecta la extensión específica de la plataforma e importa el archivo correcto automáticamente cuando haces 'import Header from \"./Header\"'.",
    "interviewTip": "Este es el mejor patrón para components complejos que requieren implementaciones nativas completamente diferentes.",
    "options": [
      "Header.ios.js y Header.android.js",
      "ios/Header.js y android/Header.js",
      "Header(ios).js y Header(android).js",
      "Header_ios.js y Header_android.js"
    ]
  },
  "ps-04": {
    "prompt": "¿Cuáles de estas son formas válidas de manejar las diferencias entre plataformas en React Native?",
    "explanation": "React Native proporciona detección de OS, la utilidad select y división a nivel de archivos. No existe un component <NativeTarget> integrado.",
    "interviewTip": "Menciona que las extensiones de archivo son mejores para grandes diferencias de lógica, mientras que Platform.select es ideal para pequeños ajustes de estilo.",
    "options": [
      "Usar el condicional Platform.OS.",
      "Usar el método Platform.select().",
      "Usar extensiones de archivo específicas (.ios.js / .android.js).",
      "Usar el wrapper component <NativeTarget>."
    ]
  },
  "ps-05": {
    "prompt": "¿Cómo verificas si el dispositivo Android actual tiene un nivel de API específico (ej. API 30)?",
    "explanation": "Para Android, Platform.Version devuelve el nivel de API como un integer (ej. 30, 31). Para iOS, devuelve un string de la versión del sistema (ej. '17.2').",
    "interviewTip": "Recuerda siempre verificar primero el OS, porque '30' (número) y '17.2' (string) se comparan de forma distinta en JS.",
    "options": [
      "Esta es la forma correcta.",
      "Usar Platform.API_LEVEL.",
      "Usar DeviceInfo.getApiLevel().",
      "Los niveles de API de Android no son accesibles vía Platform."
    ]
  },
  "ps-06": {
    "prompt": "¿Qué devuelve la property 'Platform.isPad'?",
    "explanation": "Platform.isPad es un boolean específico para iOS para distinguir entre layouts de iPhone y iPad.",
    "interviewTip": "Para una verificación de tablet cross-platform, usualmente necesitas revisar el ancho de pantalla usando Dimensions.",
    "options": [
      "True si la app se ejecuta en una tablet (Android o iOS).",
      "True si la app se ejecuta en un Apple iPad.",
      "Un string que identifica al fabricante de la tablet.",
      "True si el dispositivo tiene un stylus conectado."
    ]
  },
  "ps-07": {
    "prompt": "¿Qué property en el módulo Platform se usa para verificar si la app se ejecuta en un entorno de TV (como Apple TV o Android TV)?",
    "explanation": "Platform.isTV es un boolean que te ayuda a ajustar la lógica de navegación para interfaces basadas en foco (control remoto).",
    "interviewTip": "Las apps de TV requieren components 'focusable', que es un paradigma diferente al touch.",
    "options": [
      "Platform.isTV",
      "Platform.TV_MODE",
      "Platform.isTVOS",
      "Platform.uiMode === 'tv'"
    ]
  },
  "ps-08": {
    "prompt": "Analiza el código. ¿Qué hará la property 'elevation' en un dispositivo iOS?",
    "explanation": "Android usa 'elevation' para las sombras (Material Design), mientras que iOS usa 'shadowColor', 'shadowOffset', 'shadowOpacity' y 'shadowRadius'.",
    "interviewTip": "Para obtener sombras consistentes en ambos, debes definir ambos sets de properties o usar una librería como 'react-native-shadow-2'.",
    "options": [
      "Creará una sombra en iOS.",
      "Será ignorada porque 'elevation' es una property exclusiva de Android.",
      "Causará un error en iOS.",
      "Cambiará el z-index de la tarjeta."
    ]
  },
  "ps-09": {
    "prompt": "¿Cómo defines un component que solo se renderice en la web cuando usas 'React Native for Web'?",
    "explanation": "Metro y Webpack pueden configurarse para reconocer extensiones '.web.js' para implementaciones específicas de navegador.",
    "interviewTip": "Esto te permite usar tags estándar como <div> y <a> para la versión web mientras usas View/Text para mobile.",
    "options": [
      "MyComponent.web.js",
      "MyComponent.browser.js",
      "MyComponent.html.js",
      "MyComponent.js y verificar Platform.OS === 'web'"
    ]
  },
  "ps-10": {
    "prompt": "¿Cuál es el propósito de 'Platform.select' para valores por defecto?",
    "explanation": "La key 'default' actúa como un fallback para cualquier plataforma que no esté listada explícitamente en el object.",
    "interviewTip": "Esto es excelente para mantener la compatibilidad futura con plataformas como 'macos' o 'windows'.",
    "options": [
      "Selecciona 'Hello World' si el OS no es iOS ni Android (ej. Web/Windows).",
      "Causa un error si falta una plataforma.",
      "Elige una de las opciones al azar.",
      "La key 'default' no está soportada."
    ]
  }
}
