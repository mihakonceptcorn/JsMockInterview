{
  "perf-01": {
    "prompt": "Which JavaScript engine is now the default for React Native because it provides faster TTI (Time To Interactive) and smaller APK sizes?",
    "explanation": "Hermes is optimized specifically for mobile. It uses Ahead-of-Time (AOT) compilation to turn JS into bytecode during the build process, rather than at runtime.",
    "interviewTip": "Mention that Hermes also helps reduce the 'Memory Footprint' of the app, which is vital for budget Android devices."
  },
  "perf-02": {
    "prompt": "What is 'FlashList' (by Shopify) and why is it often used instead of 'FlatList'?",
    "explanation": "FlatList unmounts off-screen items. FlashList recycles the underlying native views and simply swaps the data, which is much faster for the device to handle.",
    "interviewTip": "FlashList claims to be '5x to 10x faster' than FlatList. It's a great mention for Senior-level performance discussions."
  },
  "perf-03": {
    "prompt": "Analyze the code. Why is this list likely to lag during fast scrolling?",
    "explanation": "Functions defined inside the component body are recreated every render. Additionally, heavy logic like 'expensiveFormat' inside renderItem blocks the JS thread during scroll.",
    "interviewTip": "Solution: Move renderItem outside the component or wrap it in 'useCallback', and memoize the expensive formatting."
  },
  "perf-04": {
    "prompt": "What is the purpose of the 'InteractionManager.runAfterInteractions' method?",
    "explanation": "This ensures that a heavy task doesn't steal CPU cycles from an animation, preventing 'jank' or dropped frames.",
    "interviewTip": "This is perfect for fetching data immediately after a screen transition without making the transition feel sluggish."
  },
  "perf-05": {
    "prompt": "Which of these tools are commonly used to profile and debug performance in a React Native app?",
    "explanation": "Flipper and React DevTools are standard for JS/Bridge profiling. Xcode Instruments (and Android Studio Profiler) are needed to inspect native memory and CPU usage.",
    "interviewTip": "Flipper is a 'Senior' choiceâ€”it allows you to inspect the bridge traffic, layout, and database in one place."
  },
  "perf-06": {
    "prompt": "How can you detect if your JS thread is being overloaded in a real device?",
    "explanation": "The 'Perf Monitor' overlay shows the frame rate of both threads. If UI is 60 FPS but JS is 10 FPS, your logic is blocking the app.",
    "interviewTip": "JS FPS drops usually mean too many re-renders or heavy computations; UI FPS drops mean your View hierarchy is too deep or complex."
  },
  "perf-07": {
    "prompt": "What is 'Inline function' optimization in the context of RN performance?",
    "explanation": "An inline arrow function creates a new reference on every render. If the button is wrapped in 'React.memo', it will still re-render because the 'onPress' prop changed reference.",
    "interviewTip": "This is the most common cause of 'Wasted Renders' in large lists."
  },
  "perf-08": {
    "prompt": "Why should you avoid deep nesting of View components?",
    "explanation": "Every layer of nesting adds work for the Yoga layout engine. Flattening your UI structure improves the speed of initial rendering and updates.",
    "interviewTip": "If you have 10 nested Views just for margins/padding, try to combine them into fewer components."
  },
  "perf-09": {
    "prompt": "What is the benefit of using 'RAM bundles' (Random Access Modules) in React Native?",
    "explanation": "RAM bundles split the JavaScript into indexed modules. The app loads the 'startup' modules first, then loads other modules as they are required during navigation.",
    "interviewTip": "This is particularly useful for large apps with many screens. Mention 'Metro bundler' configuration for enabling this."
  },
  "perf-10": {
    "prompt": "How does the New Architecture improve performance compared to the legacy architecture?",
    "explanation": "The New Architecture (JSI + Fabric + Turbo Modules) removes the JSON serialization bottleneck and allows React to communicate directly with native code, enabling features like synchronous layout and priority-based rendering.",
    "interviewTip": "Mention that this brings React Native's performance much closer to fully native apps, especially for complex UI interactions."
  }
}
