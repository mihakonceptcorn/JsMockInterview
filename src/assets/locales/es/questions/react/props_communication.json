{
  "pc-01": {
    "prompt": "¿Cuál es el resultado del siguiente fragmento de código?",
    "explanation": "Debido a que '25' se pasó como un string (con comillas), el operador '+' realiza una concatenación de strings en lugar de una suma.",
    "interviewTip": "Pasa siempre los números dentro de llaves, ej., age={25}, para asegurar que se mantengan como tipos numéricos.",
    "options": [
      "26",
      "Error: Las props son de solo lectura",
      "251",
      "undefined"
    ]
  },
  "pc-02": {
    "prompt": "¿Qué afirmación describe mejor la naturaleza de las 'props' en React?",
    "explanation": "React impone una regla estricta de inmutabilidad para las props para asegurar que el flujo de datos unidireccional sea predecible y fácil de depurar.",
    "interviewTip": "Trata las props como 'instantáneas' (snapshots) de datos proporcionados por el padre.",
    "options": [
      "Las props son inmutables; un componente nunca debe modificar sus propias props.",
      "Las props son mutables y pueden usarse para almacenar cambios locales del componente.",
      "Las props solo se usan para pasar clases CSS a los elementos hijos.",
      "Las props solo pueden pasarse de un hijo a su padre."
    ]
  },
  "pc-03": {
    "prompt": "¿Qué se renderizará con la siguiente estructura de componentes?",
    "explanation": "La prop 'children' es una prop especial en React que contiene automáticamente cualquier cosa que se coloque entre las etiquetas de apertura y cierre de un componente.",
    "interviewTip": "Este patrón se conoce como 'Contención' o 'Composición'.",
    "options": [
      "Un div vacío con la clase 'container'.",
      "Un div que contiene una etiqueta p con 'Hello World'.",
      "El string 'children'.",
      "Nada, children no es un nombre de prop válido."
    ]
  },
  "pc-04": {
    "prompt": "¿Cuáles de las siguientes son formas válidas de proporcionar valores por defecto para las props en un componente funcional?",
    "explanation": "Los valores por defecto de ES6 son el estándar moderno. .defaultProps es la forma legada de React. Usar el operador OR dentro de JSX es un respaldo rápido en línea.",
    "interviewTip": "Para componentes funcionales, el enfoque de desestructuración de ES6 es generalmente el preferido por el equipo de React hoy en día.",
    "options": [
      "Usando valores por defecto en la desestructuración de ES6: function MyComponent({ name = 'Guest' }) { ... }",
      "Usando la propiedad .defaultProps: MyComponent.defaultProps = { name: 'Guest' };",
      "Definiendo un valor por defecto dentro del return: <h1>{props.name || 'Guest'}</h1>",
      "Usando el hook useState para establecer el valor de la prop."
    ]
  },
  "pc-05": {
    "prompt": "¿Cómo envía datos un componente hijo de vuelta a su padre?",
    "explanation": "Los padres pasan funciones. Los hijos llaman a esas funciones con datos como argumentos. Este patrón de 'Eventos hacia arriba' mantiene el flujo unidireccional.",
    "interviewTip": "Esto a menudo se llama 'Lifting State Up' (Elevar el estado) cuando el hijo dispara una actualización en el estado del padre.",
    "options": [
      "Modificando el objeto props directamente.",
      "Usando una función callback pasada desde el padre como una prop.",
      "Emitiendo un evento DOM personalizado usando document.dispatchEvent.",
      "Actualizando una variable global de window."
    ]
  },
  "pc-06": {
    "prompt": "¿Qué es el 'Prop Drilling'?",
    "explanation": "El prop drilling hace que los componentes sean más difíciles de reutilizar porque los componentes intermedios se ven obligados a manejar datos que realmente no necesitan.",
    "interviewTip": "La Context API o las librerías de gestión de estado (como Redux/Zustand) son soluciones comunes para evitar un drilling excesivo.",
    "options": [
      "Una técnica para optimizar el rendimiento de las props.",
      "El proceso de pasar props a través de varias capas de componentes solo para llegar a un hijo profundo.",
      "Una forma de generar props automáticamente usando un bucle.",
      "El método utilizado para validar los tipos de props."
    ]
  },
  "pc-07": {
    "prompt": "Analiza el código. ¿Qué sucede cuando se hace clic en el botón?",
    "explanation": "La referencia a la función alertMsg se pasa como una prop. Cuando se hace clic en el botón hijo, se ejecuta esa referencia.",
    "interviewTip": "Esto demuestra cómo las props funcionales sirven de puente de comunicación entre componentes.",
    "options": [
      "No pasa nada porque onAction no es un evento nativo.",
      "Se dispara la alerta 'Hello!'.",
      "Un error: 'onAction is not a function'.",
      "El botón desaparece."
    ]
  },
  "pc-08": {
    "prompt": "¿Qué hace el operador spread (...) en el siguiente contexto?",
    "explanation": "El operador spread expande las claves del objeto en atributos individuales dentro de JSX.",
    "interviewTip": "Aunque es conveniente, el uso excesivo del operador spread puede dificultar ver de qué datos depende realmente un componente.",
    "options": [
      "Pasa una sola prop llamada 'userData' que contiene el objeto.",
      "Pasa 'name' y 'age' como props individuales al componente UserProfile.",
      "Elimina las propiedades name y age después de pasarlas.",
      "Convierte el objeto en un string JSON."
    ]
  },
  "pc-09": {
    "prompt": "¿Qué sucede si pasas una prop llamada 'class' a un componente personalizado de React?",
    "explanation": "Mientras que 'class' está reservado para elementos HTML en JSX (donde debes usar className), para un componente *personalizado*, es solo una clave en un objeto. Sin embargo, es confuso y suele evitarse.",
    "interviewTip": "Sé consistente y usa 'className' incluso para tus propios componentes para evitar confusiones con elementos nativos del DOM.",
    "options": [
      "React lo convierte automáticamente a 'className'.",
      "Funciona como cualquier otra prop; puedes acceder a ella vía props.class.",
      "La app colapsa porque 'class' es una palabra reservada en JS.",
      "La prop se ignora y no se pasa."
    ]
  },
  "pc-10": {
    "prompt": "En el siguiente código, ¿cuál es el valor inicial de 'isActive' en el Hijo?",
    "explanation": "En JSX, si se pasa una prop sin valor, por defecto es el booleano 'true'.",
    "interviewTip": "Esto es similar a los atributos HTML como 'disabled' o 'required'.",
    "options": ["\"isActive\"", "undefined", "true", "null"]
  },
  "pc-11": {
    "prompt": "¿Cuál es la mejor manera de pasar múltiples piezas de datos relacionadas (ej., nombre de usuario, email, avatar)?",
    "explanation": "Pasar un único objeto hace que la API del componente sea más limpia y fácil de actualizar, especialmente si la estructura de datos viene directamente de una API.",
    "interviewTip": "Si el componente solo necesita un pequeño campo del objeto, pasar props individuales podría ser mejor para el rendimiento y el desacoplamiento.",
    "options": [
      "Pasarlas todas como props individuales.",
      "Combinarlas en una sola prop de objeto (ej., user={userObj}).",
      "Ambas son válidas, pero una prop de objeto suele ser más limpia para datos relacionados.",
      "Las variables globales son mejores para esto."
    ]
  },
  "pc-12": {
    "prompt": "¿Puedes pasar otro componente de React como una prop a un componente?",
    "explanation": "Este es un patrón poderoso para 'Slots'. Te permite inyectar componentes de UI en partes específicas de un diseño.",
    "interviewTip": "Esto a menudo se prefiere sobre el anidamiento profundo o la lógica condicional compleja dentro del componente.",
    "options": [
      "No, las props solo pueden ser tipos de datos primitivos.",
      "Sí, los elementos son objetos de JavaScript y pueden pasarse como props.",
      "Solo a través de la prop children.",
      "Solo si usas el prefijo 'render'."
    ]
  },
  "pc-13": {
    "prompt": "¿Qué se registrará en la consola?",
    "explanation": "React 'congela' el objeto de las props. Intentar mutarlo lanzará un error o fallará silenciosamente, dependiendo del entorno.",
    "interviewTip": "Si necesitas cambiar datos, esos datos deben ser 'Estado' (State), no 'Props'.",
    "options": [
      "\"Alice\"",
      "TypeError (en modo estricto) porque las props son de solo lectura.",
      "undefined",
      "El estado del padre se actualizará a 'Alice'."
    ]
  },
  "pc-14": {
    "prompt": "¿Cuáles de los siguientes tipos de datos se pueden pasar como props en React?",
    "explanation": "Las props son simplemente JavaScript. Cualquier cosa que pueda asignarse a una variable en JS puede pasarse como prop.",
    "interviewTip": "Esta flexibilidad es la razón por la que React es tan componible.",
    "options": [
      "Funciones",
      "Objetos y Arrays",
      "Números y Booleanos",
      "Otros elementos JSX"
    ]
  },
  "pc-15": {
    "prompt": "¿Cuál es el resultado de la expresión lógica en esta asignación de prop?",
    "explanation": "Las llaves permiten poner cualquier expresión de JS. El resultado de la expresión (true/false) es lo que se pasa como valor de la prop.",
    "interviewTip": "Esta es una forma limpia de manejar estados de UI directamente en la plantilla.",
    "options": [
      "El botón se deshabilita si isLoading o isError es true.",
      "El botón se deshabilita solo si ambos son true.",
      "La prop se ignora porque contiene lógica.",
      "Un error de sintaxis."
    ]
  },
  "pc-16": {
    "prompt": "¿Cómo accedes al valor de una prop en un componente funcional?",
    "explanation": "Los componentes funcionales reciben 'props' como su primer parámetro. Puedes usar props.name o desestructurarlo inmediatamente.",
    "interviewTip": "La desestructuración es el estándar: const MyComponent = ({ name }) => { ... }",
    "options": [
      "this.props.name",
      "Desde el primer argumento de la función.",
      "Usando el hook useProps().",
      "Importándolo desde React."
    ]
  },
  "pc-17": {
    "prompt": "¿Para qué se utiliza la librería 'Prop-Types'?",
    "explanation": "Prop-Types te permite declarar el tipo esperado (string, número, etc.) para cada prop. React mostrará una advertencia en la consola si se pasa el tipo incorrecto.",
    "interviewTip": "Aunque TypeScript ha reemplazado en gran medida a Prop-Types en proyectos modernos, todavía se usa ampliamente en muchas bases de código existentes.",
    "options": [
      "Para acelerar la entrega de props.",
      "Para realizar comprobaciones de tipos en tiempo de ejecución en las props y detectar errores durante el desarrollo.",
      "Para convertir props en strings JSON.",
      "Para generar documentación automáticamente."
    ]
  }
}
