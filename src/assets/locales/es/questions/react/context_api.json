{
  "ca-01": {
    "prompt": "¿Cuáles son los tres pasos principales para implementar React Context?",
    "options": [
      "Crear el Context, definir el State, exportar el componente.",
      "Crear el Context, proveer el Context, consumir el Context.",
      "Inicializar el Ref, pasar la Prop, disparar el Effect.",
      "Importar Redux, configurar el Store, mapear el Dispatch."
    ],
    "explanation": "Primero se crea el objeto context, se envuelve el árbol padre con un Provider y luego se utiliza un hook o consumer en el hijo para acceder a los datos.",
    "interviewTip": "La forma más común de 'consumir' hoy en día es a través del hook 'useContext'."
  },
  "ca-02": {
    "prompt": "¿Qué sucede con los componentes que consumen un Context cuando la prop 'value' del Provider se actualiza?",
    "options": [
      "Solo el componente padre se vuelve a renderizar.",
      "Todos los componentes de la app se vuelven a renderizar.",
      "Todos los componentes que llaman a 'useContext' para ese contexto específico se volverán a renderizar.",
      "No sucede nada hasta que se refresque la página."
    ],
    "explanation": "Context dispara un re-render para todos los consumidores siempre que el valor cambia. Por eso se deben mantener los valores del contexto estables o dividir los contextos grandes.",
    "interviewTip": "Para optimizar, considera memorizar el objeto del valor del contexto usando 'useMemo'."
  },
  "ca-03": {
    "prompt": "¿Cuál es el resultado del siguiente código si 'UserContext' no tiene un Provider por encima del Header?",
    "code": "const UserContext = createContext('Guest');\nfunction Header() {\n  const user = useContext(UserContext);\n  return <h1>{user}</h1>;\n}",
    "options": [
      "La app colapsa con un error 'ProviderNotFound'.",
      "Renderiza 'Guest'.",
      "No renderiza nada (null).",
      "Renderiza 'undefined'."
    ],
    "explanation": "Si no se encuentra ningún Provider en el árbol, 'useContext' devuelve el valor por defecto pasado a 'createContext(defaultValue)'.",
    "interviewTip": "Los valores por defecto son útiles para probar componentes de forma aislada sin envolverlos en providers."
  },
  "ca-04": {
    "prompt": "¿Cuáles de los siguientes son buenos casos de uso para React Context?",
    "options": [
      "Gestionar el tema actual (modo Oscuro/Claro).",
      "Almacenar el texto de un único campo de entrada de búsqueda.",
      "Manejar la autenticación de usuario / perfil de usuario actual.",
      "Gestionar datos complejos de alta frecuencia como coordenadas de un juego en tiempo real."
    ],
    "explanation": "Context es ideal para datos 'globales' que no cambian con demasiada frecuencia. Para actualizaciones de alta frecuencia, Context puede causar cuellos de botella en el rendimiento.",
    "interviewTip": "Para estados de alta frecuencia, librerías como Redux, Zustand o Recoil suelen ser mejores opciones."
  },
  "ca-05": {
    "prompt": "Analiza el código. ¿Cómo debería estructurarse 'App' para compartir 'theme'?",
    "code": "const ThemeContext = createContext();\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext.Provider value={theme}>\n      <Layout />\n    </ThemeContext.Provider>\n  );\n}",
    "options": [
      "El código es correcto tal cual.",
      "El Provider necesita una prop 'state' en lugar de 'value'.",
      "El ThemeContext.Provider debería estar fuera de la función App.",
      "Debes envolver el Provider en otro div."
    ],
    "explanation": "La prop 'value' es la forma estándar de pasar datos al árbol de Context. Cualquier componente dentro de <Layout /> puede ahora acceder a 'theme'.",
    "interviewTip": "Si también quieres permitir que los hijos cambien el tema, pasa `{ theme, setTheme }` como valor."
  },
  "ca-06": {
    "prompt": "¿Por qué se prefiere 'useContext' sobre el antiguo componente 'Context.Consumer'?",
    "options": [
      "Hace que el código sea más eficiente.",
      "Evita el 'wrapper hell' y los render props anidados, logrando un código más plano y legible.",
      "Permite que Context se use en componentes de clase (Class components).",
      "Memoriza automáticamente los datos."
    ],
    "explanation": "Antes de los hooks, tenías que usar un patrón de render prop que hacía que el árbol JSX fuera muy profundo y difícil de seguir.",
    "interviewTip": "Aplanar el árbol de componentes es una de las principales victorias estéticas de la API de Hooks."
  },
  "ca-07": {
    "prompt": "¿Se pueden usar múltiples Providers en una sola aplicación?",
    "options": [
      "No, React solo permite un Context por aplicación.",
      "Sí, y puedes anidarlos para proveer diferentes tipos de datos (ej. Auth, Theme, Settings).",
      "Sí, pero solo si son para el mismo objeto Context.",
      "Solo si usas el hook 'useMultiContext'."
    ],
    "explanation": "Anidar providers es una práctica estándar. Un componente siempre consumirá el valor del provider *más cercano* de ese contexto específico que esté por encima de él en el árbol.",
    "interviewTip": "A esto se le suele llamar 'Context Composition'."
  },
  "ca-08": {
    "prompt": "¿Cuál es el riesgo principal de poner demasiados datos en un solo objeto Context?",
    "options": [
      "Los datos se corromperán.",
      "Re-renders innecesarios: si cualquier parte del objeto context cambia, todos los componentes que consumen ese contexto se volverán a renderizar.",
      "El tamaño de archivo de la app se duplicará.",
      "Evita el uso de hooks personalizados."
    ],
    "explanation": "Debido a que las actualizaciones de Context disparan un re-render para todos los consumidores, los contextos 'monolíticos' grandes pueden provocar retrasos en el rendimiento.",
    "interviewTip": "La solución es el 'Context Splitting': crear contextos separados para datos lógicamente diferentes (ej. UserContext y ThemeContext)."
  },
  "ca-09": {
    "prompt": "¿Cómo se proporciona una función a través de Context para permitir que los hijos actualicen el estado?",
    "explanation": "Los valores de Context pueden ser cualquier tipo de JS. Pasar un objeto que contenga tanto el estado como su setter es el patrón más común para la gestión del estado global.",
    "interviewTip": "Asegúrate siempre de que el objeto pasado a 'value' esté memorizado si se define dentro de un componente, de lo contrario, creará una nueva referencia en cada render.",
    "options": [
      "No se pueden pasar funciones a través de Context.",
      "Incluir la función en el objeto pasado a la prop 'value'.",
      "Usar un 'FunctionProvider' separado.",
      "Llamar a la función directamente en las etiquetas del Provider."
    ]
  },
  "ca-10": {
    "prompt": "Identifica el error en esta lógica de Consumer:",
    "explanation": "El objeto context en sí mismo es solo un descriptor. Debes usar el hook 'useContext' para 'extraer' el valor de ese contexto.",
    "interviewTip": "Piensa en el objeto Context como una 'Llave' y en 'useContext' como la 'Cerradura' que la abre.",
    "options": [
      "theme debe ser un string.",
      "Debes llamar a useContext(ThemeContext) para obtener el valor real.",
      "A la prop style le falta un punto y coma.",
      "Display debe estar en mayúsculas."
    ]
  },
  "ca-11": {
    "prompt": "¿Cuáles de estas son formas válidas de evitar problemas de rendimiento con Context?",
    "explanation": "La división (splitting) y la memorización son las dos estrategias más efectivas. Mover un provider a una posición más alta en realidad aumenta el número de componentes potenciales afectados por un render.",
    "interviewTip": "Si 'React.memo' no ayuda, el cuello de botella es probablemente el valor del contexto mismo cambiando con demasiada frecuencia.",
    "options": [
      "Dividir un contexto grande en múltiples contextos más pequeños.",
      "Usar 'React.memo' en los componentes consumidores.",
      "Mover el Provider a una posición más alta en el árbol.",
      "Memorizar la prop 'value' del Provider usando 'useMemo'."
    ]
  },
  "ca-12": {
    "prompt": "¿Qué sucede si un componente llama a 'useContext' pero su Provider padre es desmontado posteriormente?",
    "explanation": "Cuando el Provider desaparece, el hook busca hacia arriba en el árbol y, al no encontrar nada, recurre al valor por defecto original definido en 'createContext'.",
    "interviewTip": "Esto asegura que el componente se mantenga 'seguro' incluso durante cambios dinámicos en el diseño.",
    "options": [
      "El componente colapsará.",
      "El componente volverá al valor por defecto definido en 'createContext'.",
      "El componente mantendrá el último valor conocido para siempre.",
      "El componente se desmontará automáticamente también."
    ]
  }
}
