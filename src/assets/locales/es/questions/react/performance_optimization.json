{
  "po-01": {
    "prompt": "What is the primary purpose of 'React.lazy' and 'Suspense'?",
    "explanation": "React.lazy allows you to render a dynamic import as a regular component. Suspense provides a fallback UI (like a spinner) while that component is loading.",
    "interviewTip": "This reduces the initial bundle size, which improves the 'Time to Interactive' metric."
  },
  "po-02": {
    "prompt": "Analyze the code. What happens to 'HugeComponent' when the app first loads?",
    "explanation": "By using dynamic import(), the build tool (like Webpack or Vite) creates a separate chunk for this component that is fetched over the network only when needed.",
    "interviewTip": "Lazy loading is best used for components that aren't immediately visible, like Modals or separate Routes."
  },
  "po-03": {
    "prompt": "Which of these are effective ways to identify performance bottlenecks in a React app?",
    "explanation": "The Profiler shows which components rendered and why. 'Highlight updates' gives visual feedback on re-renders, and the Network tab helps identify bloated code.",
    "interviewTip": "The Profiler's 'Flamegraph' helps pinpoint exactly which component in a deep tree is causing a lag."
  },
  "po-04": {
    "prompt": "What is 'Windowing' (or Virtualization) used for?",
    "explanation": "If you have 10,000 items, rendering them all creates 10,000+ DOM nodes, which slows the browser. Windowing keeps the DOM small (e.g., only 20 nodes).",
    "interviewTip": "Mention libraries like 'react-window' or 'react-virtualized' as the industry standard for this."
  },
  "po-05": {
    "prompt": "What happens to the performance if you define a component inside another component's body?",
    "explanation": "Because the component function is recreated, React sees it as a completely new type every time. This destroys all state of the child and forces a full remount.",
    "interviewTip": "Always define your components outside the main function or in separate files."
  },
  "po-06": {
    "prompt": "What is 'Throttling' and 'Debouncing' in the context of React events?",
    "explanation": "Debouncing waits for a pause in activity (e.g., typing), while Throttling limits calls to once every X milliseconds (e.g., scrolling).",
    "interviewTip": "Use 'lodash.debounce' or similar utilities to prevent 100 API calls as a user types a single word."
  },
  "po-07": {
    "prompt": "How does 'Transition API' (useTransition) help with performance in React 18+?",
    "explanation": "startTransition tells React that an update (like filtering a massive list) can be interrupted by more urgent tasks like typing or clicking.",
    "interviewTip": "Use 'useTransition' to prevent the UI from 'freezing' during heavy rendering tasks."
  },
  "po-08": {
    "prompt": "What is the benefit of moving state down to a child component?",
    "explanation": "This is called 'Localizing State'. If only the Modal needs to know if it's open, keep that state there to avoid rendering the whole App whenever it toggles.",
    "interviewTip": "Before using useMemo, always check if you can simply restructure your component tree to avoid re-renders."
  },
  "po-09": {
    "prompt": "Why is 'index' as a key bad for performance in a dynamic list?",
    "explanation": "If the list reorders, the item at index 0 changes, but the key '0' remains. React thinks the content changed rather than the item moving.",
    "interviewTip": "Stable keys (like IDs) allow React to simply 'move' DOM nodes instead of re-creating them."
  },
  "po-10": {
    "prompt": "What does the 'useDeferredValue' hook do?",
    "explanation": "Similar to useTransition, but for values. It gives you a 'deferred' version of a value that 'lags behind' the urgent update, keeping the UI smooth.",
    "interviewTip": "Perfect for a search input where the input updates instantly, but the results list updates slightly later."
  },
  "po-11": {
    "prompt": "Which of these patterns can lead to memory leaks in React?",
    "explanation": "When a component unmounts, global things like timers and event listeners stay in memory unless you manually stop them.",
    "interviewTip": "Always use the return function in useEffect to clean up your mess!"
  },
  "po-12": {
    "prompt": "What is the result of using 'inline functions' as props for a component wrapped in 'React.memo'?",
    "explanation": "React.memo uses shallow comparison. `() => {} !== () => {}`, so the memoization check fails.",
    "interviewTip": "Pair 'React.memo' with 'useCallback' on the parent function to make the optimization work."
  }
}
