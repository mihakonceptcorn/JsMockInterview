{
  "le-01": {
    "prompt": "¿Cuándo se ejecuta por defecto el código dentro de un bloque useEffect si no se proporciona un array de dependencias?",
    "explanation": "Sin un array de dependencias, useEffect se ejecuta después de cada ciclo de renderizado. Esto suele evitarse para prevenir problemas de rendimiento.",
    "interviewTip": "Sé siempre intencional con tu array de dependencias para evitar bucles infinitos.",
    "options": [
      "Solo cuando el componente se desmonta.",
      "Después de cada renderizado del componente.",
      "Solo después del primer renderizado (mount).",
      "Solo cuando cambia el estado."
    ]
  },
  "le-02": {
    "prompt": "¿Cómo te aseguras de que un useEffect solo se ejecute una vez, similar a 'componentDidMount'?",
    "explanation": "Un array de dependencias vacío [] le indica a React que el efecto no depende de ningún valor de props o state, por lo que nunca necesita volver a ejecutarse.",
    "interviewTip": "Incluso con un array vacío, en el 'Strict Mode' de desarrollo de React 18, los efectos podrían ejecutarse dos veces para ayudarte a encontrar errores de limpieza (cleanup).",
    "options": [
      "Pasando undefined.",
      "Pasando un valor null.",
      "Pasando un array vacío [].",
      "Omitiendo el segundo argumento."
    ]
  },
  "le-03": {
    "prompt": "¿Cuál es el propósito de la función retornada desde un hook useEffect?",
    "explanation": "La función de limpieza (cleanup) es esencial para prevenir fugas de memoria (como intervalos, listeners de eventos o suscripciones activas a APIs).",
    "interviewTip": "Limpia siempre los efectos secundarios que persistan más allá del ciclo de vida del componente.",
    "options": [
      "Inicializar el siguiente renderizado.",
      "Realizar la limpieza antes de que el componente se desmonte o antes de que el efecto se vuelva a ejecutar.",
      "Disparar un re-render del componente padre.",
      "Manejar errores dentro del efecto."
    ]
  },
  "le-04": {
    "prompt": "¿Cuáles de las siguientes son razones válidas para usar el hook useEffect?",
    "explanation": "El cálculo de valores a partir de props debe hacerse durante el renderizado (o vía useMemo). Los efectos son específicamente para 'efectos secundarios' que tocan cosas fuera del ecosistema de React.",
    "interviewTip": "Si puedes calcularlo durante el renderizado, no necesitas useEffect.",
    "options": [
      "Actualizar el título del documento basado en el estado.",
      "Calcular un valor a partir de dos props (ej., fullName = firstName + lastName).",
      "Obtener datos de una API externa.",
      "Iniciar o detener un temporizador/intervalo."
    ]
  },
  "le-05": {
    "prompt": "¿Qué sucederá si actualizas una variable de estado dentro de un useEffect sin un array de dependencias?",
    "explanation": "El renderizado dispara el efecto, el efecto actualiza el estado, la actualización del estado dispara un renderizado, y el ciclo se repite infinitamente.",
    "interviewTip": "Si ves que los ventiladores de tu CPU se aceleran durante el desarrollo, revisa si falta un array de dependencias en un useEffect que llama a un setter.",
    "options": [
      "El contador se incrementará una vez y se detendrá.",
      "Causará un bucle infinito de re-renderizados.",
      "React lanzará un 'AutoLoopError'.",
      "La UI se actualizará suavemente a 60fps."
    ]
  },
  "le-06": {
    "prompt": "Analiza el array de dependencias a continuación. ¿Cuándo volverá a ejecutarse este efecto?",
    "explanation": "React realiza una comparación superficial (Object.is) en cada elemento del array. Si algún elemento cambia entre renderizados, el efecto se vuelve a ejecutar.",
    "interviewTip": "Ten cuidado al pasar objetos o arrays en el array de dependencias, ya que las nuevas referencias dispararán el efecto cada vez.",
    "options": [
      "En cada renderizado.",
      "Solo cuando 'userId' cambie (verificación de igualdad referencial).",
      "Solo cuando se llame a 'fetchData' manualmente.",
      "En cada evento de clic."
    ]
  },
  "le-07": {
    "prompt": "¿Cuál es la salida de la consola cuando el componente se desmonta?",
    "explanation": "La función de limpieza (B) se ejecuta solo cuando el componente se elimina del DOM si el array de dependencias está vacío.",
    "interviewTip": "Si el array tuviera dependencias, 'B' se ejecutaría antes de cada nueva ejecución de 'A' Y al desmontarse.",
    "options": ["A", "B", "A luego B", "Ninguna (la consola se limpia)"]
  },
  "le-08": {
    "prompt": "¿Cómo maneja React múltiples hooks useEffect en un solo componente?",
    "explanation": "React depende del orden de las llamadas a los Hooks para mantener el estado. Se ejecutan secuencialmente después de que el renderizado se confirma en la pantalla.",
    "interviewTip": "Usa múltiples efectos para separar lógicas no relacionadas (ej., uno para obtención de datos y otro para un listener de eventos).",
    "options": [
      "Solo ejecuta el primero.",
      "Los ejecuta en el orden en que están definidos.",
      "Los ejecuta en paralelo (orden aleatorio).",
      "Los combina en un solo efecto."
    ]
  },
  "le-09": {
    "prompt": "¿Por qué es importante incluir todos los valores reactivos (props, state) usados dentro del efecto en el array de dependencias?",
    "explanation": "Si un valor se usa dentro pero no se lista en las dependencias, la función del efecto 'recuerda' la versión de ese valor de cuando se creó por última vez, lo que provoca errores (stale closures).",
    "interviewTip": "El plugin 'eslint-plugin-react-hooks' es tu mejor amigo para detectar dependencias faltantes automáticamente.",
    "options": [
      "Para evitar cierres obsoletos (stale closures) donde el efecto usa valores viejos de un renderizado anterior.",
      "Para evitar que el componente se desmonte.",
      "Para acelerar el proceso de diffing del Virtual DOM.",
      "Es solo una sugerencia de linting, no es estrictamente necesario."
    ]
  },
  "le-10": {
    "prompt": "¿Cuál es el orden del 'Ciclo de Vida del Efecto' cuando las dependencias cambian?",
    "explanation": "React limpia el efecto del renderizado anterior antes de aplicar el nuevo para asegurar que no se solapen efectos secundarios obsoletos.",
    "interviewTip": "Por esto, limpiar una suscripción antes de empezar una nueva previene errores de 'listeners duplicados'.",
    "options": [
      "Se ejecuta el Nuevo Efecto -> Se ejecuta la Vieja Limpieza.",
      "Se ejecuta la Vieja Limpieza -> Se ejecuta el Nuevo Efecto.",
      "Se ejecutan al mismo tiempo.",
      "La limpieza solo se ejecuta al desmontar."
    ]
  },
  "le-11": {
    "prompt": "¿Qué sucede si retornas un string en lugar de una función desde useEffect?",
    "explanation": "useEffect espera que el valor de retorno sea una función (para la limpieza) o nada (undefined). Retornar cualquier otra cosa es un error.",
    "interviewTip": "Retornar una función async es un error común porque las funciones async devuelven una Promesa, no una función de limpieza.",
    "options": [
      "React registra 'Cleanup' en la consola.",
      "React lo ignora.",
      "React advertirá/lanzará un error porque espera una función o undefined.",
      "Se convierte en el nuevo estado."
    ]
  },
  "le-12": {
    "prompt": "¿Qué hook se utiliza para efectos secundarios que deben ocurrir de forma síncrona *antes* de que el navegador pinte la pantalla?",
    "explanation": "useLayoutEffect se ejecuta al mismo tiempo que el viejo 'componentDidMount': después de las mutaciones del DOM pero antes de que el usuario las vea. Es útil para medir elementos del DOM.",
    "interviewTip": "Prefiere useEffect en el 99% de los casos para evitar bloquear las actualizaciones visuales.",
    "options": [
      "useEffect",
      "useLayoutEffect",
      "useSyncEffect",
      "useBeforeRender"
    ]
  },
  "le-13": {
    "prompt": "¿Cómo deberías manejar una función async dentro de useEffect?",
    "explanation": "No puedes hacer que el callback del efecto sea async porque devolvería una Promesa en lugar de una función de limpieza. Debes definir la función async dentro del efecto.",
    "interviewTip": "Definirla dentro del efecto también facilita el manejo de la limpieza (como usar AbortController).",
    "options": [
      "El código anterior es la forma correcta.",
      "Hacer todo el efecto async: useEffect(async () => ...).",
      "Usar solo .then(), async/await está prohibido.",
      "Llamar a la función async fuera del componente."
    ]
  },
  "le-14": {
    "prompt": "¿Qué es la fase de 'Mounting' en React?",
    "explanation": "Mounting es el inicio de la vida de un componente en el DOM.",
    "interviewTip": "useEffect con [] es la forma más común de manejar la lógica 'onMount'.",
    "options": [
      "Cuando un componente se está actualizando con nuevas props.",
      "Cuando un componente se está creando e insertando en el DOM.",
      "Cuando un componente se elimina de la pantalla.",
      "Cuando el usuario hace clic en el componente."
    ]
  },
  "le-15": {
    "prompt": "¿Cuál de estos disparará una nueva ejecución de un efecto con [data] como dependencia?",
    "explanation": "React usa igualdad superficial. Un nuevo objeto literal `{}` es siempre una referencia diferente, incluso si las propiedades parecen iguales.",
    "interviewTip": "Por esto usamos el spread: `setData({...data})`.",
    "options": [
      "setData({ count: 0 }) // Nueva referencia de objeto.",
      "data.count = 1; setData(data); // Misma referencia de objeto.",
      "setData(prev => ({ ...prev, count: 1 })) // Nueva referencia de objeto.",
      "Llamar a setData con el mismo valor de string 'hello' si data era 'hello'."
    ]
  },
  "le-16": {
    "prompt": "¿Cuál es la salida de la consola cuando la dependencia 'count' cambia de 1 a 2?",
    "explanation": "Cuando las dependencias cambian, React primero ejecuta la limpieza del efecto anterior y luego el nuevo efecto.",
    "interviewTip": "Esto asegura que el mundo 'viejo' se limpie antes de que comience el mundo 'nuevo'.",
    "options": [
      "Effect",
      "Cleanup luego Effect",
      "Effect luego Cleanup",
      "Cleanup"
    ]
  },
  "le-17": {
    "prompt": "¿Es seguro omitir una función del array de dependencias si está definida dentro del componente?",
    "explanation": "En JS, `function a(){}` !== `function a(){}` si se crean en diferentes ciclos de renderizado. Usa `useCallback` para mantener estables las referencias de las funciones.",
    "interviewTip": "Mover la función *dentro* del useEffect es a menudo la solución más simple.",
    "options": [
      "Sí, las funciones nunca cambian.",
      "No, las funciones se recrean en cada renderizado y dispararán el efecto cada vez a menos que estén memorizadas.",
      "Solo si la función no usa el estado.",
      "Sí, React ignora las funciones en las dependencias."
    ]
  }
}
