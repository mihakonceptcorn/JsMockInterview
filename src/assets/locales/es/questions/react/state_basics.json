{
  "sb-01": {
    "prompt": "¿Qué sucede cuando actualizas una variable de estado (state) de React usando su función setter?",
    "explanation": "Llamar al setter del estado notifica a React que los datos subyacentes han cambiado, lo que dispara un re-renderizado para sincronizar la UI con los nuevos datos.",
    "interviewTip": "Recuerda que las actualizaciones de estado son asíncronas y se procesan por lotes (batched) para mejorar el rendimiento.",
    "options": [
      "La ventana del navegador se recarga para obtener nuevos datos.",
      "El componente y sus hijos son programados para un re-renderizado.",
      "La variable se actualiza, pero la UI permanece igual hasta un refresco manual.",
      "Todo el estado de la aplicación se restablece a sus valores iniciales."
    ]
  },
  "sb-02": {
    "prompt": "¿Cuál es la forma correcta de inicializar una variable de estado 'count' en 0?",
    "explanation": "useState devuelve un array donde el primer elemento es el estado actual y el segundo es la función de actualización. Usamos la desestructuración de arrays para nombrarlos.",
    "interviewTip": "Usa siempre 'const' para las variables de estado porque nunca debes mutarlas directamente; solo el setter debe cambiarlas.",
    "options": [
      "const [count, setCount] = useState(0);",
      "const count = useState(0);",
      "let [count, setCount] = useState(0);",
      "const [setCount, count] = useState(0);"
    ]
  },
  "sb-03": {
    "prompt": "¿Cuál será el valor de 'count' mostrado en la UI después de hacer clic en el botón una vez?",
    "explanation": "Debido a que 'count' se captura del entorno (scope) del renderizado actual, las tres llamadas ven 'count' como 0. React las agrupa y el resultado es 0 + 1.",
    "interviewTip": "Este es un ejemplo clásico de 'Stale Closure'. Para solucionarlo, usa el patrón de actualización funcional: setCount(prev => prev + 1).",
    "options": ["3", "0", "1", "undefined"]
  },
  "sb-04": {
    "prompt": "¿Cuál de las siguientes afirmaciones es cierta respecto a las Reglas de los Hooks?",
    "explanation": "Los Hooks deben seguir un orden de llamada constante. Colocarlos en bucles o condiciones rompe la capacidad de React para rastrear el estado correctamente.",
    "interviewTip": "Si necesitas un hook condicional, pon la condición *dentro* del hook (como en useEffect) en lugar de envolver al hook en sí.",
    "options": [
      "Los Hooks deben llamarse en el nivel superior del componente.",
      "Los Hooks pueden llamarse dentro de bucles si la longitud del array es constante.",
      "Los Hooks solo pueden llamarse desde componentes funcionales de React o hooks personalizados.",
      "Los Hooks pueden llamarse dentro de sentencias 'if' si la condición se basa en props."
    ]
  },
  "sb-05": {
    "prompt": "¿Cómo se actualiza correctamente un estado de tipo objeto preservando los campos existentes?",
    "explanation": "La función setter reemplaza el estado por completo. Para actualizar un campo, debes expandir (spread) el estado existente y sobrescribir el campo de interés.",
    "interviewTip": "Mutar directamente 'user.age' falla porque React usa Object.is para verificar cambios. Si la referencia del objeto es la misma, no hay renderizado.",
    "options": [
      "setUser({ age: 26 });",
      "user.age = 26; setUser(user);",
      "setUser({ ...user, age: 26 });",
      "setUser(Object.assign(user, { age: 26 }));"
    ]
  },
  "sb-06": {
    "prompt": "¿Cuál es el beneficio principal del patrón 'Lazy Initializer'?",
    "explanation": "Si pasas un valor inicial directamente, se calcula en cada renderizado. Si pasas una función, React solo la ejecuta durante el primer renderizado.",
    "interviewTip": "Usa esto para tareas costosas como parsear un JSON grande de storage o cálculos matemáticos complejos.",
    "options": [
      "Hace que la actualización de estado sea asíncrona.",
      "Asegura que la función solo se ejecute una vez durante el montaje inicial.",
      "Cachea automáticamente el resultado en localStorage.",
      "Permite que el estado se comparta con otros componentes."
    ]
  },
  "sb-07": {
    "prompt": "¿Cómo accedes al valor de un campo de entrada en un 'Componente Controlado'?",
    "explanation": "El objeto de evento sintético 'e' de React contiene una propiedad 'target' que apunta al elemento del DOM, el cual tiene la propiedad 'value'.",
    "interviewTip": "En los componentes controlados, el estado es la 'única fuente de verdad' para el valor del input.",
    "options": ["e.target.value", "e.value", "text.current", "this.input.value"]
  },
  "sb-08": {
    "prompt": "¿Qué es un 'SyntheticEvent' en React?",
    "explanation": "React crea estos envoltorios para que los eventos se comporten de forma idéntica en Chrome, Safari, Firefox y Edge.",
    "interviewTip": "Aún puedes acceder al evento nativo del navegador a través de 'e.nativeEvent' si es absolutamente necesario.",
    "options": [
      "Un evento creado por una librería como Redux.",
      "Un envoltorio multiplataforma alrededor del evento nativo del navegador.",
      "Un evento que realmente no existe en el DOM.",
      "Una forma de simular clics de usuario durante pruebas automatizadas."
    ]
  },
  "sb-09": {
    "prompt": "¿Qué sucederá si actualizas el estado con exactamente el mismo valor que tiene actualmente?",
    "explanation": "React usa Object.is para comparar el nuevo estado con el viejo. Si son idénticos, React evita el trabajo innecesario de renderizar.",
    "interviewTip": "Por esto mutar un array y llamar a setState(mismoArray) no funciona: la referencia es idéntica.",
    "options": [
      "React re-renderizará exactamente una vez más.",
      "React cancelará y omitirá el re-renderizado por completo.",
      "El componente se desmontará y se volverá a montar.",
      "La app lanzará un 'IdentityError'."
    ]
  },
  "sb-10": {
    "prompt": "Analiza el código. ¿Cuál es la salida de la consola después de hacer clic en el botón?",
    "explanation": "Establecer el estado es asíncrono. La variable 'val' pertenece al marco de ejecución actual y no cambia hasta el próximo renderizado.",
    "interviewTip": "Si necesitas realizar una acción después de que el estado se actualice, usa el hook 'useEffect'.",
    "options": ["20", "10", "undefined", "null"]
  },
  "sb-11": {
    "prompt": "¿Cuáles de estas son formas válidas de disparar una función cuando un usuario hace clic en un botón?",
    "explanation": "La opción A pasa una referencia. La C crea una función anónima. La D es incorrecta porque ejecuta la función *durante* el renderizado.",
    "interviewTip": "Cuidado con 'onClick={handleClick()}'; causará un bucle infinito si handleClick actualiza el estado.",
    "options": [
      "onClick={handleClick}",
      "onclick={handleClick}",
      "onClick={() => handleClick()}",
      "onClick={handleClick()}"
    ]
  },
  "sb-12": {
    "prompt": "¿Cómo limpias un intervalo creado dentro de un componente cuando usas temporizadores de estado?",
    "explanation": "Para evitar fugas de memoria y comportamientos inesperados, debes limpiar los efectos secundarios como intervalos cuando un componente se desmonta.",
    "interviewTip": "Esta es una parte clave de la gestión del ciclo de vida del componente.",
    "options": [
      "Llamar a deleteInterval() en el clic del botón.",
      "Usar la función de limpieza (cleanup) de un hook useEffect.",
      "Establecer la variable del intervalo en null.",
      "React limpia todos los intervalos automáticamente en cada renderizado."
    ]
  },
  "sb-13": {
    "prompt": "¿Qué es el 'State Lifting' (Elevación de Estado)?",
    "explanation": "Cuando dos componentes hermanos necesitan estar sincronizados, mueves el estado a su padre común y se lo pasas de vuelta a través de props.",
    "interviewTip": "Esta es la forma estándar de compartir estado sin usar Context.",
    "options": [
      "Una forma de hacer que el estado esté disponible globalmente.",
      "Mover el estado al padre común más cercano de los componentes que necesitan compartirlo.",
      "Eliminar el estado de un componente para mejorar el rendimiento.",
      "Usar una librería como Redux para manejar el estado."
    ]
  },
  "sb-14": {
    "prompt": "¿Cuál es el valor por defecto de 'event.preventDefault()' en el 'onSubmit' de un formulario?",
    "explanation": "Por defecto, los formularios HTML recargan la página. En las 'Single Page Apps' de React, evitamos esto para manejar el envío vía JS.",
    "interviewTip": "Recuerda siempre esto en los manejadores de formularios para evitar perder el estado de tu aplicación.",
    "options": [
      "Evita que el navegador recargue la página.",
      "Limpia el estado de todos los campos de entrada.",
      "Valida los datos del formulario automáticamente.",
      "Evita que el usuario haga clic en el botón de enviar dos veces."
    ]
  },
  "sb-15": {
    "prompt": "¿Cómo se maneja correctamente una actualización de estado que depende del estado anterior?",
    "explanation": "Las actualizaciones funcionales garantizan que estás trabajando con el estado más reciente, incluso si hay múltiples actualizaciones en cola.",
    "interviewTip": "Este patrón es esencial cuando las actualizaciones de estado se disparan rápidamente (como en un intervalo o eventos de alta frecuencia).",
    "options": [
      "Pasando una función al setter (Actualización Funcional).",
      "Pasando la variable actualizada directamente.",
      "Usando una variable global para el cálculo.",
      "Llamando a useState de nuevo."
    ]
  },
  "sb-16": {
    "prompt": "¿Dónde puedes definir el estado en un componente funcional?",
    "explanation": "Según las Reglas de los Hooks, deben llamarse en la parte superior de la función de tu componente.",
    "interviewTip": "React usa el orden de llamada para mapear el estado a la instancia correcta del componente.",
    "options": [
      "En cualquier lugar dentro del cuerpo de la función.",
      "Dentro de los manejadores de eventos.",
      "Solo en el nivel superior de la función del componente.",
      "Dentro de la sentencia return."
    ]
  },
  "sb-17": {
    "prompt": "¿Qué es un 'Componente No Controlado'?",
    "explanation": "En los componentes no controlados, los datos del formulario son manejados por el propio DOM. Usas 'useRef' para obtener los valores cuando los necesitas.",
    "interviewTip": "Los componentes controlados suelen preferirse para formularios complejos, mientras que los no controlados están bien para inputs simples y puntuales.",
    "options": [
      "Un componente que no usa estado y depende del DOM (vía Refs) para los datos.",
      "Un componente que tiene un error que causa re-renderizados infinitos.",
      "Un componente que no acepta ninguna prop.",
      "Un componente que no es parte del Virtual DOM."
    ]
  }
}
