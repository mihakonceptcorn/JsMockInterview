{
  "ss-01": {
    "prompt": "¿Cuál es el problema principal que resuelve React Query en comparación con el uso de useEffect para la obtención de datos?",
    "explanation": "Aunque `useEffect` puede obtener datos, no gestiona el `caching` ni el re-fetch en segundo plano. React Query gestiona el ciclo de vida de los datos del servidor para que tú no tengas que hacerlo.",
    "interviewTip": "Menciona que React Query trata el 'Estado del Servidor' como algo que el cliente no posee, sino que simplemente pide prestado.",
    "options": [
      "Hace que las peticiones a la API se ejecuten más rápido en el servidor.",
      "Proporciona `caching` y sincronización integrados, evitando peticiones de red duplicadas innecesarias.",
      "Reemplaza la necesidad de cualquier CSS en la aplicación.",
      "Permite que React se conecte directamente a una base de datos SQL."
    ]
  },
  "ss-02": {
    "prompt": "Analiza el código. ¿Qué contiene 'data' mientras 'isLoading' es true?",
    "explanation": "Durante la primera petición (estado de carga inicial), 'data' es `undefined` hasta que la promesa se resuelve.",
    "interviewTip": "Si tienes datos en caché de una sesión anterior, 'isLoading' podría ser false mientras 'isFetching' es true.",
    "options": [
      "La versión anterior de los datos.",
      "Un array vacío [].",
      "undefined",
      "Un string de marcador de posición 'Cargando...'"
    ]
  },
  "ss-03": {
    "prompt": "¿Para qué se utiliza el 'queryKey' en React Query?",
    "explanation": "El `queryKey` (generalmente un array) le indica a React Query cuándo volver a obtener datos. Si la clave cambia (ej., ['user', id]), la consulta se ejecuta automáticamente de nuevo.",
    "interviewTip": "Piensa en el `queryKey` como el 'dependency array' para tus datos del servidor.",
    "options": [
      "Es la contraseña utilizada para acceder a la API.",
      "Actúa como un identificador único para la consulta para gestionar el `caching` y el seguimiento de dependencias.",
      "Es la URL del endpoint de la API.",
      "Define el orden en el que se ejecutan las consultas."
    ]
  },
  "ss-04": {
    "prompt": "¿Qué propiedades devuelve el hook 'useQuery' para ayudar a gestionar los estados de la UI?",
    "explanation": "`useQuery` proporciona un rico conjunto de flags booleanos y objetos de datos para manejar cada estado de red posible.",
    "interviewTip": "La diferencia entre 'isLoading' e 'isFetching' es una pregunta común de nivel senior (Carga inicial vs. Actualización en segundo plano).",
    "options": [
      "status (loading, error, success).",
      "isFetching (indica si la petición está actualmente en curso).",
      "revalidate (una función para eliminar la caché).",
      "error (el objeto de error si la petición falla)."
    ]
  },
  "ss-05": {
    "prompt": "¿Cómo se realizan las 'Mutaciones de Datos' (POST/PUT/DELETE) en React Query?",
    "explanation": "`useMutation` se utiliza para cualquier efecto secundario en el lado del servidor. Proporciona métodos como 'mutate' y 'mutateAsync' para disparar la llamada.",
    "interviewTip": "Menciona siempre la 'Invalidación': después de una mutación, generalmente querrás decirle a React Query que los datos antiguos ahora están obsoletos (`stale`).",
    "options": ["usePost", "useAction", "useMutation", "useUpdate"]
  },
  "ss-06": {
    "prompt": "¿Qué hace 'queryClient.invalidateQueries'?",
    "explanation": "Esta es la 'magia' de React Query. Después de actualizar los datos, invalidas la clave y la UI se refresca automáticamente con los últimos valores del servidor.",
    "interviewTip": "Esta es también la forma estándar de manejar los fallos en las 'Actualizaciones Optimistas'.",
    "options": [
      "Elimina todos los datos del servidor.",
      "Marca una consulta específica como 'obsoleta' (`stale`) y dispara un re-fetch en segundo plano si esa consulta se está usando actualmente.",
      "Evita que el usuario haga clic en el botón de enviar.",
      "Cierra todas las conexiones de red activas."
    ]
  },
  "ss-07": {
    "prompt": "¿Qué es el 'Stale Time' en React Query?",
    "explanation": "Por defecto, `staleTime` es 0, lo que significa que los datos se consideran obsoletos inmediatamente. Configurarlo con un valor más alto reduce el tráfico de red para datos que no cambian a menudo.",
    "interviewTip": "No confundas `staleTime` con `gcTime` (antes cacheTime). `gcTime` determina cuándo se eliminan de la memoria los datos inactivos.",
    "options": [
      "El tiempo que tarda una petición en expirar.",
      "La duración durante la cual los datos se consideran 'frescos' y no dispararán un re-fetch en segundo plano.",
      "La edad del navegador del usuario.",
      "El tiempo que el usuario pasa en una sola página."
    ]
  },
  "ss-08": {
    "prompt": "Identifica el problema en el siguiente fragmento de código:",
    "explanation": "El `queryFn` debe ser una función que React Query pueda llamar más tarde. Sintaxis correcta: `queryFn: () => fetchUser(id)`.",
    "interviewTip": "Este es un error frecuente que provoca bucles infinitos o ejecuciones en la fase incorrecta.",
    "options": [
      "El queryKey debe ser un string.",
      "fetchUser(id) se ejecuta inmediatamente durante el renderizado en lugar de ser una referencia a una función.",
      "La variable id debe ser un string.",
      "useQuery no soporta IDs."
    ]
  },
  "ss-09": {
    "prompt": "¿Cómo maneja React Query la pérdida de conexión a internet?",
    "explanation": "React Query tiene soporte integrado para modo offline y pausará/reanudará las peticiones basándose en el estado de conectividad del navegador.",
    "interviewTip": "Puedes personalizar el número de reintentos (`retry`) y el retraso (`retryDelay`) en la configuración global.",
    "options": [
      "Provoca un colapso en la aplicación.",
      "Reintenta automáticamente la consulta cuando se restaura la conexión.",
      "Muestra una pantalla azul de la muerte.",
      "Cambia a una base de datos SQL local."
    ]
  },
  "ss-10": {
    "prompt": "¿Qué es una 'Actualización Optimista' (Optimistic Update)?",
    "explanation": "Actualizas la caché manualmente cuando el usuario hace clic en 'Enviar'. Si el servidor falla, haces un 'roll back' al estado anterior.",
    "interviewTip": "Esto hace que tu app se sienta 'instantánea' incluso en conexiones lentas.",
    "options": [
      "Una forma de actualizar la UI inmediatamente antes de que el servidor confirme el cambio.",
      "Un método para acelerar el tiempo de respuesta del servidor.",
      "Una estrategia para manejar errores asumiendo el mejor escenario posible.",
      "Una característica que solo funciona con React 19."
    ]
  },
  "ss-11": {
    "prompt": "¿Qué componente es necesario en la raíz de tu app para usar React Query?",
    "explanation": "Debes crear un `const queryClient = new QueryClient()` y pasarlo al `<QueryClientProvider client={queryClient}>`.",
    "interviewTip": "Este provider contiene la 'Caché de Consultas', que es lo que permite compartir datos en toda la aplicación sin necesidad de Redux.",
    "options": [
      "<QueryProvider>",
      "<ReactQueryContext>",
      "<QueryClientProvider>",
      "<ServerStateProvider>"
    ]
  },
  "ss-12": {
    "prompt": "¿Cuál es el resultado de 'enabled: false' en las opciones de useQuery?",
    "explanation": "La opción `enabled` se utiliza para 'Consultas Dependientes' (esperar a un userId) o disparadores manuales.",
    "interviewTip": "Usa esto para evitar que una consulta se ejecute hasta que tengas todos los datos necesarios (como un ID de una consulta previa).",
    "options": [
      "La consulta se elimina.",
      "La consulta se deshabilita y solo se ejecutará si se llama a 'refetch' manualmente.",
      "La consulta se ejecuta una vez y luego se detiene.",
      "La consulta solo se ejecuta en el servidor."
    ]
  }
}
