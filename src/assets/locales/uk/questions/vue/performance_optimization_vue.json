{
  "perf-v-01": {
    "prompt": "Яку директиву слід використовувати для контенту, який ніколи не змінюється після початкового рендерингу, щоб пропустити відстеження та патчинг Virtual DOM?",
    "explanation": "v-once сприймає елемент та його дітей як статичний контент. Після першого рендерингу Vue повністю ігнорує його під час циклів оновлення, зменшуючи навантаження на Virtual DOM.",
    "interviewTip": "Використовуйте v-once для статичних текстів довідки або іконок усередині важких компонентів."
  },
  "perf-v-02": {
    "prompt": "Проаналізуйте код. У чому перевага використання 'v-memo' у цьому випадку?",
    "explanation": "v-memo (Vue 3.2+) мемоїзує піддерево шаблону. Воно оновлюється лише тоді, коли змінюються залежності у вказаному масиві. Це величезна оптимізація для великих списків, де одночасно змінюється лише один елемент.",
    "interviewTip": "v-memo — це по суті аналог 'React.memo', але для конкретної частини шаблону."
  },
  "perf-v-03": {
    "prompt": "Як 'shallowRef' допомагає з продуктивністю при роботі з масивними об'єктами (наприклад, величезною відповіддю JSON)?",
    "explanation": "Стандартний 'ref' є глибоким (deep). Для списку з 10 000 елементів Vue доводиться створювати тисячі Proxy. 'shallowRef' уникає цих витрат, запускаючи оновлення лише при повній заміні всього об'єкта.",
    "interviewTip": "Це основне рішення для інтеграції великих сторонніх бібліотек (як-от OpenLayers або Three.js) у Vue."
  },
  "perf-v-04": {
    "prompt": "Проаналізуйте код. Чому ця властивість 'computed' може спричинити проблеми з продуктивністю?",
    "explanation": "Кешування computed працює лише тоді, коли результат запитується знову *без* зміни залежностей. Якщо вхідні дані оновлюються занадто швидко, ви виконуєте важке сортування 60 разів на секунду.",
    "interviewTip": "Розгляньте можливість дебаунсингу (debouncing) вхідних даних або винесення сортування у Web Worker, якщо обчислення занадто важке."
  },
  "perf-v-05": {
    "prompt": "Які з наведених практик є дружніми до 'Tree Shaking' у Vue 3?",
    "explanation": "Tree shaking дозволяє збирачу видаляти невикористовувані функції Vue із фінального JS-файлу. Vue 3 був переписаний як модульний саме з цією метою.",
    "interviewTip": "Згадайте, що ядро Vue 3 підтримує tree-shaking: якщо ви не використовуєте компонент `<Transition>`, він не потрапить у ваш фінальний бандл."
  },
  "perf-v-06": {
    "prompt": "Яке призначення утиліти 'markRaw'?",
    "explanation": "Деякі об'єкти (наприклад, складні екземпляри класів або React-компоненти всередині Vue) не повинні бути реактивними. markRaw позначає їх так, щоб Vue ігнорував їх, заощаджуючи ресурси.",
    "interviewTip": "Це життєво важливо при обгортанні зовнішніх бібліотек, які мають власне внутрішнє керування станом."
  },
  "perf-v-07": {
    "prompt": "Проаналізуйте код. Яка директива краща для компонента, що перемикає видимість 100 разів на хвилину?",
    "explanation": "v-show лише змінює CSS-властивість 'display: none'. v-if знищував би та створював компонент заново 100 разів, що дуже навантажує процесор.",
    "interviewTip": "Завжди пов'язуйте вибір із поняттями «Вартість ініціалізації» проти «Вартості виконання»."
  },
  "perf-v-08": {
    "prompt": "Що таке «Рендеринг віртуальних списків» (Virtual List Rendering або Windowing)?",
    "explanation": "Якщо у вас 10 000 елементів, рендеринг такої кількості DOM-вузлів призведе до зависання браузера. Віртуальні списки рендерять лише ті ~10 елементів, які користувач бачить у цей момент.",
    "interviewTip": "Згадайте бібліотеки на кшталт `vue-virtual-scroller` для високопродуктивних списків."
  },
  "pov-09": {
    "prompt": "Яке призначення директиви v-memo у Vue 3?",
    "explanation": "v-memo схожий на React.memo, але для шаблонів. Він особливо корисний для оптимізації великих списків v-for.",
    "interviewTip": "v-memo був представлений у Vue 3.2 і є найефективнішим у поєднанні з v-for."
  },
  "pov-10": {
    "prompt": "Як можна зменшити розмір бандла (bundle size) додатка Vue?",
    "explanation": "Розділення коду через динамічні імпорти дозволяє завантажувати лише той код, який потрібен для поточного маршруту, зменшуючи початковий розмір бандла.",
    "interviewTip": "Комбінуйте це з tree-shaking, правильною конфігурацією збірки та аналізом розміру бандла за допомогою таких інструментів, як webpack-bundle-analyzer."
  }
}
