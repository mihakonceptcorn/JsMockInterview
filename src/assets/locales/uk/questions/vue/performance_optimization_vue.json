{
  "perf-v-01": {
    "prompt": "Яку директиву слід використовувати для контенту, який ніколи не змінюється після початкового рендерингу, щоб пропустити відстеження та патчинг Virtual DOM?",
    "explanation": "v-once сприймає елемент та його дітей як статичний контент. Після першого рендерингу Vue повністю ігнорує його під час циклів оновлення, зменшуючи навантаження на Virtual DOM.",
    "interviewTip": "Використовуйте v-once для статичних текстів довідки або іконок усередині важких компонентів.",
    "options": [
      "v-memo",
      "v-once",
      "v-static",
      "v-pre"
    ]
  },
  "perf-v-02": {
    "prompt": "Проаналізуйте код. У чому перевага використання 'v-memo' у цьому випадку?",
    "explanation": "v-memo (Vue 3.2+) мемоїзує піддерево шаблону. Воно оновлюється лише тоді, коли змінюються залежності у вказаному масиві. Це величезна оптимізація для великих списків, де одночасно змінюється лише один елемент.",
    "interviewTip": "v-memo — це по суті аналог 'React.memo', але для конкретної частини шаблону.",
    "options": [
      "It prevents the item from ever being deleted.",
      "It only re-renders the specific item if its 'selected' state changes, even if other properties in the 'item' object change.",
      "It automatically saves the list to LocalStorage.",
      "It converts the div into a canvas element for faster drawing."
    ]
  },
  "perf-v-03": {
    "prompt": "Як 'shallowRef' допомагає з продуктивністю при роботі з масивними об'єктами (наприклад, величезною відповіддю JSON)?",
    "explanation": "Стандартний 'ref' є глибоким (deep). Для списку з 10 000 елементів Vue доводиться створювати тисячі Proxy. 'shallowRef' уникає цих витрат, запускаючи оновлення лише при повній заміні всього об'єкта.",
    "interviewTip": "Це основне рішення для інтеграції великих сторонніх бібліотек (як-от OpenLayers або Three.js) у Vue.",
    "options": [
      "It compresses the object in memory.",
      "It only makes the .value property reactive and does not recursively make all nested properties reactive.",
      "It moves the object to a Web Worker.",
      "It prevents the object from being garbage collected."
    ]
  },
  "perf-v-04": {
    "prompt": "Проаналізуйте код. Чому ця властивість 'computed' може спричинити проблеми з продуктивністю?",
    "explanation": "Кешування computed працює лише тоді, коли результат запитується знову *без* зміни залежностей. Якщо вхідні дані оновлюються занадто швидко, ви виконуєте важке сортування 60 разів на секунду.",
    "interviewTip": "Розгляньте можливість дебаунсингу (debouncing) вхідних даних або винесення сортування у Web Worker, якщо обчислення занадто важке.",
    "options": [
      "Computed properties should not return arrays.",
      "If 'heavyData' changes frequently, the expensive sort runs on every update, potentially blocking the main thread.",
      "Computed properties cannot use spread syntax.",
      "The code is perfectly optimized as is."
    ]
  },
  "perf-v-05": {
    "prompt": "Які з наведених практик є дружніми до 'Tree Shaking' у Vue 3?",
    "explanation": "Tree shaking дозволяє збирачу видаляти невикористовувані функції Vue із фінального JS-файлу. Vue 3 був переписаний як модульний саме з цією метою.",
    "interviewTip": "Згадайте, що ядро Vue 3 підтримує tree-shaking: якщо ви не використовуєте компонент `<Transition>`, він не потрапить у ваш фінальний бандл.",
    "options": [
      "Using the Composition API (importing only what you need).",
      "Using the Options API exclusively.",
      "Avoiding the use of global 'Vue.prototype' (Vue 2 style).",
      "Using 'defineAsyncComponent' for large modules."
    ]
  },
  "perf-v-06": {
    "prompt": "Яке призначення утиліти 'markRaw'?",
    "explanation": "Деякі об'єкти (наприклад, складні екземпляри класів або React-компоненти всередині Vue) не повинні бути реактивними. markRaw позначає їх так, щоб Vue ігнорував їх, заощаджуючи ресурси.",
    "interviewTip": "Це життєво важливо при обгортанні зовнішніх бібліотек, які мають власне внутрішнє керування станом.",
    "options": [
      "To make a variable accessible in the console.",
      "To explicitly prevent an object from ever being converted into a reactive proxy.",
      "To color-code the object in DevTools.",
      "To convert an object into a string."
    ]
  },
  "perf-v-07": {
    "prompt": "Проаналізуйте код. Яка директива краща для компонента, що перемикає видимість 100 разів на хвилину?",
    "explanation": "v-show лише змінює CSS-властивість 'display: none'. v-if знищував би та створював компонент заново 100 разів, що дуже навантажує процесор.",
    "interviewTip": "Завжди пов'язуйте вибір із поняттями «Вартість ініціалізації» проти «Вартості виконання».",
    "options": [
      "v-if",
      "v-show",
      "v-once",
      "v-cloak"
    ]
  },
  "perf-v-08": {
    "prompt": "Що таке «Рендеринг віртуальних списків» (Virtual List Rendering або Windowing)?",
    "explanation": "Якщо у вас 10 000 елементів, рендеринг такої кількості DOM-вузлів призведе до зависання браузера. Віртуальні списки рендерять лише ті ~10 елементів, які користувач бачить у цей момент.",
    "interviewTip": "Згадайте бібліотеки на кшталт `vue-virtual-scroller` для високопродуктивних списків.",
    "options": [
      "A list that only works on VR headsets.",
      "A technique where only the visible items in a long list are rendered in the DOM to save memory and CPU.",
      "Using v-for on a Virtual DOM node.",
      "A way to hide lists from the user."
    ]
  },
  "pov-09": {
    "prompt": "Яке призначення директиви v-memo у Vue 3?",
    "explanation": "v-memo схожий на React.memo, але для шаблонів. Він особливо корисний для оптимізації великих списків v-for.",
    "interviewTip": "v-memo був представлений у Vue 3.2 і є найефективнішим у поєднанні з v-for.",
    "options": [
      "To memoize component methods.",
      "To memoize a template sub-tree and skip re-rendering if dependencies haven't changed.",
      "To improve memory usage.",
      "To cache API responses."
    ]
  },
  "pov-10": {
    "prompt": "Як можна зменшити розмір бандла (bundle size) додатка Vue?",
    "explanation": "Розділення коду через динамічні імпорти дозволяє завантажувати лише той код, який потрібен для поточного маршруту, зменшуючи початковий розмір бандла.",
    "interviewTip": "Комбінуйте це з tree-shaking, правильною конфігурацією збірки та аналізом розміру бандла за допомогою таких інструментів, як webpack-bundle-analyzer.",
    "options": [
      "Use lazy loading for routes and components.",
      "Remove all comments from code.",
      "Use only inline styles.",
      "Avoid using components."
    ]
  }
}