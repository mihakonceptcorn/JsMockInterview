{
  "perf-v-01": {
    "prompt": "Яку директиву слід використовувати для контенту, який ніколи не змінюється після початкового рендерингу, щоб пропустити відстеження та патчинг Virtual DOM?",
    "explanation": "v-once сприймає елемент та його дітей як статичний контент. Після першого рендерингу Vue повністю ігнорує його під час циклів оновлення, зменшуючи навантаження на Virtual DOM.",
    "interviewTip": "Використовуйте v-once для статичних текстів довідки або іконок усередині важких компонентів.",
    "options": ["v-memo", "v-once", "v-static", "v-pre"]
  },
  "perf-v-02": {
    "prompt": "Проаналізуйте код. У чому перевага використання 'v-memo' у цьому випадку?",
    "explanation": "v-memo (Vue 3.2+) мемоїзує піддерево шаблону. Воно оновлюється лише тоді, коли змінюються залежності у вказаному масиві. Це величезна оптимізація для великих списків, де одночасно змінюється лише один елемент.",
    "interviewTip": "v-memo — це по суті аналог 'React.memo', але для конкретної частини шаблону.",
    "options": [
      "Це запобігає видаленню елемента.",
      "Він повторно рендерить конкретний елемент лише якщо змінюється стан 'selected', навіть якщо інші властивості об'єкта 'item' змінилися.",
      "Він автоматично зберігає список у LocalStorage.",
      "Він перетворює div на елемент canvas для швидшого малювання."
    ]
  },
  "perf-v-03": {
    "prompt": "Як 'shallowRef' допомагає з продуктивністю при работе з масивними об'єктами (наприклад, величезною відповіддю JSON)?",
    "explanation": "Стандартний 'ref' є глибоким (deep). Для списку з 10 000 елементів Vue доводиться створювати тисячі Proxy. 'shallowRef' уникає цих витрат, запускаючи оновлення лише при повній заміні всього об'єкта.",
    "interviewTip": "Це основне рішення для інтеграції великих сторонніх бібліотек (як-от OpenLayers або Three.js) у Vue.",
    "options": [
      "Він стискає об'єкт у пам'яті.",
      "Він робить реактивною лише властивість .value і не робить рекурсивно реактивними всі вкладені властивості.",
      "Він переміщує об'єкт у Web Worker.",
      "Він запобігає видаленню об'єкта з пам'яті збирачем сміття (garbage collector)."
    ]
  },
  "perf-v-04": {
    "prompt": "Проаналізуйте код. Чому ця властивість 'computed' може спричинити проблеми з продуктивністю?",
    "explanation": "Кешування computed працює лише тоді, коли результат запитується знову *без* зміни залежностей. Якщо вхідні дані оновлюються занадто швидко, ви виконуєте важке сортування 60 разів на секунду.",
    "interviewTip": "Розгляньте можливість дебаунсингу (debouncing) вхідних даних або винесення сортування у Web Worker, якщо обчислення занадто важке.",
    "options": [
      "Computed властивості не повинні повертати масиви.",
      "Якщо 'heavyData' змінюється часто, затратне сортування запускається при кожному оновленні, потенційно блокуючи головний потік (main thread).",
      "Computed властивості не можуть використовувати spread-синтаксис.",
      "Код ідеально оптимізований як є."
    ]
  },
  "perf-v-05": {
    "prompt": "Які з наведених практик є дружніми до 'Tree Shaking' у Vue 3?",
    "explanation": "Tree shaking дозволяє збирачу видаляти невикористовувані функції Vue із фінального JS-файлу. Vue 3 був переписаний як модульний саме з цією метою.",
    "interviewTip": "Згадайте, що ядро Vue 3 підтримує tree-shaking: якщо ви не використовуєте компонент `<Transition>`, він не потрапить у ваш фінальний бандл.",
    "options": [
      "Використання Composition API (імпорт лише того, що вам потрібно).",
      "Використання виключно Options API.",
      "Уникнення використання глобального 'Vue.prototype' (стиль Vue 2).",
      "Використання 'defineAsyncComponent' для великих модулів."
    ]
  },
  "perf-v-06": {
    "prompt": "Яке призначення утиліти 'markRaw'?",
    "explanation": "Деякі об'єкти (наприклад, складні екземпляри класів або React-компоненти всередині Vue) не повинні бути реактивними. markRaw позначає їх так, щоб Vue ігнорував їх, заощаджуючи ресурси.",
    "interviewTip": "Це життєво важливо при обгортанні зовнішніх бібліотек, які мають власне внутрішнє керування станом.",
    "options": [
      "Зробити змінну доступною в консолі.",
      "Явно запобігти перетворенню об'єкта на реактивний proxy.",
      "Призначити об'єкту колір у DevTools.",
      "Перетворити об'єкт у рядок."
    ]
  },
  "perf-v-07": {
    "prompt": "Проаналізуйте код. Яка директива краща для компонента, що перемикає видимість 100 разів на хвилину?",
    "explanation": "v-show лише змінює CSS-властивість 'display: none'. v-if знищував би та створював компонент заново 100 разів, що дуже навантажує процесор.",
    "interviewTip": "Завжди пов'язуйте вибір із поняттями «Вартість ініціалізації» проти «Вартості виконання».",
    "options": ["v-if", "v-show", "v-once", "v-cloak"]
  },
  "perf-v-08": {
    "prompt": "Що таке «Рендеринг віртуальних списків» (Virtual List Rendering або Windowing)?",
    "explanation": "Якщо у вас 10 000 елементів, рендеринг такої кількості DOM-вузлів призведе до зависання браузера. Віртуальні списки рендерять лише ті ~10 елементів, які користувач бачить у цей момент.",
    "interviewTip": "Згадайте бібліотеки на кшталт `vue-virtual-scroller` для високопродуктивних списків.",
    "options": [
      "Список, який працює лише в VR-гарнітурах.",
      "Техніка, при якій у DOM рендериться лише видима частина довгого списку для економії пам'яті та процесорного часу.",
      "Використання v-for на вузлі Virtual DOM.",
      "Спосіб приховати списки від користувача."
    ]
  },
  "pov-09": {
    "prompt": "Яке призначення директиви v-memo у Vue 3?",
    "explanation": "v-memo схожий на React.memo, але для шаблонів. Він особливо корисний для оптимізації великих списків v-for.",
    "interviewTip": "v-memo був представлений у Vue 3.2 і є найефективнішим у поєднанні з v-for.",
    "options": [
      "Мемоїзувати методи компонента.",
      "Мемоїзувати піддерево шаблону та пропустити повторний рендеринг, якщо залежності не змінилися.",
      "Покращити використання пам'яті.",
      "Кешувати API-відповіді."
    ]
  },
  "pov-10": {
    "prompt": "Як можна зменшити розмір бандла (bundle size) додатка Vue?",
    "explanation": "Розділення коду через динамічні імпорти дозволяє завантажувати лише той код, який потрібен для поточного маршруту, зменшуючи початковий розмір бандла.",
    "interviewTip": "Комбінуйте це з tree-shaking, правильною конфігурацією збірки та аналізом розміру бандла за допомогою таких інструментів, як webpack-bundle-analyzer.",
    "options": [
      "Використовувати lazy loading для маршрутів та компонентів.",
      "Видалити всі коментарі з коду.",
      "Використовувати лише інлайнові стилі.",
      "Уникати використання компонентів."
    ]
  }
}
