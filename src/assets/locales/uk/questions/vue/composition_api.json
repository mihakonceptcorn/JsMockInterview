{
  "vca-01": {
    "prompt": "Яка основна технічна різниця між 'ref' та 'reactive' у Vue 3?",
    "explanation": "ref огортає будь-яке значення в об'єкт із властивістю .value. reactive використовує Proxy безпосередньо на об'єкті та не працює з примітивами, як-от рядки чи булеві значення.",
    "interviewTip": "Якщо сумніваєтеся — використовуйте 'ref'. Він більш послідовний і дозволяє чітко розрізняти реактивні дані та звичайні змінні."
  },
  "vca-02": {
    "prompt": "Проаналізуйте код. Що станеться з реактивністю, якщо деструктурувати об'єкт 'user'?",
    "explanation": "Деструктуризація реактивного об'єкта — це те саме, що копіювання властивості. Щоб зберегти реактивність при деструктуризації, потрібно використовувати 'toRefs(user)'.",
    "interviewTip": "Це поширене питання на співбесідах. Використовуйте 'toRefs' або 'toRef', щоб безпечно розпакувати реактивні об'єкти на окремі refs."
  },
  "vca-03": {
    "prompt": "Який макрос компілятора використовується в <script setup>, щоб компоненти, пропси та змінні автоматично ставали доступними в шаблоні?",
    "explanation": "<script setup> — це трансформація під час компіляції, яка спрощує Composition API, позбавляючи потреби вручну повертати все з функції setup().",
    "interviewTip": "Зауважте, що <script setup> забезпечує кращу продуктивність під час виконання та зменшує розмір коду."
  },
  "vca-04": {
    "prompt": "Проаналізуйте код. Як слід оновлювати значення 'ref' у блоці скрипта?",
    "explanation": "У блоці скрипта ви повинні звертатися до властивості '.value' для читання або запису в ref. У шаблоні Vue автоматично «розпаковує» його за вас.",
    "interviewTip": "Втрата '.value' — це помилка №1 для розробників, які переходять з Options API на Composition API."
  },
  "vca-05": {
    "prompt": "Яке призначення функції 'shallowRef()'?",
    "explanation": "shallowRef — це оптимізація продуктивності. Він корисний для великих об'єктів або екземплярів сторонніх бібліотек, де вам потрібно відстежувати лише заміну всього об'єкта, а не кожну вкладену властивість.",
    "interviewTip": "Згадуйте про це, коли вас запитують, як оптимізувати роботу з великими наборами даних, що не потребують глибокої реактивності."
  },
  "vca-06": {
    "prompt": "Які з наведених варіантів є валідними причинами надавати перевагу Composition API над Options API у великих проектах?",
    "explanation": "Composition API розроблений для масштабованості. Options API часто призводить до «фрагментації» коду, де логіка однієї функції розпорошена між data, computed та methods.",
    "interviewTip": "Чудове ключове слово для відповіді — «Логічні завдання» (Logical Concerns). Composition API групує код за тим, що він *робить*, а не за тим, чим він *є*."
  },
  "vca-07": {
    "prompt": "Як надати значення за замовчуванням для пропсів при використанні 'defineProps' у <script setup> з TypeScript?",
    "explanation": "При використанні декларацій типів у defineProps використовується макрос компілятора 'withDefaults' для встановлення значень за замовчуванням.",
    "interviewTip": "Це найбільш професійний спосіб роботи з пропсами в проектах Vue 3 на базі TypeScript."
  },
  "vca-08": {
    "prompt": "Що робить функція 'unref()'?",
    "explanation": "unref — це утиліта для написання гнучких функцій. Це скорочення для: `isRef(val) ? val.value : val`.",
    "interviewTip": "Це дуже корисно всередині композиційних функцій (Composables), де аргумент може бути як посиланням (ref), так і звичайним значенням."
  },
  "vca-09": {
    "prompt": "Як реалізувати надання та впровадження залежностей (dependency injection) у Composition API?",
    "explanation": "provide() та inject() дозволяють передавати дані вниз по дереву компонентів без пропсів. Це вбудована система впровадження залежностей у Vue.",
    "interviewTip": "Згадайте, що inject() може приймати значення за замовчуванням, а надані значення стають реактивними лише якщо ви явно зробите їх такими (через ref або reactive)."
  },
  "vca-10": {
    "prompt": "Для чого використовується 'effectScope()' у Vue 3?",
    "explanation": "effectScope() — це просунутий API для ручного контролю моменту створення та знищення ефектів (watcher, computed тощо). Це корисно для авторів складних плагінів.",
    "interviewTip": "Згадка про effectScope демонструє глибокі знання системи реактивності Vue і майже не зустрічається на інтерв'ю початкового рівня."
  }
}
