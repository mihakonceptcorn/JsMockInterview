{
  "tr-01": {
    "prompt": "Як у Composition API пов'язати змінну 'ref' із конкретним елементом DOM у вашому шаблоні?",
    "explanation": "Щоб створити посилання на шаблон (template ref), ви оголошуєте ref із тією ж назвою у вашому скрипті та додаєте атрибут 'ref' до відповідного елемента в шаблоні.",
    "interviewTip": "Назва змінної у вашому скрипті має точно збігатися зі строковим значенням атрибута ref у шаблоні."
  },
  "tr-02": {
    "prompt": "Проаналізуйте код. Чому 'inputRef.value' буде мати значення null під час виконання console.log?",
    "explanation": "Посилання на шаблони заповнюються лише після монтування компонента. Будь-яка спроба отримати доступ до них безпосередньо в тілі скрипта setup поверне null, оскільки DOM ще не створено.",
    "interviewTip": "Щоб безпечно отримати доступ до посилання, завжди використовуйте хук життєвого циклу 'onMounted'."
  },
  "tr-03": {
    "prompt": "Як автоматично встановити фокус на поле введення (input) під час монтування компонента?",
    "explanation": "Після монтування властивість '.value' посилання містить реальний об'єкт HTMLInputElement, що дає вам доступ до нативних методів, таких як .focus().",
    "interviewTip": "Зауважте, що це «шлях Vue», на відміну від використання querySelector, який порушує інкапсуляцію компонента."
  },
  "tr-04": {
    "prompt": "Що буде містити посилання на шаблон, якщо воно застосоване до елемента всередині циклу 'v-for'?",
    "explanation": "У Vue 3, якщо ref використовується всередині циклу v-for, він автоматично заповнюється масивом відповідних DOM-елементів.",
    "interviewTip": "Майте на увазі, що порядок елементів у масиві не гарантовано відповідатиме порядку у вашому джерелі даних, якщо елементи були перевпорядковані."
  },
  "tr-05": {
    "prompt": "Проаналізуйте код. Чи може батько за замовчуванням отримати доступ до 'internalCount' цього дочірнього компонента через посилання на шаблон?",
    "explanation": "Компоненти, що використовують <script setup>, є «закритими» за замовчуванням. Вони не відкривають свій внутрішній стан батькам через посилання, якщо ви явно не вкажете їх у defineExpose().",
    "interviewTip": "Це ключова особливість безпеки та інкапсуляції у Vue 3 порівняно з Options API."
  },
  "tr-06": {
    "prompt": "Що відбувається з посиланням на шаблон у хуку 'onUnmounted'?",
    "explanation": "Система реактивності Vue сама керує життєвим циклом посилання. Коли елемент видаляється з DOM, значення ref.value автоматично скидається до null.",
    "interviewTip": "Проте ви *повинні* використовувати onUnmounted для знищення будь-яких сторонніх екземплярів (наприклад, карт або графіків), які були прив'язані до цього посилання."
  },
  "tr-07": {
    "prompt": "Як використовувати «функціональне посилання» (Function Ref) у Vue 3?",
    "explanation": "Якщо ви передаєте функцію в атрибут :ref, Vue викличе її з елементом під час монтування і з null під час розмонтування. Це корисно для складної логіки або динамічних посилань у циклі.",
    "interviewTip": "Це найбільш гнучкий спосіб роботи з посиланнями, якщо простої назви змінної недостатньо."
  },
  "tr-08": {
    "prompt": "У яких сценаріях доцільно використовувати Template Refs?",
    "explanation": "Посилання на шаблони призначені для імперативних завдань з DOM. Ніколи не використовуйте їх, щоб обійти реактивність Vue для речей, які можна вирішити через пропси або стан.",
    "interviewTip": "Завжди надавайте перевагу декларативному підходу (v-bind, v-if), поки у вас є така можливість."
  },
  "tr-09": {
    "prompt": "Як створити посилання на шаблон у Composition API?",
    "explanation": "Ви створюєте ref із назвою, що збігається з атрибутом ref у шаблоні. Vue автоматично призначить йому DOM-елемент після монтування.",
    "interviewTip": "Посилання має бути повернуте із setup() або оголошене в <script setup>, щоб бути доступним у шаблоні."
  },
  "tr-10": {
    "prompt": "Коли саме посилання на шаблон заповнюється реальним DOM-елементом?",
    "explanation": "Посилання мають значення null під час виконання setup() і отримують значення лише після того, як компонент буде змонтований у DOM.",
    "interviewTip": "Завжди перевіряйте, чи не є посилання null перед використанням, або звертайтеся до нього всередині onMounted."
  }
}
