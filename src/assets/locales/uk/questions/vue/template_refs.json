{
  "tr-01": {
    "prompt": "Як у Composition API пов'язати змінну 'ref' із конкретним елементом DOM у вашому шаблоні?",
    "explanation": "Щоб створити посилання на шаблон (template ref), ви оголошуєте ref із тією ж назвою у вашому скрипті та додаєте атрибут 'ref' до відповідного елемента в шаблоні.",
    "interviewTip": "Назва змінної у вашому скрипті має точно збігатися зі строковим значенням атрибута ref у шаблоні.",
    "options": ["v-ref", "ref", ":id", "bind-ref"]
  },
  "tr-02": {
    "prompt": "Проаналізуйте код. Чому 'inputRef.value' буде мати значення null під час виконання console.log?",
    "explanation": "Посилання на шаблони заповнюються лише після монтування компонента. Будь-яка спроба отримати доступ до них безпосередньо в тілі скрипта setup поверне null, оскільки DOM ще не створено.",
    "interviewTip": "Щоб безпечно отримати доступ до посилання, завжди використовуйте хук життєвого циклу 'onMounted'.",
    "options": [
      "Через неправильну назву змінної.",
      "Оскільки скрипт setup запускається до монтування компонента та створення DOM.",
      "Оскільки змінні 'ref' є приватними.",
      "Оскільки для DOM-елементів потрібно використовувати reactive()."
    ]
  },
  "tr-03": {
    "prompt": "Як автоматично встановити фокус на поле введення (input) під час монтування компонента?",
    "explanation": "Після монтування властивість '.value' посилання містить реальний об'єкт HTMLInputElement, що дає вам доступ до нативних методів, таких як .focus().",
    "interviewTip": "Зауважте, що це «шлях Vue», на відміну від використання querySelector, який порушує інкапсуляцію компонента.",
    "options": [
      "inputRef",
      "document.querySelector('input')",
      "this.$refs.input",
      "inputRef.current"
    ]
  },
  "tr-04": {
    "prompt": "Що буде містити посилання на шаблон, якщо воно застосоване до елемента всередині циклу 'v-for'?",
    "explanation": "У Vue 3, якщо ref використовується всередині циклу v-for, він автоматично заповнюється масивом відповідних DOM-елементів.",
    "interviewTip": "Майте на увазі, що порядок елементів у масиві не гарантовано відповідатиме порядку у вашому джерелі даних, якщо елементи були перевпорядковані.",
    "options": [
      "Тільки перший елемент у списку.",
      "Тільки останній елемент у списку.",
      "Масив, що містить усі DOM-елементи списку.",
      "Це викличе помилку; не можна використовувати refs у v-for."
    ]
  },
  "tr-05": {
    "prompt": "Проаналізуйте код. Чи може батько за замовчуванням отримати доступ до 'internalCount' цього дочірнього компонента через посилання на шаблон?",
    "explanation": "Компоненти, що використовують <script setup>, є «закритими» за замовчуванням. Вони не відкривають свій внутрішній стан батькам через посилання, якщо ви явно не вкажете їх у defineExpose().",
    "interviewTip": "Це ключова особливість безпеки та інкапсуляції у Vue 3 порівняно з Options API.",
    "options": [
      "Так, усі змінні setup є публічними.",
      "Ні, компоненти, що використовують <script setup>, є «закритими» за замовчуванням і потребують 'defineExpose' для відкриття властивостей.",
      "Так, але лише якщо батько використовує $children.",
      "Тільки якщо дочірній компонент не є scoped."
    ]
  },
  "tr-06": {
    "prompt": "Що відбувається з посиланням на шаблон у хуку 'onUnmounted'?",
    "explanation": "Система реактивності Vue сама керує життєвим циклом посилання. Коли елемент видаляється з DOM, значення ref.value автоматично скидається до null.",
    "interviewTip": "Проте ви *повинні* використовувати onUnmounted для знищення будь-яких сторонніх екземплярів (наприклад, карт або графіків), які були прив'язані до цього посилання.",
    "options": [
      "Потрібно вручну встановити значення null.",
      "Нічого; Vue автоматично очищує ref, коли елемент знищується.",
      "Видалити елемент із DOM.",
      "Викликати .destroy() на посиланні."
    ]
  },
  "tr-07": {
    "prompt": "Як використовувати «функціональне посилання» (Function Ref) у Vue 3?",
    "explanation": "Якщо ви передаєте функцію в атрибут :ref, Vue викличе її з елементом під час монтування і з null під час розмонтування. Це корисно для складної логіки або динамічних посилань у циклі.",
    "interviewTip": "Це найбільш гнучкий спосіб роботи з посиланнями, якщо простої назви змінної недостатньо.",
    "options": [
      "Шляхом передачі функції в атрибут :ref: :ref=\"(el) => { ... }\".",
      "Шляхом використання ref=\"myFunc()\".",
      "Шляхом визначення ref, який повертає функцію.",
      "Функціональні посилання не підтримуються у Vue 3."
    ]
  },
  "tr-08": {
    "prompt": "У яких сценаріях доцільно використовувати Template Refs?",
    "explanation": "Посилання на шаблони призначені для імперативних завдань з DOM. Ніколи не використовуйте їх, щоб обійти реактивність Vue для речей, які можна вирішити через пропси або стан.",
    "interviewTip": "Завжди надавайте перевагу декларативному підходу (v-bind, v-if), поки у вас є така можливість.",
    "options": [
      "Керування фокусом, виділенням тексту або відтворенням медіа.",
      "Інтеграція сторонніх DOM-бібліотек (наприклад, D3, Google Maps).",
      "Зміна стану компонента (наприклад, інкремент лічильника).",
      "Запуск імперативних анімацій, які не обробляються Vue Transitions."
    ]
  },
  "tr-09": {
    "prompt": "Як створити посилання на шаблон у Composition API?",
    "explanation": "Ви створюєте ref із назвою, що збігається з атрибутом ref у шаблоні. Vue автоматично призначить йому DOM-елемент після монтування.",
    "interviewTip": "Посилання має бути повернуте із setup() або оголошене в <script setup>, щоб бути доступним у шаблоні.",
    "options": ["createRef", "ref", "useRef", "templateRef"]
  },
  "tr-10": {
    "prompt": "Коли саме посилання на шаблон заповнюється реальним DOM-елементом?",
    "explanation": "Посилання мають значення null під час виконання setup() і отримують значення лише після того, як компонент буде змонтований у DOM.",
    "interviewTip": "Завжди перевіряйте, чи не є посилання null перед використанням, або звертайтеся до нього всередині onMounted.",
    "options": [
      "Одразу після створення компонента.",
      "Після монтування компонента (хук onMounted).",
      "До монтування компонента.",
      "Тільки після виклику спеціального методу."
    ]
  }
}
