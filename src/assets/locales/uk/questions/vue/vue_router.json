{
  "vr-01": {
    "prompt": "Як визначити сегмент динамічного маршруту, який захоплює конкретне значення, наприклад ID користувача?",
    "explanation": "Двокрапка позначає динамічні сегменти. Значення, передане в URL (наприклад, /user/123), буде доступне через 'route.params.id'.",
    "interviewTip": "Ви можете використовувати регулярні вирази (Regex) у шляхах для суворішої перевірки, наприклад /user/:id(\\\\d+)."
  },
  "vr-02": {
    "prompt": "Проаналізуйте код. Яка різниця між цими двома методами навігації (push та replace)?",
    "explanation": "Метод Replace використовується, коли ви не хочете, щоб користувач міг повернутися назад на попередній екран (наприклад, після успішного входу в систему).",
    "interviewTip": "Використовуйте 'replace' для редиректів або тимчасових станів, щоб стека історії браузера залишався чистим."
  },
  "vr-03": {
    "prompt": "Який хук слід використовувати всередині компонента для виконання логіки ПЕРЕД тим, як користувач залишить поточну сторінку?",
    "explanation": "onBeforeRouteLeave — це спеціалізований хук роутера. Він дозволяє запобігти переходу (наприклад, якщо у користувача є незбережені зміни у формі).",
    "interviewTip": "Ви можете повернути 'false' з цього хука, щоб скасувати навігацію."
  },
  "vr-04": {
    "prompt": "У чому основна перевага «лінивого завантаження» (Lazy Loading) маршрутів у конфігурації роутера?",
    "explanation": "Динамічні імпорти () => import(...) створюють окремий файл (bundle) для цього маршруту, що значно покращує час початкового завантаження додатка.",
    "interviewTip": "Для великих корпоративних додатків ліниве завантаження кожного некритичного маршруту є обов'язковою оптимізацією продуктивності."
  },
  "vr-05": {
    "prompt": "Як отримати доступ до параметрів поточного маршруту всередині блоку <script setup>?",
    "explanation": "useRoute дає доступ до поточного стану (params, query, path). useRouter надає можливість здійснювати навігацію (push, back).",
    "interviewTip": "Не плутайте їх! useRoute — для того, що відбувається зараз; useRouter — для того, що має статися далі."
  },
  "vr-06": {
    "prompt": "Які з наведених варіантів є валідними глобальними охоронцями навігації (Global Navigation Guards)?",
    "explanation": "Охоронці навігації використовуються для захисту маршрутів (наприклад, перевірка токенів авторизації).",
    "interviewTip": "Згадуйте 'beforeEach' як основне місце для впровадження перевірок авторизації."
  },
  "vr-07": {
    "prompt": "Яке призначення компонента <router-view>?",
    "explanation": "RouterView — це місце, де відбувається магія рендерингу. Без нього ви можете змінити URL, але інтерфейс не оновиться і не покаже новий компонент.",
    "interviewTip": "Ви можете використовувати кілька компонентів <router-view> з іменами (named views) для створення складних макетів."
  },
  "vr-08": {
    "prompt": "Проаналізуйте код. Що означає налаштування 'props: true' для маршруту?",
    "explanation": "Встановлення 'props: true' відв'язує компонент від роутера. Компонент може оголосити 'props: ['id']' і використовувати його, не знаючи про існування '$route'.",
    "interviewTip": "Це робить компоненти набагато легшими для модульного тестування, оскільки вони не залежать від глобального стану роутера."
  },
  "vr-09": {
    "prompt": "Як програмно перейти на інший маршрут у Vue Router?",
    "explanation": "$router — це екземпляр роутера з методами навігації. $route — це об'єкт з інформацією про поточний маршрут.",
    "interviewTip": "У Composition API використовуйте функцію useRouter() для доступу до екземпляра роутера."
  },
  "vr-10": {
    "prompt": "Яка мета використання «охоронців маршрутів» (route guards) у Vue Router?",
    "explanation": "Охоронці навігації (beforeEach, beforeEnter тощо) дозволяють реалізувати автентифікацію, авторизацію та іншу логіку перед переходом.",
    "interviewTip": "Глобальні охоронці працюють для всіх маршрутів, охоронці рівня маршруту — для конкретних, а внутрішньокомпонентні — всередині самих компонентів."
  }
}
