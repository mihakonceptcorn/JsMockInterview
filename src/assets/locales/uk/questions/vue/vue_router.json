{
  "vr-01": {
    "prompt": "Як визначити сегмент динамічного маршруту, який захоплює конкретне значення, наприклад ID користувача?",
    "explanation": "Двокрапка позначає динамічні сегменти. Значення, передане в URL (наприклад, /user/123), буде доступне через 'route.params.id'.",
    "interviewTip": "Ви можете використовувати регулярні вирази (Regex) у шляхах для суворішої перевірки, наприклад /user/:id(\\\\d+).",
    "options": [":id", "{id}", "*id", "?id"]
  },
  "vr-02": {
    "prompt": "Проаналізуйте код. Яка різниця між цими двома методами навігації (push та replace)?",
    "explanation": "Метод Replace використовується, коли ви не хочете, щоб користувач міг повернутися назад на попередній екран (наприклад, після успішного входу в систему).",
    "interviewTip": "Використовуйте 'replace' для редиректів або тимчасових станів, щоб стека історії браузера залишався чистим.",
    "options": [
      "Варіант А для зовнішніх посилань; Варіант Б для внутрішніх.",
      "Варіант А додає новий запис до стеку історії; Варіант Б перезаписує поточний запис.",
      "Варіант Б швидший за Варіант А.",
      "Різниці немає."
    ]
  },
  "vr-03": {
    "prompt": "Який хук слід використовувати всередині компонента для виконання логіки ПЕРЕД тим, як користувач залишить поточну сторінку?",
    "explanation": "onBeforeRouteLeave — це спеціалізований хук роутера. Він дозволяє запобігти переходу (наприклад, якщо у користувача є незбережені зміни у формі).",
    "interviewTip": "Ви можете повернути 'false' з цього хука, щоб скасувати навігацію.",
    "options": [
      "onUnmounted",
      "onBeforeRouteLeave",
      "onBeforeRouteUpdate",
      "watchEffect"
    ]
  },
  "vr-04": {
    "prompt": "У чому основна перевага «лінивого завантаження» (Lazy Loading) маршрутів у конфігурації роутера?",
    "explanation": "Динамічні імпорти () => import(...) створюють окремий файл (bundle) для цього маршруту, що значно покращує час початкового завантаження додатка.",
    "interviewTip": "Для великих корпоративних додатків ліниве завантаження кожного некритичного маршруту є обов'язковою оптимізацією продуктивності.",
    "options": [
      "Це змушує компоненти завантажуватися повільніше.",
      "Це розділяє додаток на менші частини (chunks), завантажуючи код сторінки лише тоді, коли користувач дійсно її відвідує.",
      "Це автоматично стискає зображення на цій сторінці.",
      "Це дозволяє сторінці працювати офлайн."
    ]
  },
  "vr-05": {
    "prompt": "Як отримати доступ до параметрів поточного маршруту всередині блоку <script setup>?",
    "explanation": "useRoute дає доступ до поточного стану (params, query, path). useRouter надає можливість здійснювати навігацію (push, back).",
    "interviewTip": "Не плутайте їх! useRoute — для того, що відбувається зараз; useRouter — для того, що має статися далі.",
    "options": ["useRouter", "useRoute", "getParams", "routeLink"]
  },
  "vr-06": {
    "prompt": "Які з наведених варіантів є валідними глобальними охоронцями навігації (Global Navigation Guards)?",
    "explanation": "Охоронці навігації використовуються для захисту маршрутів (наприклад, перевірка токенів авторизації).",
    "interviewTip": "Згадуйте 'beforeEach' як основне місце для впровадження перевірок авторизації.",
    "options": [
      "router.beforeEach (запускається перед кожною навігацією)",
      "router.afterEach (запускається після завершення навігації)",
      "router.beforeResolve (запускається перед підтвердженням навігації, після охоронців компонентів)",
      "router.onMount (запускається під час старту додатка)"
    ]
  },
  "vr-07": {
    "prompt": "Яке призначення компонента <router-view>?",
    "explanation": "RouterView — це місце, де відбувається магія рендерингу. Без нього ви можете змінити URL, але інтерфейс не оновиться і не покаже новий компонент.",
    "interviewTip": "Ви можете використовувати кілька компонентів <router-view> з іменами (named views) для створення складних макетів.",
    "options": [
      "Показати список усіх доступних маршрутів.",
      "Як заповнювач (placeholder), що рендерить компонент, який відповідає поточному URL.",
      "Створити посилання на іншу сторінку.",
      "Налагодити стан роутингу."
    ]
  },
  "vr-08": {
    "prompt": "Проаналізуйте код. Що означає налаштування 'props: true' для маршруту?",
    "explanation": "Встановлення 'props: true' відв'язує компонент від роутера. Компонент може оголосити 'props: ['id']' і використовувати його, не знаючи про існування '$route'.",
    "interviewTip": "Це робить компоненти набагато легшими для модульного тестування, оскільки вони не залежать від глобального стану роутера.",
    "options": [
      "Це дозволяє компоненту використовувати CSS-пропси.",
      "Це передає параметри маршруту (як-от :id) безпосередньо як props у компонент.",
      "Це робить маршрут публічним.",
      "Це автоматично валідує типи даних."
    ]
  },
  "vr-09": {
    "prompt": "Як програмно перейти на інший маршрут у Vue Router?",
    "explanation": "$router — це екземпляр роутера з методами навігації. $route — це об'єкт з інформацією про поточний маршрут.",
    "interviewTip": "У Composition API використовуйте функцію useRouter() для доступу до екземпляра роутера.",
    "options": [
      "this.$router.push('/path')",
      "this.$route.push('/path')",
      "router.navigate('/path')",
      "window.location = '/path'"
    ]
  },
  "vr-10": {
    "prompt": "Яка мета використання «охоронців маршрутів» (route guards) у Vue Router?",
    "explanation": "Охоронці навігації (beforeEach, beforeEnter тощо) дозволяють реалізувати автентифікацію, авторизацію та іншу логіку перед переходом.",
    "interviewTip": "Глобальні охоронці працюють для всіх маршрутів, охоронці рівня маршруту — для конкретних, а внутрішньокомпонентні — всередині самих компонентів.",
    "options": [
      "Для захисту маршрутів від несанкціонованого доступу та контролю потоку навігації.",
      "Для захисту від XSS-атак.",
      "Для запобігання змінам маршруту.",
      "Для шифрування параметрів маршруту."
    ]
  }
}
