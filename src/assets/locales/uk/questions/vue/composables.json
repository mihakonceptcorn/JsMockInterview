{
  "comp-01": {
    "prompt": "Яка основна різниця між «композиційною функцією» (Composable) та звичайною утилітою (utility function)?",
    "explanation": "Утиліта, наприклад 'sum(a, b)', просто повертає значення. Composable, як-от 'useMouse()', повертає реактивні посилання (refs), які автоматично оновлюються, коли користувач рухає мишею.",
    "interviewTip": "Ключові слова для відповіді: «Логіка зі станом» (Stateful Logic), «Повторне використання» та «Composition API».",
    "options": [
      "Composables обов'язково мають бути написані на TypeScript.",
      "Composables інкапсулюють реактивний стан (ref, reactive) та хуки життєвого циклу; утиліти зазвичай не мають стану (stateless).",
      "Composables працюють лише всередині шаблону (template).",
      "Утиліти можна використовувати лише один раз на весь додаток."
    ]
  },
  "comp-02": {
    "prompt": "Яким є стандарт іменування для Vue Composables?",
    "explanation": "Починати назву з 'use' — це стандарт спільноти. Це одразу сигналізує іншим розробникам, що функція повертає реактивний стан.",
    "interviewTip": "Це дзеркальне відображення конвенції 'use' з React Hooks, що полегшує перехід для розробників, які працюють з різними фреймворками.",
    "options": [
      "Вони мають починатися з 'vue'.",
      "Вони мають починатися з 'use' (наприклад, useUser, useFetch).",
      "Вони мають бути написані у ВЕРХНЬОМУ_РЕГІСТРІ.",
      "Специфічних угод не існує."
    ]
  },
  "comp-03": {
    "prompt": "Проаналізуйте код. Який найкращий спосіб повернення даних із Composable для зручної деструктуризації в компоненті?",
    "explanation": "У Vue краще повертати об'єкт. Це дозволяє компоненту деструктурувати лише потрібні частини та перейменовувати їх за потреби, не залежачи від суворого порядку в масиві.",
    "interviewTip": "Зауважте, що повернення об'єкта є більш гнучким для майбутнього розширення вашого API.",
    "options": [
      "[count, increment]",
      "{ count, increment }",
      "count, increment",
      "new Counter(count)"
    ]
  },
  "comp-04": {
    "prompt": "Чому важливо використовувати 'toValue()' (або 'unref') всередині Composable при обробці вхідних аргументів?",
    "explanation": "toValue() (введений у Vue 3.3) нормалізує вхідні дані (число, ref або функцію-гетер). Це робить ваш Composable набагато гнучкішим для споживача.",
    "interviewTip": "Використання toValue/unref — це ознака «добре спроектованого» Composable рівня бібліотеки.",
    "options": [
      "Щоб функція працювала швидше.",
      "Щоб дозволити Composable приймати як звичайні значення, так і refs/getters як аргументи.",
      "Щоб перетворити рядок у ціле число.",
      "Щоб приховати дані від шаблону."
    ]
  },
  "comp-05": {
    "prompt": "Проаналізуйте код. Яка поширена пастка виникає при використанні 'reactive' всередині Composable та його прямому поверненні?",
    "explanation": "Деструктуризація об'єктів reactive руйнує зв'язок реактивності. Щоб це виправити, Composable має повертати 'toRefs(state)'.",
    "interviewTip": "Завжди рекомендуйте 'toRefs' при поверненні реактивного об'єкта з Composable.",
    "options": [
      "Код видасть помилку.",
      "Змінна 'name' втратить реактивність, оскільки вона була деструктурована з реактивного об'єкта.",
      "Використання пам'яті подвоїться.",
      "Змінна name стане доступною лише для читання."
    ]
  },
  "comp-06": {
    "prompt": "Де можна безпечно викликати Composable, який використовує хуки життєвого циклу, такі як 'onMounted'?",
    "explanation": "Хуки життєвого циклу мають бути зареєстровані під час синхронного виконання 'setup'. Якщо викликати Composable після 'await', Vue втратить зв'язок із екземпляром компонента, якому належить хук.",
    "interviewTip": "Це суворе «Правило Composables». Завжди викликайте їх на верхньому рівні вашого скрипта.",
    "options": [
      "У будь-якому місці проекту.",
      "Тільки всередині функції setup() або <script setup> (синхронно).",
      "Всередині таймера setInterval.",
      "Всередині асинхронної функції після оператора 'await'."
    ]
  },
  "comp-07": {
    "prompt": "Які переваги використання Composables над застарілим патерном 'Mixins'?",
    "explanation": "Міксини (Mixins) — це «невидимі» ін'єкції, які важко відстежити. Composables чітко показують, звідки походить кожна частина даних.",
    "interviewTip": "Якщо запитають про Mixins, називайте їх «непрозорими» (opaque), а Composables — «прозорими та явними».",
    "options": [
      "Явне джерело стану (ви знаєте, з якого саме Composable походить змінна).",
      "Відсутність колізій імен (ви можете перейменувати деструктуровані змінні).",
      "Краща підтримка TypeScript.",
      "Composables — це єдиний спосіб використовувати CSS."
    ]
  },
  "comp-08": {
    "prompt": "Чи може один Composable викликати інший Composable?",
    "explanation": "Вкладення композиційних функцій (наприклад, 'useAuth' може використовувати 'useFetch' всередині) є стандартною практикою.",
    "interviewTip": "Цей патерн відомий як «Композиція композицій» (Composable Composition).",
    "options": [
      "Ні, це створює циклічну залежність.",
      "Так, Composables легко вкладаються, дозволяючи створювати складну логіку з маленьких простих модулів.",
      "Тільки якщо вони знаходяться в одній папці.",
      "Так, але тільки якщо вони не використовують refs."
    ]
  },
  "comp-09": {
    "prompt": "Що таке composable у Vue 3?",
    "explanation": "Composables — це еквівалент міксинів або компонентів вищого порядку у Vue 3, але з кращою структурою та без конфліктів іменування.",
    "interviewTip": "Назви Composables мають починатися з префікса 'use' (наприклад, useMouse, useFetch), наслідуючи конвенцію хуків React.",
    "options": [
      "Компонент, який можна поєднувати з іншими компонентами.",
      "Функція, яка використовує Vue Composition API для інкапсуляції та повторного використання логіки зі станом.",
      "Клас CSS, який можна використовувати повторно.",
      "Тип директиви Vue."
    ]
  },
  "comp-10": {
    "prompt": "Що має повертати composable?",
    "explanation": "Composables зазвичай повертають об'єкт, що містить refs, реактивні об'єкти, обчислювані властивості та методи, які компоненти можуть використовувати.",
    "interviewTip": "Повертайте лише те, що потрібно споживачеві, щоб API залишався чистим та сфокусованим.",
    "options": [
      "Нічого, composables призначені лише для побічних ефектів.",
      "Реактивний стан та функції, які може використовувати компонент.",
      "Тільки примітивні значення.",
      "Новий екземпляр Vue."
    ]
  }
}
