{
  "comp-01": {
    "prompt": "Яка основна різниця між «композиційною функцією» (Composable) та звичайною утилітою (utility function)?",
    "explanation": "Утиліта, наприклад 'sum(a, b)', просто повертає значення. Composable, як-от 'useMouse()', повертає реактивні посилання (refs), які автоматично оновлюються, коли користувач рухає мишею.",
    "interviewTip": "Ключові слова для відповіді: «Логіка зі станом» (Stateful Logic), «Повторне використання» та «Composition API»."
  },
  "comp-02": {
    "prompt": "Яким є стандарт іменування для Vue Composables?",
    "explanation": "Починати назву з 'use' — це стандарт спільноти. Це одразу сигналізує іншим розробникам, що функція повертає реактивний стан.",
    "interviewTip": "Це дзеркальне відображення конвенції 'use' з React Hooks, що полегшує перехід для розробників, які працюють з різними фреймворками."
  },
  "comp-03": {
    "prompt": "Проаналізуйте код. Який найкращий спосіб повернення даних із Composable для зручної деструктуризації в компоненті?",
    "explanation": "У Vue краще повертати об'єкт. Це дозволяє компоненту деструктурувати лише потрібні частини та перейменовувати їх за потреби, не залежачи від суворого порядку в масиві.",
    "interviewTip": "Зауважте, що повернення об'єкта є більш гнучким для майбутнього розширення вашого API."
  },
  "comp-04": {
    "prompt": "Чому важливо використовувати 'toValue()' (або 'unref') всередині Composable при обробці вхідних аргументів?",
    "explanation": "toValue() (введений у Vue 3.3) нормалізує вхідні дані (число, ref або функцію-гетер). Це робить ваш Composable набагато гнучкішим для споживача.",
    "interviewTip": "Використання toValue/unref — це ознака «добре спроектованого» Composable рівня бібліотеки."
  },
  "comp-05": {
    "prompt": "Проаналізуйте код. Яка поширена пастка виникає при використанні 'reactive' всередині Composable та його прямому поверненні?",
    "explanation": "Деструктуризація об'єктів reactive руйнує зв'язок реактивності. Щоб це виправити, Composable має повертати 'toRefs(state)'.",
    "interviewTip": "Завжди рекомендуйте 'toRefs' при поверненні реактивного об'єкта з Composable."
  },
  "comp-06": {
    "prompt": "Де можна безпечно викликати Composable, який використовує хуки життєвого циклу, такі як 'onMounted'?",
    "explanation": "Хуки життєвого циклу мають бути зареєстровані під час синхронного виконання 'setup'. Якщо викликати Composable після 'await', Vue втратить зв'язок із екземпляром компонента, якому належить хук.",
    "interviewTip": "Це суворе «Правило Composables». Завжди викликайте їх на верхньому рівні вашого скрипта."
  },
  "comp-07": {
    "prompt": "Які переваги використання Composables над застарілим патерном 'Mixins'?",
    "explanation": "Міксини (Mixins) — це «невидимі» ін'єкції, які важко відстежити. Composables чітко показують, звідки походить кожна частина даних.",
    "interviewTip": "Якщо запитають про Mixins, називайте їх «непрозорими» (opaque), а Composables — «прозорими та явними»."
  },
  "comp-08": {
    "prompt": "Чи може один Composable викликати інший Composable?",
    "explanation": "Вкладення композиційних функцій (наприклад, 'useAuth' може використовувати 'useFetch' всередині) є стандартною практикою.",
    "interviewTip": "Цей патерн відомий як «Композиція композицій» (Composable Composition)."
  },
  "comp-09": {
    "prompt": "Що таке composable у Vue 3?",
    "explanation": "Composables — це еквівалент міксинів або компонентів вищого порядку у Vue 3, але з кращою структурою та без конфліктів іменування.",
    "interviewTip": "Назви Composables мають починатися з префікса 'use' (наприклад, useMouse, useFetch), наслідуючи конвенцію хуків React."
  },
  "comp-10": {
    "prompt": "Що має повертати composable?",
    "explanation": "Composables зазвичай повертають об'єкт, що містить refs, реактивні об'єкти, обчислювані властивості та методи, які компоненти можуть використовувати.",
    "interviewTip": "Повертайте лише те, що потрібно споживачеві, щоб API залишався чистим та сфокусованим."
  }
}
