{
  "vue-re-01": {
    "prompt": "Яка технологія лежить в основі системи реактивності Vue 3, дозволяючи їй ефективніше відстежувати зміни в об'єктах?",
    "explanation": "Vue 3 використовує ES6 Proxies для перехоплення операцій над об'єктами. Це розв'язало обмеження Vue 2, такі як неможливість автоматично виявляти додавання нових властивостей або зміни в масивах за індексом.",
    "interviewTip": "Будьте готові до запитання про різницю: Vue 2 використовував гетери/сетери через Object.defineProperty, тоді як Vue 3 використовує Proxy, які є продуктивнішими та гнучкішими.",
    "options": [
      "Object.defineProperty",
      "Virtual DOM Listeners",
      "ES6 Proxies",
      "Dirty Checking (як в Angular JS)"
    ]
  },
  "vue-re-02": {
    "prompt": "Проаналізуйте код нижче. Чи буде зміна властивості 'b' реактивною у Vue 2?",
    "explanation": "У Vue 2 реактивність впроваджується під час ініціалізації екземпляра. Властивості, додані пізніше (як vm.b), не стають реактивними, якщо не використати Vue.set().",
    "interviewTip": "Це класична пастка Vue 2. У Vue 3 цей код працював би ідеально завдяки використанню Proxy.",
    "options": [
      "Так, Vue автоматично додає всі нові властивості до системи реактивності.",
      "Ні, для відстеження у Vue 2 властивість має бути попередньо оголошена в об'єкті data.",
      "Так, але лише якщо ви відразу після цього викличете vm.$forceUpdate().",
      "Ні, у Vue 2 реактивними є лише масиви."
    ]
  },
  "vue-re-03": {
    "prompt": "Що означає абревіатура MVVM у контексті архітектури Vue.js?",
    "explanation": "Vue натхненний патерном MVVM. View — це DOM, Model — це звичайні дані JavaScript, а ViewModel — це екземпляр Vue, який синхронізує їх між собою.",
    "interviewTip": "Якщо запитають, як Vue пов'язаний з MVVM, поясніть, що ViewModel бере на себе зв'язування даних, тому вам не потрібно маніпулювати DOM вручну.",
    "options": [
      "Model-View-ViewManager",
      "Model-View-ViewModel",
      "Module-View-Variable-Mapper",
      "Mapping-Virtual-View-Model"
    ]
  },
  "vue-re-04": {
    "prompt": "Яка основна роль «Ефекту» (Effect/Watcher) у системі реактивності Vue?",
    "explanation": "Коли відбувається доступ до реактивної властивості, поточний «ефект» реєструється як передплатник. При зміні властивості всі її передплатники отримують сповіщення про необхідність повторного виконання.",
    "interviewTip": "Це патерн «Спостерігач» (Observer). Розуміння того, що «відстеження залежностей» відбувається під час виклику гетера (Getter), є ознакою досвідченого розробника.",
    "options": [
      "Компілювати шаблони у функції рендерингу.",
      "Збирати залежності та повторно запускати функції (наприклад, рендеринг), коли реактивні дані змінюються.",
      "Шифрувати дані перед їх відправкою на сервер.",
      "Обробляти виключно події кліків користувача."
    ]
  },
  "vue-re-05": {
    "prompt": "Які обмеження реактивності Vue 2 були усунені у Vue 3?",
    "explanation": "Proxy дозволяють Vue відстежувати додавання/видалення властивостей та індекси масивів. Vue 3 також використовує «ліниве» спостереження, роблячи вкладені об'єкти реактивними лише тоді, коли до них реально звертаються.",
    "interviewTip": "Vue 3 значно економніший щодо пам'яті для великих вкладених структур даних саме завдяки цьому «лінивому» підходу.",
    "options": [
      "Виявлення додавання/видалення властивостей.",
      "Виявлення зміни індексу масиву (arr[0] = value).",
      "Потреба в початковому об'єкті data.",
      "Проблеми продуктивності рекурсивного спостереження для великих наборів даних."
    ]
  },
  "vue-re-06": {
    "prompt": "Проаналізуйте код Vue 3 Composition API. Що станеться з інтерфейсом при виклику 'increment'?",
    "explanation": "У Vue 3 змінні повинні бути явно зроблені реактивними за допомогою 'ref()' або 'reactive()'. Звичайна змінна, оголошена через 'let', не відстежується системою реактивності.",
    "interviewTip": "Пам'ятайте, що 'ref' створює об'єкт із властивістю '.value'. Зміна 'count.value' — це спосіб оновити дані в JavaScript-коді.",
    "options": [
      "Інтерфейс оновиться коректно, оскільки 'count' знаходиться всередині setup.",
      "Інтерфейс не оновиться, оскільки 'count' — це звичайна змінна, а не об'єкт 'ref' чи 'reactive'.",
      "Vue видасть помилку компіляції.",
      "Значення count збільшиться в пам'яті, а 'setup' перезапуститься автоматично."
    ]
  },
  "vue-re-07": {
    "prompt": "Що ви побачите, якщо передасте реактивний об'єкт у 'console.log' у Vue 3?",
    "explanation": "Оскільки Vue 3 використовує Proxy, консоль покаже обгортку Proxy. Щоб побачити чисті дані, можна використати утиліту 'toRaw()' або вивести 'JSON.parse(JSON.stringify(obj))'.",
    "interviewTip": "Згадка про 'toRaw' свідчить про те, що ви мали справу з відлагодожуванням складних реактивних станів у реальних проектах.",
    "options": [
      "Ви побачите стандартний об'єкт JS.",
      "Ви побачите об'єкт Proxy, що містить target та handlers.",
      "Браузерна консоль вийде з ладу.",
      "Об'єкт автоматично перетвориться на рядок."
    ]
  },
  "vue-re-08": {
    "prompt": "Як система реактивності Vue уникає нескінченних циклів, коли ефект оновлює ті самі дані, від яких він залежить?",
    "explanation": "Внутрішній планувальник (Scheduler) Vue перевіряє, чи є ефект, що запускається, тим самим, який виконується зараз, запобігаючи миттєвим рекурсивним циклам.",
    "interviewTip": "Розуміння роботи планувальника (Scheduler) демонструє глибокі знання внутрішнього устрою Vue, що виходять за межі простого знання синтаксису.",
    "options": [
      "Він обмежує кількість оновлень до 10 на секунду.",
      "Він використовує 'планувальник' та прапорці відстеження, щоб запобігти рекурсивному виклику ефекту самим собою.",
      "Він суворо забороняє оновлювати дані всередині watchers.",
      "Ніяк; уникати циклів — обов'язок розробника."
    ]
  },
  "vue-re-09": {
    "prompt": "Яка різниця між 'reactive()' та 'readonly()' у Vue 3?",
    "explanation": "readonly() корисний, коли ви хочете передати дані дочірнім компонентам, але заборонити їм їх змінювати. Оригінальний об'єкт все ще можна змінити, але проксі readonly видаватиме попередження в консолі розробника.",
    "interviewTip": "Згадуйте readonly() при обговоренні патернів незмінності пропсів або кращих практик керування станом.",
    "options": [
      "reactive() для об'єктів, readonly() для примітивів.",
      "readonly() створює проксі об'єкта тільки для читання, запобігаючи будь-яким мутаціям, але зберігаючи відстеження доступу для реактивності.",
      "readonly() працює швидше за reactive().",
      "Різниці немає; це аліаси."
    ]
  },
  "vue-re-10": {
    "prompt": "Як Vue 3 обробляє реактивність для глибоко вкладених об'єктів?",
    "explanation": "Vue 3 використовує «ліниве» реактивне перетворення. Коли ви вперше звертаєтеся до вкладеного об'єкта, Vue огортає його в Proxy. Це дозволяє уникнути великих витрат ресурсів при початковій обробці великих структур даних.",
    "interviewTip": "Цей «лінивий» підхід є одним із ключових покращень продуктивності порівняно з Vue 2, де рекурсивне спостереження було примусовим і миттєвим.",
    "options": [
      "Він відстежує лише властивості верхнього рівня.",
      "Він рекурсивно перетворює всі вкладені об'єкти на Proxy, але робить це «ліниво» (при зверненні) для кращої продуктивності.",
      "Ви повинні вручну викликати reactive() для кожного вкладеного об'єкта.",
      "Глибока реактивність не підтримується у Vue 3."
    ]
  }
}
