{
  "vue-re-01": {
    "prompt": "Яка технологія лежить в основі системи реактивності Vue 3, дозволяючи їй ефективніше відстежувати зміни в об'єктах?",
    "explanation": "Vue 3 використовує ES6 Proxies для перехоплення операцій над об'єктами. Це розв'язало обмеження Vue 2, такі як неможливість автоматично виявляти додавання нових властивостей або зміни в масивах за індексом.",
    "interviewTip": "Будьте готові до запитання про різницю: Vue 2 використовував гетери/сетери через Object.defineProperty, тоді як Vue 3 використовує Proxy, які є продуктивнішими та гнучкішими.",
    "options": [
      "Object.defineProperty",
      "Virtual DOM Listeners",
      "ES6 Proxies",
      "Dirty Checking (as seen in Angular JS)"
    ]
  },
  "vue-re-02": {
    "prompt": "Проаналізуйте код нижче. Чи буде зміна властивості 'b' реактивною у Vue 2?",
    "explanation": "У Vue 2 реактивність впроваджується під час ініціалізації екземпляра. Властивості, додані пізніше (як vm.b), не стають реактивними, якщо не використати Vue.set().",
    "interviewTip": "Це класична пастка Vue 2. У Vue 3 цей код працював би ідеально завдяки використанню Proxy.",
    "options": [
      "Yes, Vue automatically adds all new properties to the reactivity system.",
      "No, the property must be pre-declared in the data object for tracking in Vue 2.",
      "Yes, but only if you call vm.$forceUpdate() immediately after.",
      "No, in Vue 2 only arrays are reactive."
    ]
  },
  "vue-re-03": {
    "prompt": "Що означає абревіатура MVVM у контексті архітектури Vue.js?",
    "explanation": "Vue натхненний патерном MVVM. View — це DOM, Model — це звичайні дані JavaScript, а ViewModel — це екземпляр Vue, який синхронізує їх між собою.",
    "interviewTip": "Якщо запитають, як Vue пов'язаний з MVVM, поясніть, що ViewModel бере на себе зв'язування даних, тому вам не потрібно маніпулювати DOM вручну.",
    "options": [
      "Model-View-ViewManager",
      "Model-View-ViewModel",
      "Module-View-Variable-Mapper",
      "Mapping-Virtual-View-Model"
    ]
  },
  "vue-re-04": {
    "prompt": "Яка основна роль «Ефекту» (Effect/Watcher) у системі реактивності Vue?",
    "explanation": "Коли відбувається доступ до реактивної властивості, поточний «ефект» реєструється як передплатник. При зміні властивості всі її передплатники отримують сповіщення про необхідність повторного виконання.",
    "interviewTip": "Це патерн «Спостерігач» (Observer). Розуміння того, що «відстеження залежностей» відбувається під час виклику гетера (Getter), є ознакою досвідченого розробника.",
    "options": [
      "To compile templates into render functions.",
      "To collect dependencies and re-run functions (like rendering) when reactive data changes.",
      "To encrypt data before it is sent to a server.",
      "To handle user click events exclusively."
    ]
  },
  "vue-re-05": {
    "prompt": "Які обмеження реактивності Vue 2 були усунені у Vue 3?",
    "explanation": "Proxy дозволяють Vue відстежувати додавання/видалення властивостей та індекси масивів. Vue 3 також використовує «ліниве» спостереження, роблячи вкладені об'єкти реактивними лише тоді, коли до них реально звертаються.",
    "interviewTip": "Vue 3 значно економніший щодо пам'яті для великих вкладених структур даних саме завдяки цьому «лінивому» підходу.",
    "options": [
      "Detecting property addition/deletion.",
      "Detecting array index modification (arr[0] = value).",
      "The need for an initial data object.",
      "Performance overhead of recursive observation for large datasets."
    ]
  },
  "vue-re-06": {
    "prompt": "Проаналізуйте код Vue 3 Composition API. Що станеться з інтерфейсом при виклику 'increment'?",
    "explanation": "У Vue 3 змінні повинні бути явно зроблені реактивними за допомогою 'ref()' або 'reactive()'. Звичайна змінна, оголошена через 'let', не відстежується системою реактивності.",
    "interviewTip": "Пам'ятайте, що 'ref' створює об'єкт із властивістю '.value'. Зміна 'count.value' — це спосіб оновити дані в JavaScript-коді.",
    "options": [
      "The UI will update correctly because 'count' is inside setup.",
      "The UI will not update because 'count' is a plain variable, not a 'ref' or 'reactive' object.",
      "Vue will throw a compilation error.",
      "The count will increment in memory but 'setup' will re-run automatically."
    ]
  },
  "vue-re-07": {
    "prompt": "Що ви побачите, якщо передасте реактивний об'єкт у 'console.log' у Vue 3?",
    "explanation": "Оскільки Vue 3 використовує Proxy, консоль покаже обгортку Proxy. Щоб побачити чисті дані, можна використати утиліту 'toRaw()' або вивести 'JSON.parse(JSON.stringify(obj))'.",
    "interviewTip": "Згадка про 'toRaw' свідчить про те, що ви мали справу з відлагодожуванням складних реактивних станів у реальних проектах.",
    "options": [
      "You see a standard JS object.",
      "You see a Proxy object containing the target and handlers.",
      "The browser console crashes.",
      "The object is automatically converted to a string."
    ]
  },
  "vue-re-08": {
    "prompt": "Як система реактивності Vue уникає нескінченних циклів, коли ефект оновлює ті самі дані, від яких він залежить?",
    "explanation": "Внутрішній планувальник (Scheduler) Vue перевіряє, чи є ефект, що запускається, тим самим, який виконується зараз, запобігаючи миттєвим рекурсивним циклам.",
    "interviewTip": "Розуміння роботи планувальника (Scheduler) демонструє глибокі знання внутрішнього устрою Vue, що виходять за межі простого знання синтаксису.",
    "options": [
      "It limits the number of updates to 10 per second.",
      "It uses a 'scheduler' and tracking flags to prevent an effect from triggering itself recursively.",
      "It strictly forbids updating data inside watchers.",
      "It doesn't; it's the developer's responsibility to avoid loops."
    ]
  },
  "vue-re-09": {
    "prompt": "Яка різниця між 'reactive()' та 'readonly()' у Vue 3?",
    "explanation": "readonly() корисний, коли ви хочете передати дані дочірнім компонентам, але заборонити їм їх змінювати. Оригінальний об'єкт все ще можна змінити, але проксі readonly видаватиме попередження в консолі розробника.",
    "interviewTip": "Згадуйте readonly() при обговоренні патернів незмінності пропсів або кращих практик керування станом.",
    "options": [
      "reactive() is for objects, readonly() is for primitives.",
      "readonly() creates a read-only proxy of an object, preventing any mutations while still tracking access for reactivity.",
      "readonly() is faster than reactive().",
      "There is no difference; they are aliases."
    ]
  },
  "vue-re-10": {
    "prompt": "Як Vue 3 обробляє реактивність для глибоко вкладених об'єктів?",
    "explanation": "Vue 3 використовує «ліниве» реактивне перетворення. Коли ви вперше звертаєтеся до вкладеного об'єкта, Vue огортає його в Proxy. Це дозволяє уникнути великих витрат ресурсів при початковій обробці великих структур даних.",
    "interviewTip": "Цей «лінивий» підхід є одним із ключових покращень продуктивності порівняно з Vue 2, де рекурсивне спостереження було примусовим і миттєвим.",
    "options": [
      "It only tracks the top-level properties.",
      "It recursively converts all nested objects into Proxies, but does so lazily (on-access) for better performance.",
      "You must manually call reactive() on each nested object.",
      "Deep reactivity is not supported in Vue 3."
    ]
  }
}