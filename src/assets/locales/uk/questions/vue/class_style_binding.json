{
  "csb-01": {
    "prompt": "Проаналізуйте код. Який клас буде застосовано до div, якщо 'isActive' має значення true, а 'hasError' — false?",
    "explanation": "В об'єктному синтаксисі ключ — це назва класу, а значення — булевий вираз. Оскільки isActive — true, додається клас 'active'. Оскільки hasError — false, клас 'text-danger' пропускається.",
    "interviewTip": "Ключі з дефісами, як-от 'text-danger', в об'єктному синтаксисі обов'язково мають бути в лапках.",
    "options": ["active", "text-danger", "active text-danger", "None"]
  },
  "csb-02": {
    "prompt": "Як можна застосувати кілька класів, об'єднавши їх у список?",
    "explanation": "Синтаксис масиву дозволяє застосовувати список класів. Ви навіть можете вкладати об'єктний синтаксис у масив для реалізації складної логіки.",
    "interviewTip": "Використання конструкції `[isActive ? activeClass : '', errorClass]` — це поширений патерн для умовних класів усередині масиву.",
    "options": [
      "activeClass",
      "{ active: isActive }",
      "Обидва варіанти валідні",
      "Жоден не є валідним"
    ]
  },
  "csb-03": {
    "prompt": "Як слід писати назви CSS-властивостей з кількох слів (наприклад, 'font-size') при прив'язці до атрибута 'style'?",
    "explanation": "Vue гнучкий у цьому питанні. Ви можете використовувати camelCase (`fontSize`), що ближче до назв властивостей JS DOM, або рядки в kebab-case (`'font-size'`).",
    "interviewTip": "У спільноті Vue зазвичай надають перевагу camelCase для чистішого коду без зайвих лапок.",
    "options": [
      "Завжди в kebab-case: { 'font-size': '12px' }",
      "Завжди в camelCase: { fontSize: '12px' }",
      "Vue підтримує як camelCase, так і kebab-case (у лапках).",
      "Vue підтримує лише camelCase."
    ]
  },
  "csb-04": {
    "prompt": "Що станеться, якщо на одному елементі є одночасно стандартний атрибут 'class' та динамічний ':class'?",
    "explanation": "Vue розумно об'єднує статичні та динамічні класи. Якщо isActive має значення true, результатом буде class=\"base active\".",
    "interviewTip": "Ця поведінка об'єднання також стосується атрибутів 'style' та ':style'.",
    "options": [
      "Прив'язаний :class перезаписує статичний клас.",
      "Статичний клас перезаписує прив'язаний :class.",
      "Vue об'єднує їх разом у єдиний список класів.",
      "Це призведе до помилки компіляції шаблону."
    ]
  },
  "csb-05": {
    "prompt": "Проаналізуйте код. У чому перевага такого патерна?",
    "explanation": "Прив'язка до обчислюваного об'єкта (computed property) є найкращою практикою для складної логіки класів. Це робить ваші шаблони читабельними та використовує кешування обчислюваних властивостей.",
    "interviewTip": "На співбесіді на рівні Senior завжди радьте винести складні тернарні оператори з шаблонів в обчислювані властивості.",
    "options": [
      "Це робить шаблон чистішим, виносячи складну логіку в script.",
      "Це єдиний спосіб використовувати реактивні змінні в класах.",
      "Це автоматично мініфікує CSS.",
      "Це запобігає повторному рендерингу компонента."
    ]
  },
  "csb-06": {
    "prompt": "Які з наведених варіантів є валідними способами обмежити дію CSS лише одним компонентом (scoped) у Vue?",
    "explanation": "Атрибут 'scoped' використовує data-атрибути для ізоляції стилів. CSS Modules (атрибут module) впорскує об'єкт $style безпосередньо в компонент.",
    "interviewTip": "Будьте обережні зі 'scoped' — він не впливає на нутрощі дочірніх компонентів, а лише на їхній кореневий елемент.",
    "options": [
      "Додавання атрибута 'scoped' до тегу <style>.",
      "Використання CSS Modules шляхом додавання атрибута 'module' до тегу <style>.",
      "Vue автоматично ізолює весь CSS за замовчуванням; атрибути не потрібні.",
      "Огортання CSS у директиву 'v-scope'."
    ]
  },
  "csb-07": {
    "prompt": "Як Vue обробляє CSS-властивості, що потребують вендорних префіксів (наприклад, 'user-select')?",
    "explanation": "Коли ви використовуєте властивість, що потребує префікса, у біндінгу ':style', Vue автоматично визначить це і додасть відповідні префікси.",
    "interviewTip": "Це автоматичне додавання префіксів (Auto-prefixing) вбудоване в логіку виконання Vue для стилів.",
    "options": [
      "Ви повинні прописувати їх вручну для кожного браузера.",
      "Vue автоматично виявляє та додає необхідні вендорні префікси за вас.",
      "Vue потребує зовнішній плагін, як-от PostCSS, для цього.",
      "Vue підтримує лише стандартні властивості без префіксів."
    ]
  },
  "csb-08": {
    "prompt": "Яким є результат передачі масиву об'єктів у ':style'?",
    "explanation": "Синтаксис масиву для ':style' дозволяє застосовувати кілька об'єктів стилів до одного елемента, при цьому властивості в наступних об'єктах перезаписують попередні.",
    "interviewTip": "Це дуже корисно для комбінування базових стилів з умовними модифікаторами.",
    "options": [
      "Він ігнорує масив і застосовує лише перший об'єкт.",
      "Він об'єднує всі об'єкти стилів у масиві, застосовуючи їх до елемента.",
      "Це викликає помилку типу (type error).",
      "Він застосовує стилі як рядок, розділений пробілами."
    ]
  },
  "csb-09": {
    "prompt": "Як у Vue прив'язати кілька CSS-класів за певною умовою?",
    "explanation": "Об'єктний синтаксис дозволяє вмикати/вимикати класи на основі реактивних даних. Ви також можете комбінувати об'єктний та масивний синтаксис.",
    "interviewTip": "Для назв класів із дефісами використовуйте лапки навколо ключа.",
    "options": [
      "Цей синтаксис невалідний.",
      "Використовувати об'єкт, де ключі — назви класів, а значення — булеві вирази.",
      "Використовувати масив рядків.",
      "Замість цього використовувати v-bind:classes."
    ]
  },
  "csb-10": {
    "prompt": "У чому перевага використання ':style' з об'єктом?",
    "explanation": "Прив'язка стилів приймає об'єкт, де ключі — це назви CSS-властивостей (camelCase або kebab-case), а значення — реактивні дані.",
    "interviewTip": "Vue автоматично додає вендорні префікси для властивостей, які цього потребують.",
    "options": [
      "Це робить стилі швидшими.",
      "Це дозволяє реактивно оновлювати інлайнові стилі на основі даних компонента.",
      "Це автоматично додає вендорні префікси.",
      "Це конвертує CSS у SCSS."
    ]
  }
}
