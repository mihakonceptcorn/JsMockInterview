{
  "cw-01": {
    "prompt": "Яка основна перевага використання властивості 'computed' над звичайним методом (method) у шаблоні?",
    "explanation": "Кешування — це головна фішка. Якщо у вас є важке обчислення в computed, воно виконається лише один раз і буде повертати готовий результат, поки не зміняться вхідні дані. Методи ж виконуються при кожному рендерингу компонента.",
    "interviewTip": "Використовуйте computed для трансформації даних (гетери), а методи — для обробки подій або дій."
  },
  "cw-02": {
    "prompt": "Проаналізуйте код. Скільки разів у консолі з'явиться запис 'Calculating...', якщо компонент перерендериться 5 разів, але значення 'count' не зміниться?",
    "explanation": "Завдяки кешуванню функція computed виконається лише один раз. Поки 'count' залишається тим самим, Vue миттєво повертає збережене значення.",
    "interviewTip": "Обчислювані властивості є «лінивими». Якщо вони не використовуються в шаблоні або іншому ефекті, вони не виконаються навіть жодного разу!"
  },
  "cw-03": {
    "prompt": "Коли варто використовувати спостерігач (watch) замість обчислюваної властивості (computed)?",
    "explanation": "Обчислювані властивості мають бути «чистими» (без побічних ефектів) і повертати значення. Спостерігачі ж створені для виконання логіки (наприклад, збереження в localStorage або запиту до API) у відповідь на зміну даних.",
    "interviewTip": "Золоте правило: Computed = Гетери; Watchers = Побічні ефекти."
  },
  "cw-04": {
    "prompt": "Як змусити спостерігач спрацювати одразу після створення компонента, не чекаючи першої зміни даних?",
    "explanation": "Опція 'immediate: true' змушує колбек спостерігача виконатися один раз із початковим значенням одразу під час ініціалізації.",
    "interviewTip": "Це дуже корисно для завантаження даних на основі пропса одразу після монтування компонента."
  },
  "cw-05": {
    "prompt": "Що робить опція 'deep: true' у спостерігачі?",
    "explanation": "За замовчуванням спостерігачі відстежують лише «поверхневі» зміни (посилання на об'єкт). 'deep' рекурсивно проходить по всьому об'єкту, щоб вловити зміни у вкладених властивостях.",
    "interviewTip": "Попередження: глибоке спостереження (deep watching) великих об'єктів може сильно вдарити по продуктивності."
  },
  "cw-06": {
    "prompt": "Проаналізуйте код. Чому спостерігач НЕ спрацьовує при зміні 'user.name'?",
    "explanation": "При спостереженні за 'ref', що містить об'єкт, watcher спрацює лише якщо замінити весь об'єкт цілком. Зміни всередині ігноруються, якщо не використати 'deep' або не передати функцію-гетер: `() => user.value.name`.",
    "interviewTip": "У Vue 3 спостереження за об'єктом 'reactive' автоматично створює глибокий watcher, але спостереження за 'ref' — ні."
  },
  "cw-07": {
    "prompt": "Які з цих варіантів є валідними способами створення «обчислюваної властивості з можливістю запису» (Writable Computed)?",
    "explanation": "Хоча більшість computed-властивостей працюють лише на читання, ви можете надати сеттер (setter) для обробки оновлень (наприклад, розбиття рядка 'fullName' на 'firstName' та 'lastName').",
    "interviewTip": "Writable computed властивості чудово підходять для оновлення стану (наприклад, у Pinia) через чистий v-model."
  },
  "cw-08": {
    "prompt": "Яка різниця між 'watch' та 'watchEffect'?",
    "explanation": "watchEffect лаконічніший, бо вам не потрібно перелічувати залежності — він сам «знаходить» їх під час виконання. Проте 'watch' точніший і дає доступ до попереднього значення ('oldValue').",
    "interviewTip": "Використовуйте 'watch', якщо вам потрібне старе значення; використовуйте 'watchEffect' для простішого відстеження залежностей."
  },
  "cw-09": {
    "prompt": "Яка різниця між обчислюваною властивістю та методом у Vue?",
    "explanation": "Обчислювані властивості перераховуються лише при зміні їхніх залежностей. Методи запускаються при кожному рендерингу, що робить їх менш ефективними для важких операцій.",
    "interviewTip": "Використовуйте computed для похідного стану, а методи — для дій або коли потрібно передати аргументи."
  },
  "cw-10": {
    "prompt": "Коли слід використовувати спостерігач з опцією `immediate: true`?",
    "explanation": "За замовчуванням спостерігачі спрацьовують лише при зміні значення. `immediate: true` змушує колбек виконатися миттєво з поточним значенням.",
    "interviewTip": "Це корисно для ініціалізації даних на основі пропсів або виконання початкових API-запитів."
  }
}
