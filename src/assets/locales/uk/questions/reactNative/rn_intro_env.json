{
  "rn-env-01": {
    "prompt": "Яка основна різниця між «Мостом» (Bridge, стара архітектура) та 'JSI' (нова архітектура)?",
    "explanation": "Старий міст вимагає серіалізації даних у JSON та їх відправки через асинхронну чергу. JSI (JavaScript Interface) дозволяє JS тримати прямі посилання на об'єкти C++, що забезпечує миттєві синхронні виклики.",
    "interviewTip": "Зауважте, що JSI є фундаментом для всієї Нової архітектури (Fabric та TurboModules).",
    "options": [
      "JSI дозволяє синхронний зв'язок між JS та Native, тоді як Bridge є асинхронним та серіалізованим.",
      "Bridge швидший, оскільки використовує JSON для передачі всіх даних.",
      "JSI потребує Expo, тоді як Bridge працює лише з React Native CLI.",
      "Bridge використовує виключно Java, тоді як JSI використовує Swift."
    ]
  },
  "rn-env-02": {
    "prompt": "Який рушій розмітки використовує React Native для обчислення позицій та розмірів компонентів?",
    "explanation": "Yoga — це кросплатформний рушій розмітки, розроблений Meta, який реалізує Flexbox для нативних мобільних екранів.",
    "interviewTip": "Yoga написаний на C++ і саме він перетворює ваші стилі 'flex: 1' у реальні координати пікселів на iOS та Android.",
    "options": ["WebKit", "Gecko", "Yoga", "Flexbox-Native"]
  },
  "rn-env-03": {
    "prompt": "Яку роль відіграє рушій 'Hermes' у додатку React Native?",
    "explanation": "Hermes — це малий та легкий рушій JS. Він використовує попередню компіляцію в байт-код (AOT), що значно пришвидшує запуск додатка.",
    "interviewTip": "Починаючи з React Native 0.70, Hermes є рушієм за замовчуванням для всіх нових проектів.",
    "options": [
      "Він керує підключенням до Google Play Store.",
      "Це рушій JavaScript, оптимізований для мобільних пристроїв, щоб скоротити час запуску та розмір додатка.",
      "Він обробляє кешування зображень та локальне сховище.",
      "Це бібліотека UI, яка замінює основні компоненти."
    ]
  },
  "rn-env-04": {
    "prompt": "Яким буде результат виконання цього коду в середовищі React Native?",
    "explanation": "Базові компоненти, як-от View, — це компоненти JavaScript, які діють як обгортки для нативних елементів інтерфейсу.",
    "interviewTip": "Зрештою, ці компоненти дають команду нативній стороні відрендерити UIView на iOS або android.view на Android.",
    "options": [
      "\"string\"",
      "\"function\" (або \"object\" залежно від внутрішньої реалізації версії RN)",
      "\"undefined\"",
      "\"native-element\""
    ]
  },
  "rn-env-05": {
    "prompt": "Які з наведених варіантів є перевагами використання 'Expo' над 'React Native CLI'?",
    "explanation": "Expo спрощує розробку, абстрагуючись від складного нативного коду, хоча CLI все ще кращий, якщо вам потрібні специфічні модифікації нативних модулів, які Expo не підтримує.",
    "interviewTip": "Expo більше не «тільки для початківців»; з появою 'Development Builds' він став достатньо потужним для професійних корпоративних додатків.",
    "options": [
      "Managed workflow: автоматично обробляє нативні конфігурації та сертифікати.",
      "Прямий доступ до модифікації AppDelegate.m та MainApplication.java без обхідних шляхів.",
      "Легше тестування на фізичних пристроях через додаток Expo Go.",
      "EAS (Expo Application Services) для хмарних збірок та подання в магазини."
    ]
  },
  "rn-env-06": {
    "prompt": "Що таке 'Metro' у React Native?",
    "explanation": "Metro — це збирач (bundler), схожий на Webpack для вебу. Він розв'язує залежності та збирає ваш код у єдиний бандл для мобільного середовища.",
    "interviewTip": "Metro — це те, що забезпечує роботу функцій Hot Module Replacement (HMR) та Fast Refresh під час розробки.",
    "options": [
      "Інструмент, який компілює Java-код в APK.",
      "Збирач JavaScript, який бере всі ваші JS-файли та об'єднує їх в один бандл для додатка.",
      "Інструмент налагодження для інспектування дерева UI.",
      "Частина архітектури, яка відповідає за пуш-сповіщення."
    ]
  },
  "rn-env-07": {
    "prompt": "Що замінює 'UIManager' у Новій архітектурі?",
    "explanation": "Fabric — це нова система рендерингу. Вона ефективніша, оскільки дозволяє оновлювати UI синхронно та покращує взаємодію з нативними в'юхами.",
    "interviewTip": "Fabric для рендерингу — це те саме, що TurboModules для нативної логіки.",
    "options": ["TurboModules", "Fabric", "Hermes", "Metro"]
  },
  "rn-env-08": {
    "prompt": "Яке призначення команди 'npx react-native run-ios'?",
    "explanation": "Ця команда запускає процес збірки (через інструменти Xcode) та встановлює додаток на обраний симулятор або пристрій iOS.",
    "interviewTip": "Для роботи цієї команди на комп'ютері з macOS обов'язково має бути встановлений Xcode.",
    "options": [
      "Для встановлення залежностей з npm.",
      "Для збірки та запуску iOS-додатка на симуляторі чи пристрої.",
      "Для мініфікації JavaScript-бандла.",
      "Для генерації нового проекту з шаблону."
    ]
  },
  "rn-env-09": {
    "prompt": "Визначте три основні потоки (threads) у стандартному додатку React Native (архітектура Bridge):",
    "explanation": "UI-потік обробляє рендеринг; JS-потік виконує логіку; Shadow-потік обчислює розмітку (Yoga) перед відправкою її в UI-потік.",
    "interviewTip": "Якщо JS-потік заблокований важкою логікою, інтерфейс залишається чуйним (анімації можуть працювати), але натискання кнопок не будуть оброблятися.",
    "options": [
      "Main Thread (UI Thread)",
      "Database Thread",
      "JavaScript Thread",
      "Shadow Thread (Layout Thread)"
    ]
  },
  "rn-env-10": {
    "prompt": "Що станеться, якщо запустити цей код у стандартному компоненті React Native?",
    "explanation": "React Native не використовує DOM браузера. Ви повинні використовувати нативні примітиви, такі як <View> та <Text>.",
    "interviewTip": "У React Native немає тегів 'div', 'span' або 'p'; увесь текст має бути всередині компонента <Text>.",
    "options": [
      "Це працює, бо RN підтримує всі HTML-теги.",
      "Виникне помилка, оскільки 'div' не є валідним компонентом у React Native.",
      "Він автоматично відрендериться як View.",
      "Це працює лише у веб-версії React Native."
    ]
  },
  "rn-env-11": {
    "prompt": "Що таке 'Autolinking' у React Native?",
    "explanation": "Раніше потрібно було запускати 'react-native link'. Тепер CLI автоматично виявляє нативні модулі в node_modules і підключає їх під час збірки.",
    "interviewTip": "Для iOS після додавання бібліотеки все одно потрібно запустити 'pod install', щоб завершити процес автолінкування.",
    "options": [
      "Функція, яка автоматично оновлює ваші npm-пакети.",
      "Механізм, який автоматично підключає нативні залежності до ваших проектів iOS/Android без ручних кроків.",
      "Спосіб пов'язати два різні екрани в навігації.",
      "AI-інструмент для написання шаблонного коду."
    ]
  },
  "rn-env-12": {
    "prompt": "Що є точкою входу для нативної конфігурації в Android-проекті React Native?",
    "explanation": "AndroidManifest.xml — це місце, де ви визначаєте дозволи, активності (activities) та метадані додатка для ОС Android.",
    "interviewTip": "Знання того, де знаходяться ці файли (android/app/src/main/...), є необхідним для налаштування Deep Links або дозволів на камеру.",
    "options": [
      "AppDelegate.m",
      "AndroidManifest.xml",
      "index.js",
      "metro.config.js"
    ]
  },
  "rn-env-13": {
    "prompt": "Чим 'TurboModule' відрізняється від стандартного нативного модуля?",
    "explanation": "Стандартні модулі ініціалізуються при запуску додатка, навіть якщо вони не використовуються. TurboModules завантажуються лише за потреби та спілкуються напряму через JSI.",
    "interviewTip": "Це ключова частина Нової архітектури, спрямована на покращення швидкості запуску додатка.",
    "options": [
      "TurboModules написані на JavaScript, а Native Modules — на Java.",
      "TurboModules завантажуються «ледаче» і використовують JSI для швидшого синхронного зв'язку.",
      "TurboModules працюють лише на iOS.",
      "TurboModules — це застарілий спосіб написання нативного коду."
    ]
  },
  "rn-env-14": {
    "prompt": "Яка команда використовується для ручного запуску збирача Metro?",
    "explanation": "Ця команда запускає локальний сервер, який надає JS-бандл та ресурси вашому додатку під час розробки.",
    "interviewTip": "Якщо ви отримуєте помилку 'Could not connect to development server', першим кроком буде перевірка, чи запущений цей процес.",
    "options": [
      "npm build",
      "npx react-native start",
      "npx metro-run",
      "expo-cli build"
    ]
  },
  "rn-env-15": {
    "prompt": "Який із цих способів є валідним для вказання версії React Native у проекті?",
    "explanation": "Версія React Native керується як і будь-який інший npm-пакет у файлі package.json.",
    "interviewTip": "Оновлення версій React Native часто вимагає використання інструмента 'React Native Upgrade Helper' через зміни в нативних файлах.",
    "options": [
      "Наведений вище код є правильним.",
      "Версії вказуються у файлі 'native-config.json'.",
      "Ви встановлюєте версію лише в налаштуваннях проекту Xcode.",
      "Версії React Native керовані рушієм Hermes."
    ]
  },
  "rn-env-16": {
    "prompt": "Що представляє собою 'Shadow Tree' (тіньове дерево)?",
    "explanation": "Тіньове дерево — це місце, де React Native зберігає інформацію про макет (flex, відступи), щоб Yoga міг обчислити фінальні розміри.",
    "interviewTip": "У Новій архітектурі Тіньове дерево є незмінним (immutable) і керується в C++ для кращої продуктивності.",
    "options": [
      "Прихована копія DOM.",
      "Деревоподібна структура, що використовується Yoga для розрахунку макета перед перетворенням його в нативні в'юхи.",
      "Список усіх видалених компонентів.",
      "Рівень безпеки, що захищає JS-потік."
    ]
  },
  "rn-env-17": {
    "prompt": "Як увімкнути Нову архітектуру в сучасному проекті React Native (iOS)?",
    "explanation": "У більшості актуальних версій її потрібно явно увімкнути під час інсталяції подів (pods) для iOS або у файлі gradle.properties для Android.",
    "interviewTip": "Майте на увазі, що деякі сторонні бібліотеки можуть бути ще не сумісними з Новою архітектурою.",
    "options": [
      "Зміна налаштування в панелі Expo.",
      "Запуск 'bundle exec pod install' з прапорцем оточення 'RCT_NEW_ARCH_ENABLED=1'.",
      "Вона завжди увімкнена і її не можна вимкнути.",
      "Шляхом видалення файлу Bridge.js."
    ]
  },
  "rn-env-18": {
    "prompt": "Що відбувається під час спрацювання 'Fast Refresh'?",
    "explanation": "Fast Refresh поєднує «гаряче» та «живе» перезавантаження, забезпечуючи плавне оновлення коду без втрати стану компонента, де це можливо.",
    "interviewTip": "Якщо ви зміните файл, який експортує щось окрім React-компонента, Fast Refresh може виконати повне перезавантаження для безпеки.",
    "options": [
      "Весь додаток перезавантажується, і весь стан втрачається.",
      "React Native намагається оновити лише змінені компоненти, зберігаючи їх стан.",
      "Нативний код (Java/Swift) перекомпілюється.",
      "Пристрій вібрує, вказуючи на оновлення."
    ]
  }
}
