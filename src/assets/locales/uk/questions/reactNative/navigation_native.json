{
  "nav-01": {
    "prompt": "Який тип навігатора слід використовувати для стандартного переходу 'push/pop', де новий екран накладається поверх попереднього?",
    "explanation": "Stack Navigator забезпечує переходи між екранами, де кожен новий екран додається до «стеку» поверх попереднього.",
    "interviewTip": "У сучасній розробці використовуйте '@react-navigation/native-stack', оскільки він працює на базі нативних примітивів ОС, що забезпечує кращу продуктивність.",
    "options": [
      "Tab Navigator",
      "Stack Navigator",
      "Drawer Navigator",
      "Switch Navigator"
    ]
  },
  "nav-02": {
    "prompt": "Як перейти на екран 'Details' та передати параметр 'itemId'?",
    "explanation": "Функція 'navigate' — найпоширеніший спосіб переходу. Другий аргумент — це об'єкт із параметрами (params).",
    "interviewTip": "Зверніть увагу на різницю: 'navigate' повернеться до вже існуючого екрана в стеку, тоді як 'push' завжди створить новий екземпляр, навіть якщо цей екран уже відкритий.",
    "options": ["push", "navigate", "jumpTo", "goTo"]
  },
  "nav-03": {
    "prompt": "Як отримати параметр 'itemId' у компоненті екрана 'Details'?",
    "explanation": "Кожен компонент екрана в навігаторі отримує пропс 'route', який містить інформацію про поточний маршрут, включаючи 'params'.",
    "interviewTip": "Ви також можете використовувати хук 'useRoute', щоб отримати доступ до цієї інформації в будь-якому місці дерева компонентів.",
    "options": ["navigation", "route", "params", "props"]
  },
  "nav-04": {
    "prompt": "Яке призначення компонента <NavigationContainer>?",
    "explanation": "NavigationContainer має огортати всю структуру вашого додатка. Він керує станом навігації та обробляє Deep Linking.",
    "interviewTip": "У всьому додатку має бути лише один NavigationContainer.",
    "options": [
      "Він виступає оболонкою для всього додатка, керуючи станом навігації та пов'язуючи додаток із середовищем пристрою.",
      "Він використовується для створення бічного меню.",
      "Він автоматично обробляє виклики API між екранами.",
      "Він потрібен лише для Tab-навігації."
    ]
  },
  "nav-05": {
    "prompt": "Який хук використовується для програмного виконання дії 'go back' (повернутися назад)?",
    "explanation": "useNavigation надає доступ до об'єкта навігації всередині будь-якого вкладеного компонента, дозволяючи виконувати дії 'goBack' або 'navigate'.",
    "interviewTip": "Це набагато чистіше, ніж вручну прокидати пропс 'navigation' через кілька рівнів компонентів.",
    "options": ["useRoute", "useNavigation", "useHistory", "useStack"]
  },
  "nav-06": {
    "prompt": "Які з наведених варіантів є найпоширенішими типами навігаторів в екосистемі React Navigation?",
    "explanation": "React Navigation надає окремі пакети для Stack (стек), Tabs (вкладки) та Drawer (бічне меню). Модальні вікна зазвичай реалізуються як режим презентації всередині Stack.",
    "interviewTip": "Згадуйте 'createNativeStackNavigator' саме через його переваги у швидкодії на iOS та Android.",
    "options": [
      "createNativeStackNavigator",
      "createBottomTabNavigator",
      "createDrawerNavigator",
      "createModalNavigator"
    ]
  },
  "nav-07": {
    "prompt": "Що робить команда 'navigation.replace('Home')'?",
    "explanation": "Метод 'replace' корисний для процесів авторизації: коли користувач увійшов, ви замінюєте екран Login на Home, щоб він не міг повернутися назад до форми входу.",
    "interviewTip": "Використовуйте це для запобігання нескінченних циклів кнопки «Назад» в історії вашого додатка.",
    "options": [
      "Вона додає 'Home' поверх поточного екрана.",
      "Вона видаляє поточний екран зі стека і додає 'Home' на його місце.",
      "Вона оновлює поточний екран.",
      "Вона закриває додаток і знову відкриває головний екран."
    ]
  },
  "nav-08": {
    "prompt": "Як змінити заголовок екрана в навігаційній панелі (header)?",
    "explanation": "Пропс 'options' (зокрема поле 'title') керує відображенням екрана в інтерфейсі навігатора (текст заголовка, підпис вкладки).",
    "interviewTip": "Ви також можете встановлювати ці параметри динамічно всередині компонента за допомогою 'navigation.setOptions'.",
    "options": ["header", "label", "title", "name"]
  },
  "nav-09": {
    "prompt": "Що таке 'Deep Linking' у контексті мобільної навігації?",
    "explanation": "Deep Linking дозволяє зовнішнім джерелам (сайти, пошта, сповіщення) відкривати додаток одразу на конкретному вкладеному екрані.",
    "interviewTip": "Впровадження Deep Linking вимагає конфігурації об'єкта 'linking', який передається в <NavigationContainer>.",
    "options": [
      "Зв'язування додатка з глибокою базою даних.",
      "Спосіб відкрити конкретний екран у вашому додатку за допомогою URL-адреси (наприклад, myapp://details/42).",
      "Метод глибокого зв'язку двох компонентів у дереві.",
      "Підключення додатка до файлової системи пристрою."
    ]
  },
  "nav-10": {
    "prompt": "Як визначити, що екран став активним/видимим для користувача (focus)?",
    "explanation": "Оскільки екрани в стеку залишаються змонтованими навіть будучи прихованими, звичайний 'useEffect' не спрацює при поверненні на екран. 'useFocusEffect' — це спеціальне рішення від React Navigation.",
    "interviewTip": "Це важливо для оновлення даних, коли користувач повертається назад на попередній екран.",
    "options": [
      "Використовуючи useEffect без залежностей.",
      "Використовуючи хук 'useFocusEffect' або слухач події 'focus'.",
      "Перевіряючи window.isVisible.",
      "React Native обробляє це автоматично за допомогою пропса 'onFocus'."
    ]
  },
  "nav-11": {
    "prompt": "Що станеться, якщо викликати 'navigation.popToTop()'?",
    "explanation": "Це зручний метод у Stack-навігаторах для миттєвого очищення історії навігації та повернення до самого першого (кореневого) екрана.",
    "interviewTip": "Це часто використовується для кнопки «Додому» або при завершенні багатоетапного процесу оформлення замовлення.",
    "options": [
      "Він перезавантажує поточний екран.",
      "Він повертає на один екран назад.",
      "Він видаляє всі екрани в стеку, крім самого першого (кореневого).",
      "Він переносить користувача на головний екран телефону."
    ]
  },
  "nav-12": {
    "prompt": "Як приховати заголовок (header) для конкретного екрана?",
    "explanation": "Опція 'headerShown: false' є стандартом для видалення стандартної панелі навігації на конкретному екрані.",
    "interviewTip": "Ви можете зробити це, якщо створюєте власний кастомний заголовок або для екрана заставки (splash screen).",
    "options": ["headerShown", "hideHeader", "noHeader", "displayHeader"]
  },
  "nav-13": {
    "prompt": "Що таке 'Tab Nesting' (Вкладеність навігаторів)?",
    "explanation": "Вкладеність дозволяє мати глобальну панель вкладок (Bottom Tabs), де кожна вкладка має власну незалежну історію переходів (наприклад, Home -> Product Details).",
    "interviewTip": "Будьте обережні з глибокою вкладеністю; вона може зробити стан навігації складним для відлагодження.",
    "options": [
      "Розміщення Stack Navigator всередині вкладки Tab Navigator.",
      "Розміщення двох Tab Navigator на одному екрані.",
      "Створення декількох NavigationContainer.",
      "Використання вкладок лише на iOS."
    ]
  },
  "nav-14": {
    "prompt": "Який пропс дозволяє налаштувати іконку в Bottom Tab Navigator?",
    "explanation": "tabBarIcon — це функція, яка повертає компонент (зазвичай іконку) для відображення в панелі вкладок.",
    "interviewTip": "Функція отримує аргументи { focused, color, size }, що допомагає стилізувати активний та неактивний стани.",
    "options": ["tabIcon", "tabBarIcon", "iconName", "renderIcon"]
  }
}
