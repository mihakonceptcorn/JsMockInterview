{
  "pn-01": {
    "prompt": "Яка основна різниця між «локальним сповіщенням» та «віддаленим пуш-сповіщенням»?",
    "explanation": "Локальні сповіщення (як будильник або таймер) створюються та залишаються на пристрої. Віддалені сповіщення ініціюються зовнішнім сервером для взаємодії з користувачем.",
    "interviewTip": "Для вашого додатка JS Mock Interview локальні сповіщення ідеально підійдуть для нагадування «потренуватися завтра».",
    "options": [
      "Локальні сповіщення потребують інтернету; віддалені — ні.",
      "Локальні сповіщення плануються самим додатком на пристрої; віддалені надсилаються з сервера через APNs або FCM.",
      "Віддалені сповіщення працюють лише тоді, коли додаток відкритий.",
      "Локальні сповіщення призначені лише для Android."
    ]
  },
  "pn-02": {
    "prompt": "Який сервіс використовує React Native для доставки сповіщень на iOS-пристрої, навіть при використанні Firebase?",
    "explanation": "Навіть якщо ви використовуєте Firebase, Google зрештою має передати повідомлення службі APNs від Apple, щоб воно потрапило на iPhone.",
    "interviewTip": "Ось чому вам все одно потрібен обліковий запис Apple Developer та сертифікати .p8, навіть якщо ви працюєте через Firebase.",
    "options": [
      "GCM (Google Cloud Messaging)",
      "APNs (Apple Push Notification service)",
      "iCloud Sync",
      "WNS (Windows Notification Service)"
    ]
  },
  "pn-03": {
    "prompt": "Що таке 'FCM Token'?",
    "explanation": "Ваш сервер надсилає повідомлення саме на цей токен. Якщо користувач видалить і знову встановить додаток, токен зазвичай змінюється.",
    "interviewTip": "Завжди відправляйте токен у базу даних вашого бекенду під час запуску додатка або входу в систему.",
    "options": [
      "Пароль для консолі Firebase.",
      "Унікальний ідентифікатор екземпляра додатка на конкретному пристрої, який використовується сервером для таргетингу на цього користувача.",
      "Частина коду, яка шифрує повідомлення.",
      "Електронна адреса користувача."
    ]
  },
  "pn-04": {
    "prompt": "Як обробити натискання на сповіщення, коли додаток повністю закритий (стан Quit)?",
    "explanation": "getInitialNotification — це одноразова перевірка, яка повертає дані сповіщення, якщо додаток було запущено саме через натискання на нього.",
    "interviewTip": "Це найпоширеніше місце, де починається логіка «Deep Linking» після того, як користувач тапнув на пуш.",
    "options": [
      "getInitialNotification",
      "onNotificationOpenedApp",
      "setBackgroundMessageHandler",
      "popNotification"
    ]
  },
  "pn-05": {
    "prompt": "Яке призначення «Каналів сповіщень» (Notification Channels) на Android?",
    "explanation": "Android 8.0+ вимагає наявності каналів. Без валідного ID каналу сповіщення просто не відображатимуться на сучасних Android-пристроях.",
    "interviewTip": "На iOS цієї концепції не існує; користувачі можуть лише ввімкнути або вимкнути сповіщення для всього додатка.",
    "options": [
      "Для стрімінгу відеоконтенту всередині сповіщення.",
      "Щоб дозволити користувачам налаштовувати важливість та звук для різних категорій сповіщень (наприклад, Чати проти Маркетингу).",
      "Для збільшення швидкості доставки.",
      "Щоб обійти режим «Не турбувати»."
    ]
  },
  "pn-06": {
    "prompt": "Що відбувається при отриманні «тихого» (Silent/Data-only) сповіщення?",
    "explanation": "Тихі сповіщення містять лише дані без заголовка (title) чи тексту (body). Вони використовуються, щоб «розбудити» додаток для непомітного завантаження нового контенту.",
    "interviewTip": "Будьте обережні: і iOS, і Android обмежують кількість тихих пушів для запобігання розряджанню акумулятора.",
    "options": [
      "Телефон вібрує, але не показує текст.",
      "Воно не показує UI-повідомлення, але запускає фонове завдання в додатку для синхронізації даних.",
      "Сповіщення видаляється негайно.",
      "Це працює лише тоді, коли екран увімкнено."
    ]
  },
  "pn-07": {
    "prompt": "Які з цих елементів необхідні для активації пуш-сповіщень на iOS?",
    "explanation": "iOS дуже сувора в цьому плані. Вам потрібні всі ці налаштування та реальний пристрій для тестування повного циклу від сервера до смартфона.",
    "interviewTip": "Нові версії Xcode та симулятори додали обмежену підтримку, але фізичний пристрій залишається галузевим стандартом для тестування.",
    "options": [
      "Увімкнена опція Push Notifications Capability в Xcode.",
      "Увімкнені Background Modes (Remote notifications) в Xcode.",
      "Фізичний пристрій (симулятори за замовчуванням не підтримують віддалені пуші).",
      "Валідний Auth Key (.p8) або сертифікат (.p12)."
    ]
  },
  "pn-08": {
    "prompt": "Яка роль 'setBackgroundMessageHandler' у React Native Firebase?",
    "explanation": "Цей обробник працює у власному спеціалізованому потоці поза вашим основним деревом компонентів React.",
    "interviewTip": "Тримайте цю функцію «чистою» (pure) і уникайте використання хуків або складної UI-логіки всередині неї.",
    "options": [
      "Для зміни шпалер телефону.",
      "Для обробки вхідних повідомлень з даними (data-only), коли додаток знаходиться у фоновому режимі або закритий.",
      "Для відтворення кастомного звуку.",
      "Для збереження повідомлення в AsyncStorage."
    ]
  },
  "pn-09": {
    "prompt": "Що таке «перевантаження сповіщеннями» (Notification Overloading)?",
    "explanation": "Це термін з області UX. Занадто часті та нерелевантні сповіщення — це причина №1 видалення додатків.",
    "interviewTip": "Згадуйте «персоналізацію сповіщень» та «обмеження частоти» (Frequency Capping) як способи вирішення цієї проблеми.",
    "options": [
      "Надсилання занадто великої кількості сповіщень, що призводить до їх вимкнення користувачами або видалення додатка.",
      "Коли текст сповіщення занадто довгий для екрана.",
      "Помилка, через яку одне й те саме сповіщення з'являється двічі.",
      "Використання занадто великої кількості зображень у сповіщенні."
    ]
  },
  "pn-10": {
    "prompt": "Як запитати дозвіл на сповіщення у користувача в React Native?",
    "explanation": "requestPermission() повертає статус авторизації (authorized, denied, provisional). На iOS це викликає системне вікно запиту.",
    "interviewTip": "Завжди перевіряйте поточний статус дозволу перед запитом, щоб не дратувати користувачів повторними вікнами. На Android 13+ також потрібно запитувати дозвіл POST_NOTIFICATIONS під час виконання.",
    "options": [
      "getPermission",
      "requestPermission",
      "askForNotifications",
      "enablePush"
    ]
  }
}
