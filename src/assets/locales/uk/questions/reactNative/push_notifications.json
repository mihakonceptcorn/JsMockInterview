{
  "pn-01": {
    "prompt": "Яка основна різниця між «локальним сповіщенням» та «віддаленим пуш-сповіщенням»?",
    "explanation": "Локальні сповіщення (як будильник або таймер) створюються та залишаються на пристрої. Віддалені сповіщення ініціюються зовнішнім сервером для взаємодії з користувачем.",
    "interviewTip": "Для вашого додатка JS Mock Interview локальні сповіщення ідеально підійдуть для нагадування «потренуватися завтра»."
  },
  "pn-02": {
    "prompt": "Який сервіс використовує React Native для доставки сповіщень на iOS-пристрої, навіть при використанні Firebase?",
    "explanation": "Навіть якщо ви використовуєте Firebase, Google зрештою має передати повідомлення службі APNs від Apple, щоб воно потрапило на iPhone.",
    "interviewTip": "Ось чому вам все одно потрібен обліковий запис Apple Developer та сертифікати .p8, навіть якщо ви працюєте через Firebase."
  },
  "pn-03": {
    "prompt": "Що таке 'FCM Token'?",
    "explanation": "Ваш сервер надсилає повідомлення саме на цей токен. Якщо користувач видалить і знову встановить додаток, токен зазвичай змінюється.",
    "interviewTip": "Завжди відправляйте токен у базу даних вашого бекенду під час запуску додатка або входу в систему."
  },
  "pn-04": {
    "prompt": "Як обробити натискання на сповіщення, коли додаток повністю закритий (стан Quit)?",
    "explanation": "getInitialNotification — це одноразова перевірка, яка повертає дані сповіщення, якщо додаток було запущено саме через натискання на нього.",
    "interviewTip": "Це найпоширеніше місце, де починається логіка «Deep Linking» після того, як користувач тапнув на пуш."
  },
  "pn-05": {
    "prompt": "Яке призначення «Каналів сповіщень» (Notification Channels) на Android?",
    "explanation": "Android 8.0+ вимагає наявності каналів. Без валідного ID каналу сповіщення просто не відображатимуться на сучасних Android-пристроях.",
    "interviewTip": "На iOS цієї концепції не існує; користувачі можуть лише ввімкнути або вимкнути сповіщення для всього додатка."
  },
  "pn-06": {
    "prompt": "Що відбувається при отриманні «тихого» (Silent/Data-only) сповіщення?",
    "explanation": "Тихі сповіщення містять лише дані без заголовка (title) чи тексту (body). Вони використовуються, щоб «розбудити» додаток для непомітного завантаження нового контенту.",
    "interviewTip": "Будьте обережні: і iOS, і Android обмежують кількість тихих пушів для запобігання розряджанню акумулятора."
  },
  "pn-07": {
    "prompt": "Які з цих елементів необхідні для активації пуш-сповіщень на iOS?",
    "explanation": "iOS дуже сувора в цьому плані. Вам потрібні всі ці налаштування та реальний пристрій для тестування повного циклу від сервера до смартфона.",
    "interviewTip": "Нові версії Xcode та симулятори додали обмежену підтримку, але фізичний пристрій залишається галузевим стандартом для тестування."
  },
  "pn-08": {
    "prompt": "Яка роль 'setBackgroundMessageHandler' у React Native Firebase?",
    "explanation": "Цей обробник працює у власному спеціалізованому потоці поза вашим основним деревом компонентів React.",
    "interviewTip": "Тримайте цю функцію «чистою» (pure) і уникайте використання хуків або складної UI-логіки всередині неї."
  },
  "pn-09": {
    "prompt": "Що таке «перевантаження сповіщеннями» (Notification Overloading)?",
    "explanation": "Це термін з області UX. Занадто часті та нерелевантні сповіщення — це причина №1 видалення додатків.",
    "interviewTip": "Згадуйте «персоналізацію сповіщень» та «обмеження частоти» (Frequency Capping) як способи вирішення цієї проблеми."
  },
  "pn-10": {
    "prompt": "Як запитати дозвіл на сповіщення у користувача в React Native?",
    "explanation": "requestPermission() повертає статус авторизації (authorized, denied, provisional). На iOS це викликає системне вікно запиту.",
    "interviewTip": "Завжди перевіряйте поточний статус дозволу перед запитом, щоб не дратувати користувачів повторними вікнами. На Android 13+ також потрібно запитувати дозвіл POST_NOTIFICATIONS під час виконання."
  }
}
