{
  "ps-01": {
    "prompt": "Який вбудований модуль використовується для визначення операційної системи під час виконання коду JavaScript?",
    "explanation": "Модуль 'Platform' надає властивість 'Platform.OS', яка повертає значення 'ios' або 'android'.",
    "interviewTip": "Ви також можете використовувати 'Platform.Version', щоб перевірити конкретний рівень API або версію системи пристрою."
  },
  "ps-02": {
    "prompt": "Як застосувати різні стилі для iOS та Android за допомогою методу Platform.select?",
    "explanation": "Platform.select приймає об'єкт, де ключами є назви платформ, і повертає значення для тієї платформи, на якій зараз запущено додаток.",
    "interviewTip": "Це набагато чистіше, ніж використання кількох тернарних операторів (Platform.OS === 'ios' ? ... : ...)."
  },
  "ps-03": {
    "prompt": "Яким є правило іменування файлів для створення окремих реалізацій для iOS та Android, які React Native підхопить автоматично?",
    "explanation": "Пакувальник React Native (Metro) виявляє розширення для конкретної платформи (.ios.js або .android.js) і автоматично імпортує правильний файл при виклику 'import Header from \"./Header\"'.",
    "interviewTip": "Це найкращий патерн для складних компонентів, які потребують абсолютно різних нативних реалізацій."
  },
  "ps-04": {
    "prompt": "Які з наведених варіантів є валідними способами обробки відмінностей між платформами в React Native?",
    "explanation": "React Native надає можливість визначення ОС, утиліту select та поділ на рівні файлів. Вбудованого компонента <NativeTarget> не існує.",
    "interviewTip": "Зауважте, що розширення файлів найкраще підходять для великих відмінностей у логіці, тоді як Platform.select — для незначних коригувань стилів."
  },
  "ps-05": {
    "prompt": "Як перевірити, чи має поточний пристрій Android певний рівень API (наприклад, API 30)?",
    "explanation": "Для Android Platform.Version повертає ціле число (наприклад, 30, 31). Для iOS він повертає рядок із версією системи (наприклад, '17.2').",
    "interviewTip": "Завжди пам'ятайте спочатку перевіряти ОС, оскільки '30' (число) та '17.2' (рядок) порівнюються в JS по-різному."
  },
  "ps-06": {
    "prompt": "Що повертає властивість 'Platform.isPad'?",
    "explanation": "Platform.isPad — це булеве значення, специфічне для iOS, яке дозволяє розрізняти макети для iPhone та iPad.",
    "interviewTip": "Для кросплатформної перевірки на планшет зазвичай потрібно перевіряти ширину екрана за допомогою Dimensions."
  },
  "ps-07": {
    "prompt": "Яка властивість модуля Platform використовується для перевірки, чи запущено додаток у середовищі TV (як-от Apple TV або Android TV)?",
    "explanation": "Platform.isTV — це булеве значення, яке допомагає адаптувати логіку навігації для інтерфейсів, що керуються пультом (focus-based).",
    "interviewTip": "Додатки для ТБ вимагають фокусованих (focusable) компонентів, що є зовсім іншою парадигмою, ніж сенсорне керування."
  },
  "ps-08": {
    "prompt": "Проаналізуйте код. Що робитиме властивість 'elevation' на пристрої iOS?",
    "explanation": "Android використовує 'elevation' для створення тіней (Material Design), тоді як iOS використовує набір властивостей: 'shadowColor', 'shadowOffset', 'shadowOpacity' та 'shadowRadius'.",
    "interviewTip": "Щоб отримати однакові тіні на обох платформах, потрібно визначити обидва набори властивостей або використати бібліотеку на кшталт 'react-native-shadow-2'."
  },
  "ps-09": {
    "prompt": "Як визначити компонент, який рендериться лише у веб-версії при використанні 'React Native for Web'?",
    "explanation": "Metro та Webpack можна налаштувати так, щоб вони розпізнавали розширення '.web.js' для специфічних реалізацій під браузер.",
    "interviewTip": "Це дозволяє використовувати стандартні теги <div> та <a> для веб-версії, зберігаючи View/Text для мобільної."
  },
  "ps-10": {
    "prompt": "Яке призначення ключа 'default' у методі 'Platform.select'?",
    "explanation": "Ключ 'default' діє як запасний варіант (fallback) для будь-якої платформи, яка не вказана явно в об'єкті.",
    "interviewTip": "Це чудово підходить для підтримки сумісності з майбутніми платформами, такими як 'macos' або 'windows'."
  }
}
