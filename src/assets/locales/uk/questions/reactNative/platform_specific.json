{
  "ps-01": {
    "prompt": "Який вбудований модуль використовується для визначення операційної системи під час виконання коду JavaScript?",
    "explanation": "Модуль 'Platform' надає властивість 'Platform.OS', яка повертає значення 'ios' або 'android'.",
    "interviewTip": "Ви також можете використовувати 'Platform.Version', щоб перевірити конкретний рівень API або версію системи пристрою.",
    "options": ["Device", "OS", "Platform", "System"]
  },
  "ps-02": {
    "prompt": "Як застосувати різні стилі для iOS та Android за допомогою методу Platform.select?",
    "explanation": "Platform.select приймає об'єкт, де ключами є назви платформ, і повертає значення для тієї платформи, на якій зараз запущено додаток.",
    "interviewTip": "Це набагато чистіше, ніж використання кількох тернарних операторів (Platform.OS === 'ios' ? ... : ...).",
    "options": ["paddingTop", "marginTop", "safeArea", "topOffset"]
  },
  "ps-03": {
    "prompt": "Яким є правило іменування файлів для створення окремих реалізацій для iOS та Android, які React Native підхопить автоматично?",
    "explanation": "Пакувальник React Native (Metro) виявляє розширення для конкретної платформи (.ios.js або .android.js) і автоматично імпортує правильний файл при виклику 'import Header from \"./Header\"'.",
    "interviewTip": "Це найкращий патерн для складних компонентів, які потребують абсолютно різних нативних реалізацій.",
    "options": [
      "Header.ios.js та Header.android.js",
      "ios/Header.js та android/Header.js",
      "Header(ios).js та Header(android).js",
      "Header_ios.js та Header_android.js"
    ]
  },
  "ps-04": {
    "prompt": "Які з наведених варіантів є валідними способами обробки відмінностей між платформами в React Native?",
    "explanation": "React Native надає можливість визначення ОС, утиліту select та поділ на рівні файлів. Вбудованого компонента <NativeTarget> не існує.",
    "interviewTip": "Зауважте, що розширення файлів найкраще підходять для великих відмінностей у логіці, тоді як Platform.select — для незначних коригувань стилів.",
    "options": [
      "Використання умови Platform.OS.",
      "Використання методу Platform.select().",
      "Використання розширень файлів для конкретних платформ (.ios.js / .android.js).",
      "Використання компонента-обгортки <NativeTarget>."
    ]
  },
  "ps-05": {
    "prompt": "Як перевірити, чи має поточний пристрій Android певний рівень API (наприклад, API 30)?",
    "explanation": "Для Android Platform.Version повертає ціле число (наприклад, 30, 31). Для iOS він повертає рядок із версією системи (наприклад, '17.2').",
    "interviewTip": "Завжди пам'ятайте спочатку перевіряти ОС, оскільки '30' (число) та '17.2' (рядок) порівнюються в JS по-різному.",
    "options": [
      "Це правильний спосіб.",
      "Використовувати Platform.API_LEVEL.",
      "Використовувати DeviceInfo.getApiLevel().",
      "Рівні Android API недоступні через Platform."
    ]
  },
  "ps-06": {
    "prompt": "Що повертає властивість 'Platform.isPad'?",
    "explanation": "Platform.isPad — це булеве значення, специфічне для iOS, яке дозволяє розрізняти макети для iPhone та iPad.",
    "interviewTip": "Для кросплатформної перевірки на планшет зазвичай потрібно перевіряти ширину екрана за допомогою Dimensions.",
    "options": [
      "True, якщо додаток запущено на планшеті (Android або iOS).",
      "True, якщо додаток запущено на Apple iPad.",
      "Рядок, що ідентифікує виробника планшета.",
      "True, якщо до пристрою підключено стилус."
    ]
  },
  "ps-07": {
    "prompt": "Яка властивість модуля Platform використовується для перевірки, чи запущено додаток у середовищі TV (як-от Apple TV або Android TV)?",
    "explanation": "Platform.isTV — це булеве значення, яке допомагає адаптувати логіку навігації для інтерфейсів, що керуються пультом (focus-based).",
    "interviewTip": "Додатки для ТБ вимагають фокусованих (focusable) компонентів, що є зовсім іншою парадигмою, ніж сенсорне керування.",
    "options": [
      "Platform.isTV",
      "Platform.TV_MODE",
      "Platform.isTVOS",
      "Platform.uiMode === 'tv'"
    ]
  },
  "ps-08": {
    "prompt": "Проаналізуйте код. Що робитиме властивість 'elevation' на пристрої iOS?",
    "explanation": "Android використовує 'elevation' для створення тіней (Material Design), тоді як iOS використовує набір властивостей: 'shadowColor', 'shadowOffset', 'shadowOpacity' та 'shadowRadius'.",
    "interviewTip": "Щоб отримати однакові тіні на обох платформах, потрібно визначити обидва набори властивостей або використати бібліотеку на кшталт 'react-native-shadow-2'.",
    "options": [
      "Вона створить тінь на iOS.",
      "Вона буде ігноруватися, оскільки 'elevation' — властивість лише для Android.",
      "Вона викличе помилку на iOS.",
      "Вона змінить z-index картки."
    ]
  },
  "ps-09": {
    "prompt": "Як визначити компонент, який рендериться лише у веб-версії при використанні 'React Native for Web'?",
    "explanation": "Metro та Webpack можна налаштувати так, щоб вони розпізнавали розширення '.web.js' для специфічних реалізацій під браузер.",
    "interviewTip": "Це дозволяє використовувати стандартні теги <div> та <a> для веб-версії, зберігаючи View/Text для мобільної.",
    "options": [
      "MyComponent.web.js",
      "MyComponent.browser.js",
      "MyComponent.html.js",
      "MyComponent.js та перевірка Platform.OS === 'web'"
    ]
  },
  "ps-10": {
    "prompt": "Яке призначення ключа 'default' у методі 'Platform.select'?",
    "explanation": "Ключ 'default' діє як запасний варіант (fallback) для будь-якої платформи, яка не вказана явно в об'єкті.",
    "interviewTip": "Це чудово підходить для підтримки сумісності з майбутніми платформами, такими як 'macos' або 'windows'.",
    "options": [
      "Він вибирає значення за замовчуванням, якщо ОС не є iOS або Android (наприклад, Web/Windows).",
      "Він викликає помилку, якщо платформа відсутня.",
      "Він випадковим чином вибирає один із варіантів.",
      "Ключ 'default' не підтримується."
    ]
  }
}
