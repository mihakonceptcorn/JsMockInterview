{
  "sec-01": {
    "prompt": "Що таке 'SSL Pinning' і чому він використовується в додатках React Native?",
    "explanation": "Навіть із HTTPS зловмисник іноді може змусити пристрій довіряти фальшивому сертифікату. SSL Pinning гарантує, що додаток відхилить будь-який сертифікат, який не збігається з «закріпленим» (pinned) сертифікатом вашого сервера.",
    "interviewTip": "Згадайте бібліотеки на кшталт 'react-native-ssl-pinning' або 'TrustKit'. Попередження: якщо термін дії сертифіката вашого сервера закінчиться, а ви не оновите додаток, він перестане працювати!",
    "options": [
      "Спосіб закріпити іконку додатка на головному екрані.",
      "Техніка запобігання атакам Man-in-the-Middle (MITM) шляхом перевірки відповідності сертифіката сервера заздалегідь визначеному значенню в додатку.",
      "Метод шифрування JavaScript-бандла.",
      "Функція, яка тримає користувача залогіненим назавжди."
    ]
  },
  "sec-02": {
    "prompt": "Як слід зберігати чутливі ключі (наприклад, секрети API) у додатку React Native?",
    "explanation": "Стандартні сховища (AsyncStorage/MMKV) не шифруються. Keychain (iOS) та Keystore (Android) забезпечують шифрування на апаратному рівні, розроблене спеціально для секретів.",
    "interviewTip": "Чудова відповідь включає: «Я використовую .env файли для конфігурації під час збірки, але секрети, специфічні для пристрою, зберігаються в Secure Keychain».",
    "options": [
      "Прописати їх жорстко (hardcode) у файлі 'constants.js'.",
      "Зберігати у 'package.json' для легкого доступу.",
      "В iOS Keychain або Android Keystore за допомогою бібліотеки на кшталт 'react-native-keychain'.",
      "У локальному стані (state) компонента."
    ]
  },
  "sec-03": {
    "prompt": "Яка мета виявлення 'Jailbreak' (iOS) або 'Root' (Android) у мобільних додатках?",
    "explanation": "На пристроях із рут-правами зловмисники можуть обходити обмеження «пісочниці», читати приватні дані вашого додатка або перехоплювати дані з пам'яті. Банківські та високонадійні додатки часто блокують доступ на таких пристроях.",
    "interviewTip": "Використовуйте 'react-native-jail-monkey' або 'expo-device', щоб перевірити, чи є середовище пристрою надійним.",
    "options": [
      "Для прискорення додатка на модифікованих пристроях.",
      "Для ідентифікації компрометації рівнів безпеки пристрою, що дозволяє додатку вимкнути чутливі функції (наприклад, платежі).",
      "Для автоматичного оновлення ОС.",
      "Щоб дозволити користувачеві обійти App Store."
    ]
  },
  "sec-04": {
    "prompt": "Проаналізуйте конфігурацію Android. Що роблять параметри 'minifyEnabled true' та 'proguardFiles'?",
    "explanation": "Proguard/R8 видаляє невикористовуваний код і перейменовує класи та методи на безглузді імена (наприклад, 'a', 'b', 'c'), що робить нативний бінарний файл складним для аналізу (обфускація).",
    "interviewTip": "Завжди вмикайте це для релізних збірок. Це перша лінія захисту від декомпіляторів.",
    "options": [
      "Це робить розмір шрифтів у додатку меншим.",
      "Це обфускує код і видаляє невикористовувані частини, що значно ускладнює реверс-інжиніринг вашої Java/Kotlin логіки.",
      "Це шифрує фотографії користувача.",
      "Це вмикає швидше налагодження на Android."
    ]
  },
  "sec-05": {
    "prompt": "Чому небезпечно залишати 'console.log' у продакшн-збірці React Native?",
    "explanation": "Логи відображаються не лише у вашому терміналі; вони транслюються в системний лог пристрою. У релізних збірках усі логи мають бути видалені.",
    "interviewTip": "Використовуйте 'babel-plugin-transform-remove-console', щоб автоматично видалити всі логи під час процесу збірки продакшн-версії.",
    "options": [
      "Це робить інтерфейс додатка потворним.",
      "Логи доступні через системні інструменти (logcat, Xcode), що може призвести до витоку конфіденційних даних (токенів, інфо користувача).",
      "Це призводить до автоматичної відмови App Store.",
      "Це надзвичайно швидко розряджає батарею."
    ]
  },
  "sec-06": {
    "prompt": "Які з наведених методів є валідними для захисту самого JavaScript-бандла?",
    "explanation": "Двигун Hermes забезпечує «захист через компіляцію» у байт-код. Обфускатори додають додатковий рівень складності до самої логіки коду.",
    "interviewTip": "Поясніть, що жоден JS-код не є на 100% «прихованим», але ці кроки роблять його злом значно дорожчим та складнішим для атакуючого.",
    "options": [
      "Використання 'JSC' замість 'Hermes'.",
      "Використання Hermes (він компілює JS у байт-код, який важче прочитати, ніж звичайний текст).",
      "Використання обфускатора на кшталт 'javascript-obfuscator' перед збіркою.",
      "Перейменування файлу .js у .png."
    ]
  },
  "sec-07": {
    "prompt": "Що таке «перехоплення посилань» (Deep Link Hijacking)?",
    "explanation": "Схеми URL (myapp://) не є ексклюзивними. Щоб запобігти перехопленню, слід використовувати 'Universal Links' (iOS) або 'App Links' (Android), які використовують верифікований домен веб-сайту для підтвердження власності.",
    "interviewTip": "Завжди надавайте перевагу Universal Links на основі HTTPS замість кастомних URI-схем для процесів автентифікації.",
    "options": [
      "Коли веб-сайт посилається на неправильну сторінку.",
      "Коли шкідливий додаток реєструє таку ж URL-схему, як і ваш, щоб перехопити дані, надіслані через посилання.",
      "Коли інтернет зникає під час навігації.",
      "Коли користувач натискає на посилання занадто багато разів."
    ]
  },
  "sec-08": {
    "prompt": "У чому полягає ризик безпеки при використанні 'allowFileAccess' або 'javaScriptEnabled' у WebView?",
    "explanation": "WebView — це фактично міні-браузери. Якщо ви завантажуєте ненадійні URL-адреси з повними дозволами, ви ризикуєте надати цьому сайту доступ до внутрішньої файлової системи додатка.",
    "interviewTip": "Вмикайте лише ті функції, які вам дійсно потрібні, і завжди використовуйте 'originWhitelist' для обмеження доменів, які може відвідувати WebView.",
    "options": [
      "Додаток вичерпає оперативну пам'ять.",
      "Це може відкрити двері для атак Cross-Site Scripting (XSS), де шкідливий веб-контент отримує доступ до локальних файлів пристрою.",
      "WebView буде рендеритися занадто повільно.",
      "Користувач зможе побачити вихідний код додатка."
    ]
  },
  "sec-09": {
    "prompt": "Як реалізувати біометричну автентифікацію (Face ID / Touch ID) у React Native?",
    "explanation": "Спеціальні бібліотеки надають кросплатформний API для перевірки доступності біометрії та виклику системного вікна автентифікації.",
    "interviewTip": "Завжди залишайте можливість входу за допомогою ПІН-коду або пароля на випадок, якщо біометрія не спрацює або недоступна на пристрої.",
    "options": [
      "Це вбудовано в React Native за замовчуванням.",
      "Використовувати бібліотеку типу 'react-native-biometrics' або 'expo-local-authentication'.",
      "Потрібно писати нативний Swift/Kotlin код для кожної платформи.",
      "Біометрична автентифікація неможлива в React Native."
    ]
  },
  "sec-10": {
    "prompt": "Який рекомендований спосіб шифрування конфіденційних даних перед їх локальним зберіганням?",
    "explanation": "Base64 — це кодування, а не шифрування; його легко розкодувати. AES-256 — це надійний стандарт шифрування, який вимагає ключ для доступу до даних.",
    "interviewTip": "Зберігайте ключ шифрування в Keychain/Keystore і ніколи не прописуйте його жорстко (hardcode) у вашому JavaScript-коді.",
    "options": [
      "Використовувати кодування Base64.",
      "Використовувати бібліотеку на кшталт 'react-native-aes-crypto' для шифрування AES-256 перед збереженням в AsyncStorage/MMKV.",
      "Зберігати дані у відкритому тексті, але приховати файл.",
      "Шифрування не потрібне для мобільних додатків."
    ]
  }
}
