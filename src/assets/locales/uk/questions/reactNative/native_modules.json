{
  "nm-01": {
    "prompt": "Яку роль відіграє 'RCTBridgeModule' в iOS у старій архітектурі (Legacy)?",
    "explanation": "Щоб зробити нативний клас доступним для JS, він повинен реалізувати протокол RCTBridgeModule та використовувати макрос RCT_EXPORT_MODULE.",
    "interviewTip": "Пам'ятайте, що дані, які проходять через цей міст (bridge), повинні бути серіалізовані в JSON, що може бути «вузьким місцем» для продуктивності.",
    "options": [
      "Це JavaScript-клас, який визначає компоненти інтерфейсу.",
      "Це протокол, який повинен реалізувати клас Objective-C/Swift, щоб бути доступним із JavaScript.",
      "Це інструмент, який компілює JS у машинний код.",
      "Це головна точка входу для App Store."
    ]
  },
  "nm-02": {
    "prompt": "У чому полягає основна технічна перевага 'Turbo Modules' над старими нативними модулями?",
    "explanation": "Старі модулі ініціалізуються всі разом при запуску додатка, що уповільнює старт. Turbo Modules завантажуються за запитом (lazy loading) і дозволяють синхронні виклики через JSI.",
    "interviewTip": "Якщо інтерв'юер запитає про продуктивність запуску додатка, обов'язково згадайте про «ледаче завантаження» (Lazy Loading) Turbo-модулів.",
    "options": [
      "Вони написані на Python замість Java.",
      "Вони завантажуються «ледаче» (лише за потреби) і використовують JSI для прямого зв'язку.",
      "Вони автоматично завантажують дані в хмару.",
      "Вони не потребують жодного нативного коду."
    ]
  },
  "nm-03": {
    "prompt": "Проаналізуйте нативний код для Android. Яке призначення анотації @ReactMethod?",
    "explanation": "Без цієї анотації метод залишиться невидимим для моста React Native, навіть якщо сам клас було експортовано.",
    "interviewTip": "Лише методи, позначені @ReactMethod, можуть бути викликані через 'NativeModules.ModuleName.methodName()'.",
    "options": [
      "Вона позначає метод як приватний для нативного класу.",
      "Вона експортує метод, щоб його можна було викликати з JavaScript-коду.",
      "Вона вказує ОС Android запускати це у фоновому режимі.",
      "Вона шифрує параметри."
    ]
  },
  "nm-04": {
    "prompt": "Як JavaScript взаємодіє з нативною стороною в Новій архітектурі без серіалізації даних?",
    "explanation": "JSI дозволяє рушію JavaScript (Hermes) тримати пряме посилання на об'єкт C++, що уможливлює миттєві синхронні виклики методів замість передачі JSON-повідомлень.",
    "interviewTip": "JSI — це те, що робить бібліотеку 'Reanimated' такою швидкою: вона дозволяє оновлювати UI без очікування відповіді від моста.",
    "options": [
      "Через чергу моста (Bridge queue).",
      "Використовуючи JSI (JavaScript Interface) для утримання посилань C++ на нативні об'єкти.",
      "Шляхом запису файлів на диск.",
      "Використовуючи WebSockets."
    ]
  },
  "nm-05": {
    "prompt": "Яке призначення 'Codegen' у Новій архітектурі?",
    "explanation": "Codegen забезпечує типізацію між JS та нативним кодом. Він автоматично створює допоміжний код («клей»), тому вам не потрібно писати шаблони C++ вручную.",
    "interviewTip": "Codegen допомагає запобігти помилкам під час виконання (runtime crashes), спричиненим передачею неправильних типів даних між JS та нативною частиною.",
    "options": [
      "Написання інтерфейсу замість вас за допомогою ШІ.",
      "Генерація коду нативного інтерфейсу (C++ / Java / Obj-C) на основі ваших визначень TypeScript/Flow.",
      "Мініфікація JS-бандла.",
      "Перевірка версій npm-пакетів."
    ]
  },
  "nm-06": {
    "prompt": "Які з цих способів є валідними для передачі даних із нативної сторони назад у JavaScript?",
    "explanation": "Callbacks та Promises використовуються для відповідей на конкретні виклики. Події (EventEmitter) потрібні для нативних дій, які JS не ініціював, як-от оновлення GPS-координат.",
    "interviewTip": "Завжди пам'ятайте про видалення слухачів подій у функції очищення 'useEffect', щоб уникнути витоків пам'яті.",
    "options": [
      "Використання Callback (одноразова відповідь).",
      "Використання Promises (одноразова відповідь, сучасний підхід).",
      "Використання DeviceEventEmitter (для стрімінгу подій).",
      "Пряма зміна змінної JS із Java."
    ]
  },
  "nm-07": {
    "prompt": "Що таке 'Native UI Component' (на відміну від Native Module)?",
    "explanation": "У той час як Native Modules надають «логіку», Native UI Components надають «інтерфейс» (views). Ви використовуєте 'requireNativeComponent', щоб додати їх у свій JSX.",
    "interviewTip": "Якщо вам потрібен складний елемент інтерфейсу, якого не існує в RN, ви створюєте 'ViewManager' на нативній стороні.",
    "options": [
      "Частина логіки, наприклад, завантажувач API.",
      "Справжній нативний елемент (як спеціалізований відеоплеєр або мапа), який рендериться як React-компонент.",
      "Кнопка, надана ОС.",
      "Локальна база даних для зберігання."
    ]
  },
  "nm-08": {
    "prompt": "Визначте проблему в цьому нативному методі iOS:",
    "explanation": "Методи старого моста (bridge) є асинхронними та повертають 'void'. Щоб повернути результат у JS, потрібно передати RCTResponseSenderBlock або RCTPromiseResolveBlock.",
    "interviewTip": "У Новій архітектурі з використанням JSI ви дійсно *можете* повертати значення синхронно.",
    "options": [
      "Типи мають бути 'NSInteger'.",
      "Нативні методи моста не можуть повертати значення безпосередньо; вони мають використовувати колбеки або проміси.",
      "Назва методу занадто коротка.",
      "Проблем немає."
    ]
  },
  "nm-09": {
    "prompt": "Що робить макрос 'RCT_EXPORT_MODULE()'?",
    "explanation": "Без цього макроса міст React Native не знатиме про існування класу під час виконання програми.",
    "interviewTip": "Ви можете передати макросу необов'язкове ім'я (наприклад, RCT_EXPORT_MODULE(MyCustomName)), щоб змінити те, як він буде називатися в JS.",
    "options": [
      "Компілює клас у бінарний файл.",
      "Реєструє клас у React Native, щоб до нього можна було отримати доступ через NativeModules у JS.",
      "Експортує клас до App Store.",
      "Робить клас синглтоном."
    ]
  },
  "nm-10": {
    "prompt": "Що таке 'Fabric' у Новій архітектурі та чим він відрізняється від старого рендерера?",
    "explanation": "Старий рендерер використовував асинхронний міст для передачі оновлень UI. Fabric використовує JSI для синхронного зв'язку з нативним потоком UI, що дозволяє пріоритетний рендеринг та складні анімації.",
    "interviewTip": "Fabric — це еквівалент Concurrent Mode (React 18) для нативної сторони: він дозволяє React Native переривати та пріоритезувати оновлення інтерфейсу.",
    "options": [
      "Fabric — це новий CSS-фреймворк для React Native.",
      "Fabric — це нова система синхронного рендерингу, яка замінює асинхронний UIManager для кращої продуктивності та конкурентного рендерингу.",
      "Fabric — це інструмент для деплою додатків у хмару.",
      "Fabric — це база даних для зберігання нативних модулів."
    ]
  }
}
