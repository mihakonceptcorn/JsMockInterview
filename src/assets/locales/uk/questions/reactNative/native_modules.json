{
  "nm-01": {
    "prompt": "Яку роль відіграє 'RCTBridgeModule' в iOS у старій архітектурі (Legacy)?",
    "explanation": "Щоб зробити нативний клас доступним для JS, він повинен реалізувати протокол RCTBridgeModule та використовувати макрос RCT_EXPORT_MODULE.",
    "interviewTip": "Пам'ятайте, що дані, які проходять через цей міст (bridge), повинні бути серіалізовані в JSON, що може бути «вузьким місцем» для продуктивності."
  },
  "nm-02": {
    "prompt": "У чому полягає основна технічна перевага 'Turbo Modules' над старими нативними модулями?",
    "explanation": "Старі модулі ініціалізуються всі разом при запуску додатка, що уповільнює старт. Turbo Modules завантажуються за запитом (lazy loading) і дозволяють синхронні виклики через JSI.",
    "interviewTip": "Якщо інтерв'юер запитає про продуктивність запуску додатка, обов'язково згадайте про «ледаче завантаження» (Lazy Loading) Turbo-модулів."
  },
  "nm-03": {
    "prompt": "Проаналізуйте нативний код для Android. Яке призначення анотації @ReactMethod?",
    "explanation": "Без цієї анотації метод залишиться невидимим для моста React Native, навіть якщо сам клас було експортовано.",
    "interviewTip": "Лише методи, позначені @ReactMethod, можуть бути викликані через 'NativeModules.ModuleName.methodName()'."
  },
  "nm-04": {
    "prompt": "Як JavaScript взаємодіє з нативною стороною в Новій архітектурі без серіалізації даних?",
    "explanation": "JSI дозволяє рушію JavaScript (Hermes) тримати пряме посилання на об'єкт C++, що уможливлює миттєві синхронні виклики методів замість передачі JSON-повідомлень.",
    "interviewTip": "JSI — це те, що робить бібліотеку 'Reanimated' такою швидкою: вона дозволяє оновлювати UI без очікування відповіді від моста."
  },
  "nm-05": {
    "prompt": "Яке призначення 'Codegen' у Новій архітектурі?",
    "explanation": "Codegen забезпечує типізацію між JS та нативним кодом. Він автоматично створює допоміжний код («клей»), тому вам не потрібно писати шаблони C++ вручную.",
    "interviewTip": "Codegen допомагає запобігти помилкам під час виконання (runtime crashes), спричиненим передачею неправильних типів даних між JS та нативною частиною."
  },
  "nm-06": {
    "prompt": "Які з цих способів є валідними для передачі даних із нативної сторони назад у JavaScript?",
    "explanation": "Callbacks та Promises використовуються для відповідей на конкретні виклики. Події (EventEmitter) потрібні для нативних дій, які JS не ініціював, як-от оновлення GPS-координат.",
    "interviewTip": "Завжди пам'ятайте про видалення слухачів подій у функції очищення 'useEffect', щоб уникнути витоків пам'яті."
  },
  "nm-07": {
    "prompt": "Що таке 'Native UI Component' (на відміну від Native Module)?",
    "explanation": "У той час як Native Modules надають «логіку», Native UI Components надають «інтерфейс» (views). Ви використовуєте 'requireNativeComponent', щоб додати їх у свій JSX.",
    "interviewTip": "Якщо вам потрібен складний елемент інтерфейсу, якого не існує в RN, ви створюєте 'ViewManager' на нативній стороні."
  },
  "nm-08": {
    "prompt": "Визначте проблему в цьому нативному методі iOS:",
    "explanation": "Методи старого моста (bridge) є асинхронними та повертають 'void'. Щоб повернути результат у JS, потрібно передати RCTResponseSenderBlock або RCTPromiseResolveBlock.",
    "interviewTip": "У Новій архітектурі з використанням JSI ви дійсно *можете* повертати значення синхронно."
  },
  "nm-09": {
    "prompt": "Що робить макрос 'RCT_EXPORT_MODULE()'?",
    "explanation": "Без цього макроса міст React Native не знатиме про існування класу під час виконання програми.",
    "interviewTip": "Ви можете передати макросу необов'язкове ім'я (наприклад, RCT_EXPORT_MODULE(MyCustomName)), щоб змінити те, як він буде називатися в JS."
  },
  "nm-10": {
    "prompt": "Що таке 'Fabric' у Новій архітектурі та чим він відрізняється від старого рендерера?",
    "explanation": "Старий рендерер використовував асинхронний міст для передачі оновлень UI. Fabric використовує JSI для синхронного зв'язку з нативним потоком UI, що дозволяє пріоритетний рендеринг та складні анімації.",
    "interviewTip": "Fabric — це еквівалент Concurrent Mode (React 18) для нативної сторони: він дозволяє React Native переривати та пріоритезувати оновлення інтерфейсу."
  }
}
