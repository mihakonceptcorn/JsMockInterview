{
  "perf-01": {
    "prompt": "Який двигун JavaScript зараз є стандартним для React Native, оскільки він забезпечує швидший TTI (час до інтерактивності) та менший розмір APK?",
    "explanation": "Hermes оптимізований спеціально для мобільних пристроїв. Він використовує попередню компіляцію (AOT) для перетворення JS на байт-код під час збірки, а не під час виконання.",
    "interviewTip": "Зауважте, що Hermes також допомагає зменшити споживання пам'яті (Memory Footprint), що критично важливо для бюджетних Android-пристроїв."
  },
  "perf-02": {
    "prompt": "Що таке 'FlashList' (від Shopify) і чому його часто використовують замість 'FlatList'?",
    "explanation": "FlatList демонтує елементи, що вийшли за екран. FlashList перевикористовує (recycles) нативні в'юхи та просто підміняє в них дані, що набагато легше для пристрою.",
    "interviewTip": "FlashList заявляє про прискорення у 5-10 разів порівняно з FlatList. Це чудовий аргумент для Senior-рівня обговорення продуктивності."
  },
  "perf-03": {
    "prompt": "Проаналізуйте код. Чому цей список, швидше за все, буде лагати при швидкому скролі?",
    "explanation": "Функції, визначені всередині тіла компонента, перестворюються при кожному рендері. Крім того, важка логіка на кшталт 'expensiveFormat' всередині renderItem блокує JS-потік під час скролу.",
    "interviewTip": "Рішення: винесіть renderItem за межі компонента або огорніть його в 'useCallback', а важке форматування мемоїзуйте."
  },
  "perf-04": {
    "prompt": "Яка мета використання методу 'InteractionManager.runAfterInteractions'?",
    "explanation": "Це гарантує, що важке завдання не відбиратиме ресурси процесора в анімації, запобігаючи «фризам» або випадінню кадрів.",
    "interviewTip": "Це ідеально підходить для завантаження даних одразу після переходу на новий екран, щоб сам перехід не здавався повільним."
  },
  "perf-05": {
    "prompt": "Які з цих інструментів зазвичай використовують для профілювання та відлагодження продуктивності в React Native?",
    "explanation": "Flipper та React DevTools є стандартом для профілювання JS та моста (bridge). Xcode Instruments (та Android Studio Profiler) потрібні для перевірки нативної пам'яті та завантаження процесора.",
    "interviewTip": "Flipper — це вибір професіоналів; він дозволяє інспектувати трафік моста, макет та базу даних в одному місці."
  },
  "perf-06": {
    "prompt": "Як визначити, що ваш JS-потік перевантажений на реальному пристрої?",
    "explanation": "Оверлей 'Perf Monitor' показує частоту кадрів обох потоків. Якщо UI — 60 FPS, а JS — 10 FPS, значить, ваша логіка блокує роботу додатка.",
    "interviewTip": "Падіння JS FPS зазвичай означає занадто багато перерендерингів або важкі обчислення; падіння UI FPS означає, що ваша ієрархія View занадто глибока або складна."
  },
  "perf-07": {
    "prompt": "Що таке оптимізація «інлайнових функцій» (Inline function) у контексті продуктивності RN?",
    "explanation": "Інлайнова стрілкова функція створює нове посилання при кожному рендері. Навіть якщо кнопка огорнута в 'React.memo', вона все одно перерендериться, бо пропс 'onPress' змінив посилання.",
    "interviewTip": "Це найпоширеніша причина «марних рендерів» (Wasted Renders) у великих списках."
  },
  "perf-08": {
    "prompt": "Чому варто уникати глибокої вкладеності компонентів View?",
    "explanation": "Кожен рівень вкладеності додає роботи для рушія розмітки Yoga. Спрощення структури UI покращує швидкість початкового рендерингу та оновлень.",
    "interviewTip": "Якщо у вас 10 вкладених View лише для відступів, спробуйте об'єднати їх у меншу кількість компонентів."
  },
  "perf-09": {
    "prompt": "У чому перевага використання 'RAM bundles' (Random Access Modules) у React Native?",
    "explanation": "RAM-бандли розбивають JavaScript на індексовані модулі. Додаток спочатку завантажує лише модулі для запуску, а решту — за потреби під час навігації.",
    "interviewTip": "Це особливо корисно для великих додатків із багатьма екранами. Згадайте конфігурацію 'Metro bundler' для ввімкнення цієї функції."
  },
  "perf-10": {
    "prompt": "Як Нова архітектура покращує продуктивність порівняно зі старою (Legacy)?",
    "explanation": "Нова архітектура (JSI + Fabric + Turbo Modules) прибирає «вузьке місце» у вигляді серіалізації JSON і дозволяє React спілкуватися з нативним кодом напряму, що дає можливість синхронного рендерингу.",
    "interviewTip": "Зауважте, що це наближає продуктивність React Native до повністю нативних додатків, особливо у складних взаємодіях з інтерфейсом."
  }
}
