{
  "rn-core-01": {
    "prompt": "Який компонент є найфундаментальнішим будівельним блоком інтерфейсу, що діє як контейнер і підтримує макет за допомогою Flexbox?",
    "explanation": "Компонент <View> напряму відображається на нативні аналоги (UIView в iOS, android.view в Android) і використовується для розмітки та стилізації.",
    "interviewTip": "Сприймайте <View> як <div> у React Native."
  },
  "rn-core-02": {
    "prompt": "Що станеться, якщо спробувати відрендерити звичайний текст поза компонентом <Text>?",
    "explanation": "На відміну від вебу, де текст може знаходитися всередині <div>, React Native вимагає, щоб увесь текст був явно огорнутий у компонент <Text>.",
    "interviewTip": "Це дуже поширена помилка початківців при переході з веб-розробки на мобільну."
  },
  "rn-core-03": {
    "prompt": "Як відобразити віддалене зображення за URL-адресою в React Native?",
    "explanation": "Для віддалених зображень потрібен об'єкт із властивістю 'uri'. Локальні зображення використовують функцію 'require'.",
    "interviewTip": "Пам'ятайте, що віддалені зображення в React Native не мають автоматичного розміру; ви ОБОВ'ЯЗКОВО повинні вказати width та height у стилях, інакше вони не з'являться."
  },
  "rn-core-04": {
    "prompt": "Яка основна мета методу 'StyleSheet.create'?",
    "explanation": "StyleSheet.create надсилає об'єкт стилів через міст (bridge) лише один раз, а не створює його заново при кожному рендері, що є більш ефективним.",
    "interviewTip": "Він також забезпечує валідацію, викидаючи помилки, якщо ви використовуєте невалідні властивості CSS, які не підтримуються в React Native."
  },
  "rn-core-05": {
    "prompt": "Який компонент слід використовувати, якщо вам потрібен контейнер, що дозволяє користувачеві гортати контент, розмір якого перевищує екран?",
    "explanation": "<View> не має можливості прокрутки. Для базової прокрутки невеликої кількості контенту правильним вибором є <ScrollView>.",
    "interviewTip": "Для великих списків даних <ScrollView> неефективний, оскільки він рендерить усіх дітей одночасно. Використовуйте <FlatList> для кращої продуктивності."
  },
  "rn-core-06": {
    "prompt": "Які з наступних властивостей є валідними для компонента <Text> у React Native?",
    "explanation": "Компонент <Text> напрочуд потужний: він підтримує скорочення тексту (truncation), нативні події натискання та виділення тексту для копіювання.",
    "interviewTip": "Вкладені компоненти <Text> успадковують стилі від своїх батьків, що відрізняється від того, як працює успадкування у <View>."
  },
  "rn-core-07": {
    "prompt": "Як обробляти локальні ресурси (наприклад, логотип) у компоненті <Image>?",
    "explanation": "Синтаксис 'require' дозволяє пакувальнику (bundler) зібрати метадані зображення (ширину, висоту, шлях) під час збірки додатка.",
    "interviewTip": "На відміну від віддалених зображень, локальним зображенням зазвичай не потрібні явні width/height для появи, хоча їх встановлення вважається хорошою практикою."
  },
  "rn-core-08": {
    "prompt": "Яка різниця між <View> та <SafeAreaView>?",
    "explanation": "SafeAreaView необхідний для пристроїв iOS із «вирізами» (notches), щоб контент не перекривався системними елементами інтерфейсу (статус-баром тощо).",
    "interviewTip": "У сучасній розробці багато хто використовує бібліотеку 'react-native-safe-area-context' для ще кращого контролю над безпечними зонами."
  },
  "rn-core-09": {
    "prompt": "Яким буде результат застосування 'flexDirection' до <View> у React Native?",
    "explanation": "У стандартному Web CSS значенням за замовчуванням є 'row'. У React Native це 'column', що краще підходить для вертикальних екранів мобільних пристроїв.",
    "interviewTip": "Це одна з найчастіших пасток для веб-розробників, які переходять на React Native."
  },
  "rn-core-10": {
    "prompt": "Який компонент використовується для збору тексту від користувача?",
    "explanation": "TextInput — основний компонент для введення з клавіатури. Він підтримує різні типи клавіатур (цифрова, email) та приховане введення для паролів.",
    "interviewTip": "Завжди використовуйте пропс 'onChangeText' (який повертає рядок напряму), а не 'onChange' (який повертає об'єкт події)."
  },
  "rn-core-11": {
    "prompt": "Як застосувати кілька об'єктів стилів до одного компонента?",
    "explanation": "Пропс 'style' у React Native приймає масив об'єктів. Останній об'єкт у масиві має пріоритет (перезаписує попередні).",
    "interviewTip": "Це ідеально підходить для умовних стилів: style={[styles.box, isActive && styles.activeBox]}."
  },
  "rn-core-12": {
    "prompt": "Яке призначення компонента <ActivityIndicator />?",
    "explanation": "Це вбудований компонент, який відображає нативний індикатор завантаження (спінер).",
    "interviewTip": "Ви можете налаштувати його розмір ('small' або 'large') та колір."
  },
  "rn-core-13": {
    "prompt": "Які з наведених значень 'resizeMode' є валідними для компонента <Image>?",
    "explanation": "resizeMode визначає, як зображення має масштабуватися, якщо його рамка не збігається зі співвідношенням сторін самого зображення.",
    "interviewTip": "'cover' є значенням за замовчуванням і зазвичай це те, що вам потрібно для фонів на весь екран."
  },
  "rn-core-14": {
    "prompt": "Чому важливо використовувати 'key' у списку компонентів, що рендеряться всередині ScrollView?",
    "explanation": "Як і в React для вебу, алгоритм узгодження (reconciliation) використовує ключі для відстеження ідентичності елементів у масиві.",
    "interviewTip": "Використання індексу масиву як ключа зазвичай не рекомендується, якщо порядок елементів може змінюватися."
  },
  "rn-core-15": {
    "prompt": "Що робить пропс 'contentContainerStyle' у <ScrollView>?",
    "explanation": "Якщо ви додасте padding до пропса 'style' у ScrollView, контент буде обрізатися. Ви повинні використовувати 'contentContainerStyle', щоб додати відступи до самої області прокрутки.",
    "interviewTip": "Це найпоширеніший спосіб додати «місце для вдиху» внизу довгого списку."
  },
  "rn-core-16": {
    "prompt": "Що відрендерить наступний код на екрані?",
    "explanation": "За замовчуванням Views мають властивість 'alignItems: stretch', тому компонент розтягнеться на всю ширину батька і буде виглядати як лінія висотою в 1 піксель.",
    "interviewTip": "Це поширений спосіб створення кастомних розділювачів (separators) між елементами списку."
  }
}
