{
  "tm-01": {
    "prompt": "Який фреймворк для тестування є стандартним для React Native і відповідає за виконання модульних (unit) тестів?",
    "explanation": "Jest — це стандартний інструмент для запуску тестів у React Native. Він постачається з попередньо налаштованим пресетом 'react-native', який емулює мобільне середовище.",
    "interviewTip": "Зауважте, що 'Snapshot Testing' у Jest — це популярний, але суперечливий спосіб відстеження небажаних змін у UI."
  },
  "tm-02": {
    "prompt": "У чому полягає основна філософія 'React Native Testing Library' (RNTL)?",
    "explanation": "RNTL заохочує тестувати *поведінку*, а не *реалізацію*. Якщо ви проведете рефакторинг коду, але користувач все одно бачить кнопку 'Submit', ваші тести мають залишатися успішними.",
    "interviewTip": "Уникайте використання бібліотеки 'enzyme' у сучасних проектах; RNTL є загальноприйнятим стандартом спільноти."
  },
  "tm-03": {
    "prompt": "Проаналізуйте код. Як у тесті симулювати введення тексту користувачем у поле 'Question'?",
    "explanation": "У RNTL 'fireEvent.changeText' — це спеціалізована подія для компонентів TextInput, яка напряму імітує роботу пропса 'onChangeText'.",
    "interviewTip": "Завжди використовуйте 'fireEvent.press' для кнопок та 'fireEvent.changeText' для інпутів."
  },
  "tm-04": {
    "prompt": "Для чого використовується 'Detox' в екосистемі React Native?",
    "explanation": "Detox запускає ваш додаток у реальному симуляторі та взаємодіє з ним як користувач. Його називають 'gray-box' тестуванням, оскільки він синхронізується з внутрішнім станом додатка для запобігання нестабільним (flaky) тестам.",
    "interviewTip": "Порівнюйте Detox із Cypress; це найближчий мобільний еквівалент для автоматизації повних сценаріїв (End-to-End)."
  },
  "tm-05": {
    "prompt": "Чому в Jest потрібно створювати «мок» (mock) нативних модулів (як-от 'react-native-reanimated' або 'AsyncStorage')?",
    "explanation": "Jest працює в середовищі Node, а не в мобільній ОС. Нативних модулів (C++/Java/Swift) там не існує, тому ви повинні надати JS-реалізацію (mock) для імітації їхньої роботи.",
    "interviewTip": "Більшість популярних бібліотек (наприклад, React Navigation) надають власні Jest-моки, які можна просто імпортувати у ваш 'jest.setup.js'."
  },
  "tm-06": {
    "prompt": "Які з цих варіантів є валідними «запитами» (queries) RNTL для пошуку елементів у UI?",
    "explanation": "getByText та getByTestId є найпоширенішими. queryBy... використовується, коли ви хочете перевірити, що елемент *не* існує (він повертає null замість помилки).",
    "interviewTip": "Надавайте перевагу 'getByText' або 'getByLabelText' (доступність) перед 'getByTestId', де це можливо, щоб ваш додаток був інклюзивним."
  },
  "tm-07": {
    "prompt": "Яке призначення команди 'jest.useFakeTimers()'?",
    "explanation": "Якщо у вашому додатку Mock Interview є 3-секундний зворотний відлік перед питанням, фейкові таймери дозволяють миттєво пропустити ці 3 секунди під час тесту.",
    "interviewTip": "Не забувайте викликати 'jest.runAllTimers()' або 'jest.advanceTimersByTime()' після використання цієї функції."
  },
  "tm-08": {
    "prompt": "Проаналізуйте фрагмент тесту Detox. Що він перевіряє?",
    "explanation": "Це типовий E2E-тест. Він перевіряє видимість елементів та виконує дії (натискання), щоб верифікувати логіку переходу між кількома екранами.",
    "interviewTip": "У Detox 'by.id' посилається на пропс 'testID', який ви додаєте до своїх компонентів React Native."
  },
  "tm-09": {
    "prompt": "Як протестувати компонент, який використовує хук із бібліотеки (наприклад, 'useNavigation'), без помилок?",
    "explanation": "Як і в самому додатку, хукам часто потрібен контекст. Огортання тестованого компонента в провайдер (наприклад, NavigationContainer або Redux Provider) є стандартним рішенням.",
    "interviewTip": "Ви можете створити власну функцію 'render', яка автоматично огортатиме кожен компонент у всі необхідні провайдери."
  },
  "tm-10": {
    "prompt": "Що представляє собою 'coverage' (покриття) у звіті Jest?",
    "explanation": "Покриття допомагає виявити «темні плями» у вашому коді, які ще не були перевірені жодним тестом.",
    "interviewTip": "Попередження: 100% покриття не означає відсутність багів; це лише означає, що кожен рядок коду був виконаний хоча б один раз."
  }
}
