{
  "lp-01": {
    "prompt": "Чому <FlatList> продуктивніший за <ScrollView> для довгих списків даних?",
    "explanation": "FlatList використовує «ледачий» рендеринг: він створює елементи лише тоді, коли вони мають з'явитися на екрані, і видаляє ті, що вийшли далеко за його межі, зберігаючи пам'ять.",
    "interviewTip": "Ця концепція називається «Віртуалізація» (Virtualization) або «Віконний режим» (Windowing).",
    "options": [
      "Він використовує швидшу реалізацію смуги прокрутки на C++.",
      "Він рендерить лише ті елементи, які зараз видно на екрані, і перевикористовує (recycles) представлення.",
      "Він автоматично стискає зображення всередині списку.",
      "Він працює в Shadow Thread замість JS Thread."
    ]
  },
  "lp-02": {
    "prompt": "Який пропс є обов'язковим у <FlatList>, щоб вказати, що саме рендерити для кожного елемента масиву?",
    "explanation": "Пропс renderItem приймає функцію, яка отримує об'єкт (зазвичай деструктурований як { item, index }) і повертає JSX-елемент.",
    "interviewTip": "Для високої продуктивності визначайте функцію renderItem поза компонентом або огортайте її в useCallback.",
    "options": ["renderItem", "component", "ItemTemplate", "rowRenderer"]
  },
  "lp-03": {
    "prompt": "Яке призначення пропса 'keyExtractor'?",
    "explanation": "За замовчуванням FlatList шукає властивість 'id' або 'key'. Якщо ваші дані використовують інші назви (наприклад, 'uuid'), ви повинні використати keyExtractor.",
    "interviewTip": "Завжди надавайте унікальний рядок як ключ. Уникайте використання індексу, якщо дані можуть сортуватися або фільтруватися.",
    "options": [
      "Для шифрування даних задля безпеки.",
      "Для надання унікального ID кожному елементу, щоб React міг відстежувати зміни та ефективно проводити рендеринг.",
      "Для сортування списку на основі ключа.",
      "Для зв'язку списку з базою даних."
    ]
  },
  "lp-04": {
    "prompt": "Як відрендерити заголовок (header), який прокручується разом із елементами списку?",
    "explanation": "Використання ListHeaderComponent гарантує, що заголовок залишається частиною області прокрутки, не порушуючи логіку віртуалізації.",
    "interviewTip": "Ніколи не огортайте FlatList всередину ScrollView тієї ж орієнтації; це ламає віртуалізацію і викликає попередження про продуктивність.",
    "options": [
      "Розмістити заголовок у View над FlatList.",
      "Використовувати пропс 'ListHeaderComponent'.",
      "Огорнути FlatList у ScrollView.",
      "Помістити заголовок у перший елемент масиву даних."
    ]
  },
  "lp-05": {
    "prompt": "Який компонент слід використовувати для рендерингу групованих даних (наприклад, список контактів за алфавітом)?",
    "explanation": "SectionList розроблений спеціально для даних, розділених на логічні секції, кожна з яких має власний заголовок.",
    "interviewTip": "Дані для SectionList мають бути масивом об'єктів, де кожен об'єкт має масив 'data' (наприклад, { title: 'A', data: ['Alice', 'Aaron'] }).",
    "options": [
      "GroupedList",
      "SectionList",
      "FlatList з вкладеними Map",
      "CategoryView"
    ]
  },
  "lp-06": {
    "prompt": "Що саме оптимізує пропс 'getItemLayout'?",
    "explanation": "Вказуючи точні розміри елементів заздалегідь, ви звільняєте FlatList від потреби обчислювати їх «на льоту» під час скролу, що робить прокрутку плавною.",
    "interviewTip": "Це оптимізація рівня «про» для списків із сотнями елементів, де кожен елемент має однакову фіксовану висоту.",
    "options": [
      "Він дозволяє списку пропускати вимірювання елементів, якщо вони мають фіксовану висоту/ширину.",
      "Він визначає макет Flexbox для рядка.",
      "Він автоматично розраховує розмір шрифту тексту.",
      "Він керує відступами між елементами."
    ]
  },
  "lp-07": {
    "prompt": "Проаналізуйте код. Що станеться, якщо користувач дійде до кінця списку?",
    "explanation": "onEndReachedThreshold — це значення від 0 до 1, що вказує, наскільки близько до кінця (як частка довжини списку) має бути користувач, щоб спрацювала подія.",
    "interviewTip": "Саме так реалізується «Нескінченний скрол» (Infinite Scroll) у мобільних додатках.",
    "options": [
      "Список припинить прокручуватися.",
      "loadMoreData буде викликано, коли користувач опиниться в межах 50% від кінця контенту списку.",
      "loadMoreData буде викликано лише тоді, коли користувач досягне останнього пікселя внизу.",
      "Список почнеться спочатку (зверху)."
    ]
  },
  "lp-08": {
    "prompt": "Як додати лінію-розділювач між елементами, не додаючи її в самий початок або кінець списку?",
    "explanation": "ItemSeparatorComponent рендерить компонент між кожним елементом, але виключає його для самого верху та самого низу списку.",
    "interviewTip": "Це чистіше, ніж використання margin або border, оскільки автоматично обробляє краї списку.",
    "options": [
      "Додати border до кожного елемента.",
      "Використовувати пропс 'ItemSeparatorComponent'.",
      "Додати лінію всередині функції renderItem.",
      "Використовувати стиль 'gap' на FlatList."
    ]
  },
  "lp-09": {
    "prompt": "Які з цих пропсів можуть допомогти покращити роботу дуже повільного FlatList?",
    "explanation": "Усі ці пропси налаштовують двигун віртуалізації. Наприклад, менший windowSize зменшує споживання пам'яті, але може показувати порожні місця при швидкому скролі.",
    "interviewTip": "Завжди починайте зі значень за замовчуванням. Змінюйте їх лише якщо помічаєте лаги або високе споживання пам'яті.",
    "options": [
      "initialNumToRender (скільки елементів завантажувати спочатку)",
      "windowSize (скільки сторінок елементів тримати в пам'яті)",
      "removeClippedSubviews (демонтує представлення поза екраном)",
      "maxToRenderPerBatch (обмежує кількість елементів на ітерацію рендерингу)"
    ]
  },
  "lp-10": {
    "prompt": "Для чого використовується пропс 'extraData' у FlatList?",
    "explanation": "FlatList — це PureComponent. Він перерендериться лише якщо зміниться посилання на 'data'. Якщо ваші елементи залежать від теми або вибраного ID, передайте це в extraData.",
    "interviewTip": "Якщо ваш список не оновлюється при зміні стану одного елемента, ви, ймовірно, забули вказати extraData.",
    "options": [
      "Для передачі метаданих у базу даних.",
      "Щоб повідомити FlatList про необхідність перерендерингу, коли змінюється стан *поза* масивом 'data'.",
      "Щоб додати більше елементів у кінець списку.",
      "Для стилізації стану порожнього списку."
    ]
  },
  "lp-11": {
    "prompt": "Як реалізувати функцію «Оновити тягнучи» (Pull to Refresh) у FlatList?",
    "explanation": "refreshing (boolean) показує індикатор завантаження; onRefresh (function) — це колбек, де ви завантажуєте нові дані.",
    "interviewTip": "Це забезпечує нативний досвід взаємодії, якого користувачі очікують від мобільних додатків.",
    "options": [
      "loading, onReload",
      "isFetching, onFetch",
      "refreshing, onRefresh",
      "active, onPull"
    ]
  },
  "lp-12": {
    "prompt": "Що станеться, якщо не надати унікальний ключ елементам списку?",
    "explanation": "React використовує ключі для оптимізації оновлень. Використання індексу може призвести до того, що стан «приклеїться» до неправильних елементів при зміні списку.",
    "interviewTip": "На співбесіді поясніть, що стабільні ключі запобігають дороговартісним повторним монтуванням (re-mounts).",
    "options": [
      "Додаток негайно завершиться з помилкою.",
      "React покаже попередження і використає індекс як ключ, що може призвести до помилок продуктивності.",
      "Список буде порожнім.",
      "Елементи будуть відрендерені у випадковому порядку."
    ]
  },
  "lp-13": {
    "prompt": "Який пропс дозволяє рендерити список у кілька колонок (наприклад, сітку)?",
    "explanation": "numColumns={2} автоматично розташує елементи у дві колонки. Це вимагає, щоб ваші елементи мали гнучку або відповідну фіксовану ширину.",
    "interviewTip": "Зверніть увагу, що ви не можете змінювати numColumns «на льоту»; для цього компонент має перемонтуватися.",
    "options": ["columnCount", "numColumns", "gridEnabled", "flexWrap"]
  },
  "lp-14": {
    "prompt": "Для чого використовується 'ListEmptyComponent'?",
    "explanation": "Це зручний пропс для обробки стану порожнього списку без використання зайвих тернарних операторів у вашому JSX.",
    "interviewTip": "Це робить код вашого компонента набагато чистішим.",
    "options": [
      "Для видалення всіх даних зі списку.",
      "Для рендерингу специфічного інтерфейсу (наприклад, повідомлення «Нічого не знайдено»), коли масив даних порожній.",
      "Для стилізації фону списку.",
      "Щоб повністю приховати список."
    ]
  }
}
