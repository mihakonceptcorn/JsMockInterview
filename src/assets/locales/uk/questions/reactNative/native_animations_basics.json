{
  "ab-01": {
    "prompt": "Який тип компонента потрібно використовувати, щоб зробити звичайний View анімованим за допомогою Animated API?",
    "explanation": "Стандартні компоненти не можуть обробляти анімовані значення напряму. Ви повинні використовувати спеціальні версії: Animated.View, Animated.Text, Animated.Image та Animated.ScrollView.",
    "interviewTip": "Якщо у вас є власний кастомний компонент, ви можете огорнути його за допомогою 'Animated.createAnimatedComponent(MyComponent)'.",
    "options": ["<View>", "<Animated.View>", "<Motion.View>", "<View.Animated>"]
  },
  "ab-02": {
    "prompt": "Яка основна перевага встановлення 'useNativeDriver: true' у конфігурації анімації?",
    "explanation": "Надсилаючи визначення анімації на нативну сторону один раз, нативний потік може оновлювати UI незалежно від черги подій JavaScript.",
    "interviewTip": "Пам'ятайте, що 'useNativeDriver' працює лише з властивостями, які не впливають на макет, такими як 'opacity' та 'transform'.",
    "options": [
      "Це робить код JavaScript коротшим.",
      "Це переносить виконання анімації на нативний потік інтерфейсу, запобігаючи затримкам, навіть якщо потік JS зайнятий.",
      "Це дозволяє анімації працювати у вебі.",
      "Це автоматично розраховує значення інтерполяції."
    ]
  },
  "ab-03": {
    "prompt": "Як перетворити (map) значення, що змінюється від 0 до 1, у властивість, що змінюється від 0 до 360 градусів?",
    "explanation": "Інтерполяція (interpolation) дозволяє зіставити вхідний діапазон із вихідним, включаючи такі значення, як кольори або градуси.",
    "interviewTip": "Інтерполяція — це ключова концепція Animated API для створення складних анімацій кількох властивостей на основі одного значення.",
    "options": ["transform", "map", "interpolate", "extrapolate"]
  },
  "ab-04": {
    "prompt": "Який метод використовується для створення анімації на основі пружини (spring), що імітує фізичний рух?",
    "explanation": "Animated.spring() забезпечує більш природне відчуття руху, використовуючи фізичні параметри, такі як 'friction' (тертя), 'tension' (натяг) або 'bounciness' (пружність).",
    "interviewTip": "Пружинам зазвичай надають перевагу для взаємодій з інтерфейсом (натискання кнопок, модальні вікна), оскільки вони відчуваються більш «органічними».",
    "options": [
      "Animated.timing()",
      "Animated.decay()",
      "Animated.spring()",
      "Animated.physics()"
    ]
  },
  "ab-05": {
    "prompt": "Який правильний спосіб ініціалізації анімованого значення у функціональному компоненті, щоб воно зберігалося між рендерами?",
    "explanation": "Використання useRef гарантує, що екземпляр Animated.Value створюється один раз і не скидається при повторному рендерингу компонента.",
    "interviewTip": "Ініціалізація в 'useRef' є стандартним патерном для функціональних компонентів, щоб уникнути витоків пам'яті та скидання стану.",
    "options": ["useState", "useMemo", "useRef", "useEffect"]
  },
  "ab-06": {
    "prompt": "Як запустити кілька анімацій одночасно?",
    "explanation": "Animated.parallel запускає масив анімацій синхронно.",
    "interviewTip": "Використовуйте це, коли хочете, щоб елемент одночасно плавно з'являвся (fade-in) та збільшувався (scale-up).",
    "options": [
      "Animated.sequence([])",
      "Animated.parallel([])",
      "Animated.stagger(0, [])",
      "Animated.group([])"
    ]
  },
  "ab-07": {
    "prompt": "Що робить 'Animated.sequence([])'?",
    "explanation": "Sequence гарантує, що наступна анімація в масиві не почнеться, поки попередня не завершиться успішно.",
    "interviewTip": "Це ідеально підходить для багатоетапних анімацій «онбордингу» або складних переходів інтерфейсу.",
    "options": [
      "Запускає анімації одну за одною, чекаючи завершення кожної.",
      "Запускає всі анімації одночасно.",
      "Повторює анімацію циклічно.",
      "Вибирає випадковий порядок анімацій."
    ]
  },
  "ab-08": {
    "prompt": "Як запустити анімацію після того, як вона була визначена?",
    "explanation": "Анімації в React Native є декларативними. Вони не почнуть виконуватися, поки ви явно не викличете метод '.start()'.",
    "interviewTip": "Ви можете передати колбек у .start(({ finished }) => { ... }), щоб виконати логіку після завершення анімації.",
    "options": ["play", "begin", "start", "run"]
  },
  "ab-09": {
    "prompt": "Яку з цих властивостей стилю НЕ МОЖНА використовувати з 'useNativeDriver: true'?",
    "explanation": "Нативний драйвер переважно підтримує 'transform' та 'opacity'. Властивості макета (width, height, flex) та деякі властивості кольору зазвичай потребують обробки в JS-потоці.",
    "interviewTip": "Якщо вам потрібно плавно анімувати властивості макета, зверніть увагу на LayoutAnimation API або бібліотеку 'Reanimated'.",
    "options": ["opacity", "scale", "backgroundColor", "translateX"]
  },
  "ab-10": {
    "prompt": "Для чого насамперед використовується 'Animated.event'?",
    "explanation": "Animated.event дозволяє створювати надзвичайно плавну взаємодію, наприклад, заголовок, що зменшується при скролі, пов'язуючи 'contentOffset' ScrollView з анімованим значенням.",
    "interviewTip": "Це найефективніший спосіб пов'язати жести користувача зі змінами в інтерфейсі.",
    "options": [
      "Щоб запустити функцію після завершення анімації.",
      "Щоб прив'язати нативні події (як-от скрол або панорамування) безпосередньо до анімованого значення в обхід потоку JS.",
      "Щоб відстежувати зміни орієнтації пристрою.",
      "Щоб створювати кастомні події дотику."
    ]
  },
  "ab-11": {
    "prompt": "Як створити анімацію, що повторюється нескінченно?",
    "explanation": "Animated.loop() бере анімацію та запускає її знову кожного разу, коли вона доходить до кінця.",
    "interviewTip": "Це можна використовувати для ефектів «пульсації» кнопок або індикаторів завантаження.",
    "options": [
      "Animated.repeat()",
      "Animated.loop()",
      "Animated.forever()",
      "Викликати .start() всередині колбеку завершення."
    ]
  },
  "ab-12": {
    "prompt": "Для чого використовується 'LayoutAnimation' API?",
    "explanation": "LayoutAnimation — це API типу «запустив і забув». Ви викликаєте його перед оновленням стану, і нативна сторона плавно обробляє всі зміни макета.",
    "interviewTip": "Він дуже потужний, але пропонує менше можливостей для тонкого налаштування, ніж Animated API.",
    "options": [
      "Для анімації окремих компонентів, наприклад, появи (fade-in).",
      "Для автоматичної анімації будь-якої зміни макета (flex, ширина, висота) у наступному циклі рендерингу.",
      "Для обробки складних 3D-трансформацій.",
      "Для керування переходами z-index."
    ]
  },
  "ab-13": {
    "prompt": "Проаналізуйте код. Що станеться з об'єктом через 2 секунди?",
    "explanation": "toValue: 0 для властивості opacity призведе до того, що елемент стане повністю прозорим.",
    "interviewTip": "Завжди перевіряйте, чи початкове значення відповідає задуму (наприклад, new Animated.Value(1) для ефекту зникнення).",
    "options": [
      "Він стане повністю непрозорим.",
      "Він зникне (fade out).",
      "Він переміститься на 2000 пікселів вліво.",
      "Блок змінить свій колір на чорний."
    ]
  },
  "ab-14": {
    "prompt": "Що відбувається з анімацією, якщо компонент демонтується, поки вона ще триває?",
    "explanation": "Хоча React Native зазвичай стабільний, незавершені анімації можуть призводити до попереджень про оновлення стану демонтованого компонента або проблем із пам'яттю.",
    "interviewTip": "В очищенні useEffect варто зупиняти активні анімації, якщо вони прив'язані до локального стану.",
    "options": [
      "Вона продовжується у фоновому режимі.",
      "React Native автоматично очищує ресурси, але рекомендується викликати .stop() вручну.",
      "Додаток завершиться з помилкою.",
      "Телефон завібрує."
    ]
  }
}
