{
  "ab-01": {
    "prompt": "Який тип компонента потрібно використовувати, щоб зробити звичайний View анімованим за допомогою Animated API?",
    "explanation": "Стандартні компоненти не можуть обробляти анімовані значення напряму. Ви повинні використовувати спеціальні версії: Animated.View, Animated.Text, Animated.Image та Animated.ScrollView.",
    "interviewTip": "Якщо у вас є власний кастомний компонент, ви можете огорнути його за допомогою 'Animated.createAnimatedComponent(MyComponent)'."
  },
  "ab-02": {
    "prompt": "Яка основна перевага встановлення 'useNativeDriver: true' у конфігурації анімації?",
    "explanation": "Надсилаючи визначення анімації на нативну сторону один раз, нативний потік може оновлювати UI незалежно від черги подій JavaScript.",
    "interviewTip": "Пам'ятайте, що 'useNativeDriver' працює лише з властивостями, які не впливають на макет, такими як 'opacity' та 'transform'."
  },
  "ab-03": {
    "prompt": "Як перетворити (map) значення, що змінюється від 0 до 1, у властивість, що змінюється від 0 до 360 градусів?",
    "explanation": "Інтерполяція (interpolation) дозволяє зіставити вхідний діапазон із вихідним, включаючи такі значення, як кольори або градуси.",
    "interviewTip": "Інтерполяція — це ключова концепція Animated API для створення складних анімацій кількох властивостей на основі одного значення."
  },
  "ab-04": {
    "prompt": "Який метод використовується для створення анімації на основі пружини (spring), що імітує фізичний рух?",
    "explanation": "Animated.spring() забезпечує більш природне відчуття руху, використовуючи фізичні параметри, такі як 'friction' (тертя), 'tension' (натяг) або 'bounciness' (пружність).",
    "interviewTip": "Пружинам зазвичай надають перевагу для взаємодій з інтерфейсом (натискання кнопок, модальні вікна), оскільки вони відчуваються більш «органічними»."
  },
  "ab-05": {
    "prompt": "Який правильний спосіб ініціалізації анімованого значення у функціональному компоненті, щоб воно зберігалося між рендерами?",
    "explanation": "Використання useRef гарантує, що екземпляр Animated.Value створюється один раз і не скидається при повторному рендерингу компонента.",
    "interviewTip": "Ініціалізація в 'useRef' є стандартним патерном для функціональних компонентів, щоб уникнути витоків пам'яті та скидання стану."
  },
  "ab-06": {
    "prompt": "Як запустити кілька анімацій одночасно?",
    "explanation": "Animated.parallel запускає масив анімацій синхронно.",
    "interviewTip": "Використовуйте це, коли хочете, щоб елемент одночасно плавно з'являвся (fade-in) та збільшувався (scale-up)."
  },
  "ab-07": {
    "prompt": "Що робить 'Animated.sequence([])'?",
    "explanation": "Sequence гарантує, що наступна анімація в масиві не почнеться, поки попередня не завершиться успішно.",
    "interviewTip": "Це ідеально підходить для багатоетапних анімацій «онбордингу» або складних переходів інтерфейсу."
  },
  "ab-08": {
    "prompt": "Як запустити анімацію після того, як вона була визначена?",
    "explanation": "Анімації в React Native є декларативними. Вони не почнуть виконуватися, поки ви явно не викличете метод '.start()'.",
    "interviewTip": "Ви можете передати колбек у .start(({ finished }) => { ... }), щоб виконати логіку після завершення анімації."
  },
  "ab-09": {
    "prompt": "Яку з цих властивостей стилю НЕ МОЖНА використовувати з 'useNativeDriver: true'?",
    "explanation": "Нативний драйвер переважно підтримує 'transform' та 'opacity'. Властивості макета (width, height, flex) та деякі властивості кольору зазвичай потребують обробки в JS-потоці.",
    "interviewTip": "Якщо вам потрібно плавно анімувати властивості макета, зверніть увагу на LayoutAnimation API або бібліотеку 'Reanimated'."
  },
  "ab-10": {
    "prompt": "Для чого насамперед використовується 'Animated.event'?",
    "explanation": "Animated.event дозволяє створювати надзвичайно плавну взаємодію, наприклад, заголовок, що зменшується при скролі, пов'язуючи 'contentOffset' ScrollView з анімованим значенням.",
    "interviewTip": "Це найефективніший спосіб пов'язати жести користувача зі змінами в інтерфейсі."
  },
  "ab-11": {
    "prompt": "Як створити анімацію, що повторюється нескінченно?",
    "explanation": "Animated.loop() бере анімацію та запускає її знову кожного разу, коли вона доходить до кінця.",
    "interviewTip": "Це можна використовувати для ефектів «пульсації» кнопок або індикаторів завантаження."
  },
  "ab-12": {
    "prompt": "Для чого використовується 'LayoutAnimation' API?",
    "explanation": "LayoutAnimation — це API типу «запустив і забув». Ви викликаєте його перед оновленням стану, і нативна сторона плавно обробляє всі зміни макета.",
    "interviewTip": "Він дуже потужний, але пропонує менше можливостей для тонкого налаштування, ніж Animated API."
  },
  "ab-13": {
    "prompt": "Проаналізуйте код. Що станеться з об'єктом через 2 секунди?",
    "explanation": "toValue: 0 для властивості opacity призведе до того, що елемент стане повністю прозорим.",
    "interviewTip": "Завжди перевіряйте, чи початкове значення відповідає задуму (наприклад, new Animated.Value(1) для ефекту зникнення)."
  },
  "ab-14": {
    "prompt": "Що відбувається з анімацією, якщо компонент демонтується, поки вона ще триває?",
    "explanation": "Хоча React Native зазвичай стабільний, незавершені анімації можуть призводити до попереджень про оновлення стану демонтованого компонента або проблем із пам'яттю.",
    "interviewTip": "В очищенні useEffect варто зупиняти активні анімації, якщо вони прив'язані до локального стану."
  }
}
