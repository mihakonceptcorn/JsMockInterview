{
  "rn-flex-01": {
    "prompt": "Який 'flexDirection' встановлено за замовчуванням для View у React Native?",
    "explanation": "У вебі значенням за замовчуванням є 'row'. У React Native це 'column', що краще відповідає вертикальній природі мобільних пристроїв.",
    "interviewTip": "Завжди перевіряйте напрямок перед тим, як виправляти вирівнювання, оскільки 'justifyContent' та 'alignItems' змінюють свої ролі залежно від цієї властивості.",
    "options": ["row", "row-reverse", "column", "column-reverse"]
  },
  "rn-flex-02": {
    "prompt": "Яка властивість вирівнює дочірні елементи вздовж головної осі (Main Axis)?",
    "explanation": "justifyContent визначає, як дочірні елементи розподіляються вздовж головної осі (яка задається через flexDirection).",
    "interviewTip": "Поширені значення: 'center', 'space-between' та 'space-around'.",
    "options": ["alignContent", "justifyContent", "alignItems", "selfAlign"]
  },
  "rn-flex-03": {
    "prompt": "Яким буде розмір цих двох блоків?",
    "explanation": "Значення flex є пропорційними. Загальний flex: 1 + 3 = 4. Червоний блок займе 1/4 (25%), а синій — 3/4 (75%).",
    "interviewTip": "У React Native 'flex: 1' для одного дочірнього елемента вказує йому заповнити весь доступний простір у батьківському компоненті.",
    "options": [
      "Червоний займає 25% висоти, синій — 75%.",
      "Червоний займає 50% висоти, синій — 50%.",
      "Червоний займає 1/3 висоти, синій — 2/3.",
      "Обидва матимуть нульову висоту, оскільки ширина не вказана."
    ]
  },
  "rn-flex-04": {
    "prompt": "Яка властивість дозволяє окремому дочірньому елементу відхилитися від 'alignItems', встановленого батьком?",
    "explanation": "alignSelf дозволяє перевизначити вирівнювання батька для конкретного елемента.",
    "interviewTip": "Це дуже корисно для центрування одного конкретного елемента в списку, де всі інші елементи розтягнуті на всю ширину.",
    "options": ["alignItem", "justifySelf", "alignSelf", "flexSelf"]
  },
  "rn-flex-05": {
    "prompt": "Яке значення за замовчуванням для 'alignItems' у React Native?",
    "explanation": "За замовчуванням дочірні елементи розтягуються ('stretch'), щоб заповнити вторинну вісь батька, якщо не вказано конкретну ширину чи висоту.",
    "interviewTip": "Якщо ваш дочірній компонент «зникає», можливо, ви встановили flexDirection: 'row', а стандартний 'stretch' намагається знайти висоту, якої немає.",
    "options": ["center", "flex-start", "stretch", "baseline"]
  },
  "rn-flex-06": {
    "prompt": "Як відцентрувати дочірній елемент і по горизонталі, і по вертикалі всередині звичайного View?",
    "explanation": "Використання 'center' для обох властивостей — justifyContent (головна вісь) та alignItems (вторинна вісь) — ідеально центрує контент.",
    "interviewTip": "Переконайтеся, що батьківський компонент має 'flex: 1' або фіксований розмір, інакше всередині нього не буде простору для центрування.",
    "options": [
      "flexDirection, alignContent",
      "justifyContent, alignItems",
      "alignSelf, justifyContent",
      "textAlign, verticalAlign"
    ]
  },
  "rn-flex-07": {
    "prompt": "Яким є результат використання 'flex: -1' у React Native?",
    "explanation": "Від'ємне значення flex дозволяє компоненту стискатися, коли контент виходить за межі батька, але він не займатиме зайвого простору в інших випадках.",
    "interviewTip": "Це використовується рідко, але корисно для обробки динамічного тексту у вузьких заголовках (headers).",
    "options": [
      "Компонент стає прихованим.",
      "Компонент стискається до мінімального розміру при переповненні, але не розширюється.",
      "Працює так само як 'flex: 1'.",
      "Викликає помилку."
    ]
  },
  "rn-flex-08": {
    "prompt": "Яку властивість слід використовувати для додавання простору між елементами у Flex-контейнері без використання марджинів?",
    "explanation": "Сучасні версії React Native підтримують властивість 'gap' (а також rowGap та columnGap), яка додає простір саме між елементами.",
    "interviewTip": "Використання 'gap' набагато чистіше, ніж застосування margin до кожного елемента з подальшим його видаленням у останнього.",
    "options": ["spacing", "item-padding", "gap", "grid-gap"]
  },
  "rn-flex-09": {
    "prompt": "Проаналізуйте цей код. Де буде розташований 'Box'?",
    "explanation": "flex-end для напрямку row ставить його праворуч; flex-end для вторинної осі ставить його внизу.",
    "interviewTip": "Завжди візуалізуйте вісь у формі літери 'L': Головна вісь (X) та Вторинна вісь (Y) для напрямку 'row'.",
    "options": [
      "Верхній правий кут",
      "Верхній лівий кут",
      "Нижній правий кут",
      "Нижній лівий кут"
    ]
  },
  "rn-flex-10": {
    "prompt": "Чи підтримує React Native 'z-index' для елементів, що накладаються один на одного?",
    "explanation": "React Native підтримує zIndex. Проте, якщо кілька елементів мають однаковий zIndex, той, що визначений пізніше в JSX, буде зверху.",
    "interviewTip": "На Android іноді потрібна властивість 'elevation' разом із zIndex для вирішення проблем із накладанням тіней.",
    "options": [
      "Ні, потрібно змінювати черговість компонентів у JSX.",
      "Так, працює точно так само, як у вебі.",
      "Лише на Android.",
      "Лише на iOS."
    ]
  },
  "rn-flex-11": {
    "prompt": "Які з наведених одиниць вимірювання є валідними для 'width' та 'height' у стилях React Native?",
    "explanation": "React Native переважно використовує числа без одиниць (логічні пікселі) та відсоткові рядки. rem/em/vh/vw нативно не підтримуються.",
    "interviewTip": "Щоб отримати одиниці на основі екрана (як vw/vh), використовуйте API 'Dimensions' або хук 'useWindowDimensions'.",
    "options": [
      "Числа (що представляють логічні пікселі)",
      "Відсотки (наприклад, '50%')",
      "Одиниці rem або em",
      "Одиниці vh або vw"
    ]
  },
  "rn-flex-12": {
    "prompt": "Для чого використовується 'flexBasis'?",
    "explanation": "flexBasis визначає початковий розмір елемента перед тим, як залишок простору буде розподілено через flexGrow або flexShrink.",
    "interviewTip": "Якщо flexDirection: 'column', flexBasis діє як 'height'. Якщо 'row' — як 'width'.",
    "options": [
      "Для встановлення кінцевого розміру компонента після розширення.",
      "Для встановлення початкового розміру компонента до розподілу додаткового простору.",
      "Для визначення кольору фону flex-контейнера.",
      "Для встановлення мінімальної ширини."
    ]
  },
  "rn-flex-13": {
    "prompt": "Як змусити View переносити дочірні елементи на кілька рядків, якщо вони перевищують ширину контейнера?",
    "explanation": "За замовчуванням flex-контейнери мають значення 'nowrap'. Встановлення 'flexWrap: wrap' дозволяє елементам переходити на наступний рядок.",
    "interviewTip": "Це необхідно для створення макетів типу «хмари тегів» або сіток фотографій.",
    "options": [
      "flexDirection: 'multiline'",
      "flexWrap: 'wrap'",
      "overflow: 'scroll'",
      "display: 'grid'"
    ]
  },
  "rn-flex-14": {
    "prompt": "За що відповідає 'Shadow Thread'?",
    "explanation": "Shadow Thread — це місце, де React Native обчислює математичну розкладку ваших компонентів за допомогою Yoga перед відправкою її в UI Thread.",
    "interviewTip": "Знання цього допомагає зрозуміти, що зміни стилів у JS проходять певний шлях через потоки, перш ніж з'явитися на екрані.",
    "options": [
      "Обчислення тіней та меж (borders).",
      "Запуск рушія Yoga для обчислення макета інтерфейсу.",
      "Захист додатка від злому.",
      "Обробка фонових викликів API."
    ]
  },
  "rn-flex-15": {
    "prompt": "Як отримати ширину фізичного екрана в React Native?",
    "explanation": "API Dimensions (або хук useWindowDimensions) надає ширину та висоту поточного вікна/екрана.",
    "interviewTip": "Надавайте перевагу 'useWindowDimensions', оскільки він автоматично оновлюється при повороті екрана або зміні розміру вікна (на планшетах чи у вебі).",
    "options": ["Screen", "Dimensions", "Device", "Layout"]
  },
  "rn-flex-16": {
    "prompt": "Що робить властивість 'aspectRatio' в об'єкті Style?",
    "explanation": "Якщо встановити 'aspectRatio: 1', компонент завжди буде квадратом, навіть якщо визначено лише ширину.",
    "interviewTip": "Це надзвичайно корисно для зображений та контейнерів відео, коли ви хочете, щоб вони були адаптивними, але зберігали пропорції 16:9 або 4:3.",
    "options": [
      "Встановлює прозорість зображення.",
      "Змушує компонент зберігати певне співвідношення ширини до висоти.",
      "Використовується лише для відтворення відео.",
      "Закруглює кути View."
    ]
  },
  "rn-flex-17": {
    "prompt": "Визначте помилку в цьому об'єкті Style:",
    "explanation": "React Native не реалізує повну специфікацію CSS. Властивостей на кшталт float, clear та display: block/inline не існує.",
    "interviewTip": "Якщо вам потрібна розкладка «пліч-о-пліч», завжди використовуйте 'flexDirection: row'.",
    "options": [
      "flex не може дорівнювати 1.",
      "React Native не підтримує 'float' або 'display: block' (все є flex за замовчуванням).",
      "StyleSheet.create застарів.",
      "Помилок немає."
    ]
  }
}
