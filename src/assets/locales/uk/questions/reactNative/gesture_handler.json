{
  "gh-01": {
    "prompt": "Чому 'React Native Gesture Handler' (RNGH) кращий за вбудований 'PanResponder'?",
    "explanation": "RNGH взаємодіє безпосередньо з нативною системою розпізнавання жестів платформи, що означає, що події дотику не повинні проходити через JS-потік для обробки.",
    "interviewTip": "Завжди згадуйте про 'детермінізм' та 'чуйність' (responsiveness) при порівнянні RNGH з PanResponder.",
    "options": [
      "Він споживає менше заряду батареї.",
      "Він працює в нативному потоці, уникаючи вузького місця «мосту» (bridge) для плавних жестів при 60fps.",
      "Він написаний чистою мовою JavaScript, і його легше відлагоджувати.",
      "Він працює лише з Expo."
    ]
  },
  "gh-02": {
    "prompt": "Який компонент повинен огортати весь ваш додаток для роботи Gesture Handler?",
    "explanation": "Щоб жести захоплювалися правильно, особливо на Android, ви повинні огорнути точку входу (зазвичай App.js) у <GestureHandlerRootView>.",
    "interviewTip": "Відсутність цієї обгортки — найпоширеніша причина того, що жести «мовчазно» не спрацьовують.",
    "options": [
      "<GestureContainer>",
      "<GestureHandlerRootView>",
      "<TouchProvider>",
      "<NativeGestureWrapper>"
    ]
  },
  "gh-03": {
    "prompt": "Що зробить цей код, коли користувач проведе пальцем по екрану?",
    "explanation": "У жесті Pan (панорамування) 'translationX' та 'translationY' представляють відстань, на яку перемістився палець з моменту початку жесту.",
    "interviewTip": "Порівнюйте 'translation' (рух відносно початку) з 'absolutePosition' (координата відносно батьківського елемента).",
    "options": [
      "Він відстежує горизонтальну відстань, пройдену від початкової точки.",
      "Він відстежує загальну кількість пальців на екрані.",
      "Він логує абсолютну координату X відносно екрана.",
      "Він працює лише за умови подвійного натискання (double-tap)."
    ]
  },
  "gh-04": {
    "prompt": "Який обробник жестів спеціально розроблений для поодинокого швидкого натискання?",
    "explanation": "Gesture.Tap() використовується для дискретних подій дотику. Ви можете налаштувати його так, щоб він вимагав кілька натискань (наприклад, подвійний тап для лайка).",
    "interviewTip": "Tap кращий за Pressable, коли вам потрібно координувати його з іншими жестами, як-от Pinch (щипок) або Pan.",
    "options": [
      "Gesture.LongPress()",
      "Gesture.Tap()",
      "Gesture.Fling()",
      "Gesture.Click()"
    ]
  },
  "gh-05": {
    "prompt": "Як дозволити двом жестам працювати одночасно (наприклад, масштабування щипком та обертання)?",
    "explanation": "Gesture.Simultaneous() дозволяє всім зазначеним жестам залишатися активними разом.",
    "interviewTip": "Це важливо для складних інтерфейсів (наприклад, фоторедакторів), де користувачі очікують свободи мультитач-керування.",
    "options": [
      "Наведений вище код є правильним.",
      "Використовувати Gesture.Parallel(pinch, rotate).",
      "Використовувати Gesture.Exclusive(pinch, rotate).",
      "Жести не можуть працювати одночасно."
    ]
  },
  "gh-06": {
    "prompt": "Яке призначення 'Gesture.Exclusive'?",
    "explanation": "Exclusive надає пріоритет першому жесту. Якщо виявлено подвійне натискання, він запобігає спрацьовуванню одиночного натискання.",
    "interviewTip": "Саме так вирішуються конфлікти між зонами дотику, що накладаються одна на одну.",
    "options": [
      "Щоб жест працював лише на iOS.",
      "Щоб встановити пріоритет, де лише один жест може «виграти» (наприклад, пріоритет подвійного тапу над одиночним).",
      "Щоб запобігти прокручуванню батьківського ScrollView.",
      "Щоб вимкнути всі інші кнопки на екрані."
    ]
  },
  "gh-07": {
    "prompt": "Який колбек події запускається, коли користувач піднімає палець з екрана?",
    "explanation": "onFinalize запускається незалежно від того, чи завершився жест успішно, чи був скасований. onEnd запускається лише за успішного завершення.",
    "interviewTip": "Використовуйте onFinalize для «скидання» стану UI, щоб він не застряг, якщо жест був перерваний (наприклад, вхідним дзвінком).",
    "options": ["onBegin", "onStart", "onEnd", "onFinalize"]
  },
  "gh-08": {
    "prompt": "Які з цих жестів є вбудованими типами в RNGH?",
    "explanation": "Pinch (щипок), Rotation (обертання) та Fling (швидке гортання) — це жести дотику. 'Shake' (струшування) — це подія руху пристрою, яку RNGH не обробляє.",
    "interviewTip": "Згадайте 'Fling' як оптимізований спосіб реалізації взаємодії 'Swipe to delete' (проведіть, щоб видалити).",
    "options": [
      "Pinch (масштабування двома пальцями)",
      "Rotation (обертання двома пальцями)",
      "Fling (швидкий свайп у певному напрямку)",
      "Shake (фізичне струшування пристрою)"
    ]
  },
  "gh-09": {
    "prompt": "Що робить пропс 'simultaneousHandlers' у старій версії API (legacy)?",
    "explanation": "Без нього ScrollView «вкрав» би подію дотику, як тільки помітив би рух. simultaneousHandlers дозволяє обом компонентам співпрацювати.",
    "interviewTip": "Це критично важливо для бокових панелей (drawers) або нижніх листів (bottom sheets), що містять контент, який можна прокручувати.",
    "options": [
      "Він прискорює JS-потік.",
      "Він дозволяє компоненту розпізнавати жест, поки певний батьківський елемент (наприклад, ScrollView) також активний.",
      "Він дозволяє двом різним користувачам торкатися екрана.",
      "Він конвертує дотики в кліки миші."
    ]
  },
  "gh-10": {
    "prompt": "У новому API 'Gesture' (v2), як прив'язати жест до конкретного View?",
    "explanation": "GestureDetector — це компонент-обгортка, який поєднує визначення жесту з конкретним елементом інтерфейсу.",
    "interviewTip": "Пам'ятайте, що GestureDetector може мати лише ОДНОГО дочірнього елемента.",
    "options": [
      "Наведений вище код є правильним.",
      "Шляхом передачі його в пропс 'onGesture' компонента View.",
      "Використовуючи хук 'useGesture'.",
      "Шляхом обгортання View у <PanHandler>."
    ]
  }
}
