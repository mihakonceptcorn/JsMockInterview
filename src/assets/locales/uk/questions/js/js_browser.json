{
  "js-browser-01": {
    "prompt": "Яка основна відповідальність браузера?",
    "explanation": "Браузер рендерить інтерфейс (UI) та запускає движок JavaScript.",
    "interviewTip": "Важливо розуміти конвеєр рендерингу (rendering pipeline).",
    "options": [
      "Рендеринг UI та виконання JS",
      "Компіляція JavaScript",
      "Зберігання баз даних",
      "Управління серверами"
    ]
  },
  "js-browser-02": {
    "prompt": "Що відбувається першим при завантаженні вебсторінки?",
    "explanation": "HTML парситься (аналізується) і перетворюється на DOM.",
    "interviewTip": "Це частина критичного шляху рендерингу (Critical Render Path).",
    "options": [
      "Парсинг HTML",
      "Парсинг CSS",
      "Виконання JS",
      "Малювання (Painting)"
    ]
  },
  "js-browser-03": {
    "prompt": "Що таке DOM?",
    "explanation": "DOM (Document Object Model) — це деревоподібна структура вузлів документа.",
    "interviewTip": "JS взаємодіє зі сторінкою саме через маніпуляції з DOM.",
    "options": [
      "Деревоподібне представлення HTML",
      "Середовище виконання JS",
      "Рушій CSS",
      "Кеш браузера"
    ]
  },
  "js-browser-04": {
    "prompt": "Що таке CSSOM?",
    "explanation": "CSSOM створюється на основі стилів CSS аналогічно до DOM.",
    "interviewTip": "DOM + CSSOM = Render Tree (Дерево рендерингу).",
    "options": [
      "Проаналізоване дерево CSS",
      "Файл CSS",
      "Стилі DOM",
      "Тема браузера"
    ]
  },
  "js-browser-05": {
    "prompt": "Що блокує парсинг HTML?",
    "explanation": "Скрипти, що завантажуються синхронно, зупиняють процес парсингу.",
    "interviewTip": "Використовуйте атрибути defer або async для оптимізації.",
    "options": ["Синхронний JavaScript", "Зображення", "Шрифти", "Мета-теги"]
  },
  "js-browser-06": {
    "prompt": "Яка різниця між async та defer?",
    "explanation": "Defer зберігає черговість виконання скриптів, async — ні.",
    "interviewTip": "Класичне питання на співбесіді.",
    "options": [
      "Async виконується якнайшвидше, defer — після DOM",
      "Вони однакові",
      "Defer блокує парсинг",
      "Async чекає на CSS"
    ]
  },
  "js-browser-07": {
    "prompt": "Що таке reflow (перекомпонування)?",
    "explanation": "Reflow — це процес перерахунку геометрії та положення елементів.",
    "interviewTip": "Це дуже ресурсомістка операція.",
    "options": [
      "Перерахунок макета (Layout)",
      "Перемальовування кольорів",
      "Виконання JS",
      "Збирання сміття (Garbage collection)"
    ]
  },
  "js-browser-08": {
    "prompt": "Що викликає repaint (перемальовування)?",
    "explanation": "Зміни, що впливають лише на вигляд (колір, видимість), але не на розміри.",
    "interviewTip": "Ця операція «дешевша» за reflow.",
    "options": [
      "Тільки візуальні зміни",
      "Зміни макета (Layout)",
      "Виконання JS",
      "Мережеві запити"
    ]
  },
  "js-browser-09": {
    "prompt": "Що таке Render Tree?",
    "explanation": "Це структура, що використовується для розрахунку макета та малювання.",
    "interviewTip": "Невидимі вузли (наприклад, display: none) не входять до нього.",
    "options": ["DOM + CSSOM", "Тільки DOM", "Тільки CSSOM", "Купа JS (heap)"]
  },
  "js-browser-10": {
    "prompt": "Що обробляє Event Loop у браузері?",
    "explanation": "Він керує черговістю виконання завдань (tasks).",
    "interviewTip": "Пам'ятайте про різницю між макро- та мікрозавданнями.",
    "options": [
      "Асинхронні колбеки",
      "Тільки рендеринг",
      "Збирання сміття",
      "Робота з мережею"
    ]
  },
  "js-browser-11": {
    "prompt": "Яке завдання має вищий пріоритет?",
    "explanation": "Проміси (мікрозавдання) обробляються швидше за таймери.",
    "interviewTip": "Важливо для відлагодження асинхронних багів.",
    "options": [
      "Мікрозавдання (Microtask)",
      "Макрозавдання (Macrotask)",
      "setTimeout",
      "requestIdleCallback"
    ]
  },
  "js-browser-12": {
    "prompt": "Що таке Same-Origin Policy (SOP)?",
    "explanation": "Політика, що обмежує доступ одного сайту до даних іншого.",
    "interviewTip": "CORS існує саме для того, щоб безпечно обходити це обмеження.",
    "options": [
      "Обмеження безпеки",
      "Правило кешування",
      "Правило рендерингу",
      "Оптимізація мережі"
    ]
  },
  "js-browser-13": {
    "prompt": "Що таке CORS?",
    "explanation": "Механізм, що дозволяє браузеру робити запити до іншого домену.",
    "interviewTip": "Налаштовується на стороні сервера.",
    "options": [
      "Спільне використання ресурсів різних джерел",
      "Система запитів клієнт-джерело",
      "Система відповідей орієнтована на кеш",
      "Стиль рендерингу крос-об'єктів"
    ]
  },
  "js-browser-14": {
    "prompt": "Яке сховище (storage) є синхронним?",
    "explanation": "LocalStorage та SessionStorage блокують основний потік.",
    "interviewTip": "Уникайте запису великих обсягів даних у них.",
    "options": ["localStorage", "IndexedDB", "Cache API", "Асинхронні Cookies"]
  },
  "js-browser-15": {
    "prompt": "Яке сховище краще для великих обсягів даних?",
    "explanation": "IndexedDB є асинхронним і має велику місткість.",
    "interviewTip": "Активно використовується в PWA.",
    "options": ["IndexedDB", "localStorage", "sessionStorage", "Cookies"]
  },
  "js-browser-16": {
    "prompt": "Що таке Service Worker?",
    "explanation": "Скрипт, що працює у фоні та може перехоплювати мережеві запити.",
    "interviewTip": "Основа для підтримки офлайн-режиму.",
    "options": [
      "Фоновий скрипт",
      "Фреймворк JS",
      "Потік браузера",
      "Рушій рендерингу"
    ]
  },
  "js-browser-17": {
    "prompt": "Що забезпечує роботу застосунку без інтернету?",
    "explanation": "Це ключова функція Service Workers та Cache API.",
    "interviewTip": "Можуть запитати про стратегії кешування.",
    "options": [
      "Service Worker + Cache API",
      "localStorage",
      "Cookies",
      "Тільки IndexedDB"
    ]
  },
  "js-browser-18": {
    "prompt": "Яка перевага HTTP/2?",
    "explanation": "Дозволяє передавати кілька потоків даних через одне з'єднання.",
    "interviewTip": "Значно покращує швидкість завантаження ресурсів.",
    "options": [
      "Мультиплексування",
      "Більше заголовків",
      "Більше TCP з'єднань",
      "Повільніший парсинг"
    ]
  },
  "js-browser-19": {
    "prompt": "Чому важливо мінімізувати критичний CSS?",
    "explanation": "Це прискорює перше відмальовування сторінки.",
    "interviewTip": "Критичний CSS часто вбудовують прямо в HTML (inline).",
    "options": [
      "Швидше перше малювання",
      "Краще SEO",
      "Менше пам'яті",
      "Краще кешування"
    ]
  },
  "js-browser-20": {
    "prompt": "Що таке First Contentful Paint (FCP)?",
    "explanation": "Метрика часу, коли користувач бачить перший контент на екрані.",
    "interviewTip": "Це частина Core Web Vitals.",
    "options": [
      "Перший видимий контент",
      "Сторінка повністю завантажена",
      "JS виконано",
      "DOM готовий"
    ]
  },
  "js-browser-21": {
    "prompt": "Що таке зсув макета (Layout Shift)?",
    "explanation": "Неочікуваний рух елементів, що вимірюється метрикою CLS.",
    "interviewTip": "Уникайте стрибків контенту при динамічному завантаженні.",
    "options": [
      "Неочікуваний рух інтерфейсу",
      "Повільний рендеринг",
      "Зламаний CSS",
      "Асинхронне завантаження"
    ]
  },
  "js-browser-22": {
    "prompt": "Який API працює поза основним потоком?",
    "explanation": "Web Workers дозволяють реальну багатопотоковість у браузері.",
    "interviewTip": "Вони не мають прямого доступу до DOM.",
    "options": [
      "Web Workers",
      "Promises",
      "setTimeout",
      "requestAnimationFrame"
    ]
  },
  "js-browser-23": {
    "prompt": "Що таке купа (JS Heap)?",
    "explanation": "Область пам'яті для динамічного розміщення об'єктів.",
    "interviewTip": "Саме тут зазвичай виникають витоки пам'яті (memory leaks).",
    "options": [
      "Пам'ять для об'єктів",
      "Стек викликів (Call stack)",
      "Черга завдань",
      "Дерево DOM"
    ]
  },
  "js-browser-24": {
    "prompt": "Що викликає примусовий синхронний макет (Forced Synchronous Layout)?",
    "explanation": "Звернення до геометричних властивостей (наприклад, offsetHeight) одразу після зміни стилів.",
    "interviewTip": "Уникайте « layout thrashing» (чергування читання та запису геометрії).",
    "options": [
      "Читання макета одразу після запису",
      "Асинхронний JS",
      "Promises",
      "Слухачі подій"
    ]
  },
  "js-browser-25": {
    "prompt": "Який найкращий спосіб оптимізації рендерингу?",
    "explanation": "Починати з профілювання (Profiling) у DevTools.",
    "interviewTip": "Ніколи не робіть припущень без вимірювань.",
    "options": [
      "Вимірювання за допомогою DevTools",
      "Переписування на WebAssembly",
      "Уникнення JS",
      "Видалення CSS"
    ]
  }
}
