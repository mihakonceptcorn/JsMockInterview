{
  "js-fn-01": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "У JavaScript функції є об'єктами першого класу, але оператор `typeof` повертає `function`.",
    "interviewTip": "Зауважте, що функції — це об'єкти, які можна викликати завдяки внутрішньому методу [[Call]]."
  },
  "js-fn-02": {
    "prompt": "Яким буде результат?",
    "explanation": "Оголошення функцій (function declarations) піднімаються (hoisting) разом із їхнім тілом.",
    "interviewTip": "Порівняйте це з функціональними виразами (function expressions)."
  },
  "js-fn-03": {
    "prompt": "Що станеться?",
    "explanation": "Змінна `bar` існує, але на момент виклику вона має значення undefined.",
    "interviewTip": "Функціональні вирази не піднімаються так, як оголошення функцій."
  },
  "js-fn-04": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Круглі дужки дозволяють стрілковій функції неявно повертати об'єкт.",
    "interviewTip": "Поширена пастка при роботі зі стрілковими функціями."
  },
  "js-fn-05": {
    "prompt": "Стрілкові функції відрізняються від звичайних тим, що вони…",
    "explanation": "Стрілкові функції беруть `this` із лексичного оточення (зовнішнього коду).",
    "interviewTip": "Чудове питання для перевірки розуміння контексту `this`."
  },
  "js-fn-06": {
    "prompt": "Що буде виведено?",
    "explanation": "Об'єкт `arguments` містить лише ті аргументи, які були фактично передані у функцію.",
    "interviewTip": "Згадайте, що стрілкові функції не мають власного об'єкта `arguments`."
  },
  "js-fn-07": {
    "prompt": "Яким буде результат?",
    "explanation": "Параметри за замовчуванням застосовуються лише тоді, коли аргумент має значення `undefined`.",
    "interviewTip": "Це відрізняється від передачі значення `null`."
  },
  "js-fn-08": {
    "prompt": "Що поверне ця функція?",
    "explanation": "Автоматичне вставлення крапки з комою (ASI) завершує інструкцію return передчасно.",
    "interviewTip": "Класичний «підступ» у JavaScript."
  },
  "js-fn-09": {
    "prompt": "Що таке функція вищого порядку (higher-order function)?",
    "explanation": "Це функції, які приймають інші функції як аргументи або повертають їх.",
    "interviewTip": "Приклади: map, filter, reduce."
  },
  "js-fn-10": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "У суворому режимі (strict mode) значення `this` у звичайній функції дорівнює undefined.",
    "interviewTip": "Завжди уточнюйте, чи працює код у суворому режимі."
  },
  "js-fn-11": {
    "prompt": "Що робить метод bind?",
    "explanation": "`bind` створює і повертає нову функцію з прив'язаним контекстом.",
    "interviewTip": "Пам'ятайте різницю: bind ≠ call ≠ apply."
  },
  "js-fn-12": {
    "prompt": "Що буде виведено?",
    "explanation": "Оператор `rest` (...) збирає всі залишкові аргументи в масив.",
    "interviewTip": "Порівняйте rest-параметри з об'єктом arguments."
  },
  "js-fn-13": {
    "prompt": "Що станеться при спробі виклику?",
    "explanation": "Стрілкові функції не можна використовувати як конструктори (з оператором new).",
    "interviewTip": "Вони не мають внутрішнього методу [[Construct]]."
  },
  "js-fn-14": {
    "prompt": "Що таке рекурсія?",
    "explanation": "Рекурсія — це процес, при якому функція викликає саму себе.",
    "interviewTip": "Завжди згадуйте про базовий випадок (умову виходу), щоб уникнути переповнення стека."
  },
  "js-fn-15": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Замикання (closure) зберігає доступ до змінної x навіть після завершення роботи зовнішньої функції.",
    "interviewTip": "Замикання — це фундаментальна концепція JS."
  },
  "js-fn-16": {
    "prompt": "Яке твердження про замикання є правильним?",
    "explanation": "Замикання посилаються на змінні із зовнішньої області видимості.",
    "interviewTip": "Поясніть вплив замикань на використання пам'яті."
  },
  "js-fn-17": {
    "prompt": "Що означає абревіатура IIFE?",
    "explanation": "IIFE — це функція, яка виконується одразу після свого визначення.",
    "interviewTip": "Раніше часто використовувалася для ізоляції області видимості змінних."
  },
  "js-fn-18": {
    "prompt": "Що буде виведено?",
    "explanation": "`arguments` — це масивоподібний об'єкт, а не справжній масив.",
    "interviewTip": "Він не має методів масиву, як-от map або filter."
  },
  "js-fn-19": {
    "prompt": "Що таке хвостова рекурсія (tail recursion)?",
    "explanation": "Це вид рекурсії, де рекурсивний виклик є останньою дією у функції.",
    "interviewTip": "Більшість движків JS наразі не мають повної оптимізації хвостових викликів."
  },
  "js-fn-20": {
    "prompt": "Що виведе цей код?",
    "explanation": "Параметри за замовчуванням можуть посилатися на попередні параметри тієї ж функції.",
    "interviewTip": "Порядок оголошення параметрів має значення."
  },
  "js-fn-21": {
    "prompt": "Що станеться, якщо функція не має інструкції return?",
    "explanation": "Така функція неявно повертає `undefined`.",
    "interviewTip": "Типова помилка початківців при написанні функцій."
  },
  "js-fn-22": {
    "prompt": "Що робить метод call?",
    "explanation": "`call` негайно викликає функцію з заданим значенням `this` та аргументами.",
    "interviewTip": "Поясніть різницю між call, apply та bind."
  },
  "js-fn-23": {
    "prompt": "Що таке арність (arity) функції?",
    "explanation": "Властивість `fn.length` показує кількість очікуваних аргументів функції.",
    "interviewTip": "Це корисно при використанні патернів функціонального програмування."
  },
  "js-fn-24": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Звичайні функції мають властивість `prototype`, стрілкові — ні.",
    "interviewTip": "Стрілкові функції не призначені для створення об'єктів через прототипи."
  },
  "js-fn-25": {
    "prompt": "Чому функції називають «громадянами першого класу»?",
    "explanation": "Оскільки з ними можна поводитися як зі звичайними значеннями (передавати, повертати, присвоювати).",
    "interviewTip": "Саме це робить можливим функціональне програмування в JS."
  }
}
