{
  "js-scope-01": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`var a` піднімається (hoisting) всередині функції, затінюючи зовнішню змінну `a`.",
    "interviewTip": "Класичне питання на поєднання підняття (hoisting) та затінення (shadowing).",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-02": {
    "prompt": "Що таке блочна область видимості?",
    "explanation": "Змінні, оголошені через `let` та `const`, доступні лише всередині блоку `{}`.",
    "interviewTip": "Порівняйте це з функціональною областю видимості `var`.",
    "options": [
      "Scope created by `{}` with let/const",
      "Scope of a function",
      "Scope of an object",
      "Scope of a file"
    ]
  },
  "js-scope-03": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`x` існує лише всередині блоку, де вона була оголошена через let/const.",
    "interviewTip": "Перевірка дотримання правил блочної області видимості.",
    "options": [
      "10",
      "undefined",
      "ReferenceError",
      "null"
    ]
  },
  "js-scope-04": {
    "prompt": "Що станеться?",
    "explanation": "`let` піднімається, але знаходиться в «тимчасовій мертвій зоні» (TDZ) до моменту ініціалізації.",
    "interviewTip": "Концепцію TDZ часто розуміють неправильно, тому це гарне питання.",
    "options": [
      "5",
      "undefined",
      "ReferenceError",
      "TypeError"
    ]
  },
  "js-scope-05": {
    "prompt": "Яка область видимості у змінної, оголошеної через var?",
    "explanation": "`var` ігнорує блоки `{}` і обмежена лише функцією або глобальним простором.",
    "interviewTip": "Це основна причина, чому було введено `let`.",
    "options": [
      "Function scope",
      "Block scope",
      "Module scope only",
      "Lexical scope"
    ]
  },
  "js-scope-06": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`var` «витікає» за межі циклу for у зовнішню область видимості.",
    "interviewTip": "Класичний баг із областю видимості в циклах.",
    "options": [
      "2",
      "3",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-07": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`let` створює нову область видимості для кожної ітерації циклу.",
    "interviewTip": "Область видимості на кожній ітерації (per-iteration scope).",
    "options": [
      "2",
      "3",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-08": {
    "prompt": "Що таке лексична область видимості?",
    "explanation": "Область видимості визначається місцем розташування коду в тексті програми під час написання.",
    "interviewTip": "JavaScript використовує саме лексичну (статичну) область видимості.",
    "options": [
      "Scope determined by code location",
      "Scope determined at runtime",
      "Dynamic scope",
      "Global scope only"
    ]
  },
  "js-scope-09": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Функція `foo` «запам'ятовує» свою лексичну область видимості в момент створення.",
    "interviewTip": "Різниця між лексичною та динамічною областями видимості.",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-10": {
    "prompt": "Що таке замикання (closure)?",
    "explanation": "Це функція разом зі своєю лексичною областю видимості (змінними, що її оточують).",
    "interviewTip": "Одна з найважливіших концепцій у JavaScript.",
    "options": [
      "Function + its lexical scope",
      "Function inside another",
      "Private variable",
      "Recursive function"
    ]
  },
  "js-scope-11": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Замикання підтримує змінну `a` «живою» в пам'яті навіть після виходу з функції.",
    "interviewTip": "Згадайте про утримання пам'яті замиканнями.",
    "options": [
      "1",
      "undefined",
      "ReferenceError",
      "null"
    ]
  },
  "js-scope-12": {
    "prompt": "Що спричиняє витік глобальної змінної?",
    "explanation": "Без суворого режиму (strict mode) неоголошені змінні автоматично стають глобальними.",
    "interviewTip": "Завжди рекомендуйте використовувати strict mode або модулі.",
    "options": [
      "Assigning to undeclared variable",
      "Using let",
      "Using strict mode",
      "Using const"
    ]
  },
  "js-scope-13": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Суворий режим забороняє створення неявних глобальних змінних.",
    "interviewTip": "Важливість використання `use strict`.",
    "options": [
      "10",
      "undefined",
      "ReferenceError",
      "TypeError"
    ]
  },
  "js-scope-14": {
    "prompt": "Яка область видимості у змінних в ES-модулях?",
    "explanation": "Кожен модуль має власну ізольовану область видимості верхнього рівня.",
    "interviewTip": "Модулі запобігають забрудненню глобального простору імен.",
    "options": [
      "Module scope",
      "Global scope",
      "Function scope",
      "Block scope only"
    ]
  },
  "js-scope-15": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Внутрішня змінна `a` має блочну область видимості та затінює зовнішню.",
    "interviewTip": "Ще один приклад затінення (shadowing).",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-16": {
    "prompt": "Що таке затінення змінної (variable shadowing)?",
    "explanation": "Це ситуація, коли змінна у внутрішній області видимості має те саме ім'я, що й у зовнішній.",
    "interviewTip": "Затінення може погіршити читабельність коду.",
    "options": [
      "Inner scope variable with same name",
      "Overwriting global variable",
      "Garbage collection",
      "Hoisting"
    ]
  },
  "js-scope-17": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`const` працює за тими ж правилами області видимості, що й `let`.",
    "interviewTip": "Пам'ятайте: const — це незмінне посилання, а не незмінне значення.",
    "options": [
      "10",
      "undefined",
      "ReferenceError",
      "null"
    ]
  },
  "js-scope-18": {
    "prompt": "Що представляє ланцюжок областей видимості (scope chain)?",
    "explanation": "Ланцюжок, за яким JS шукає ідентифікатор від внутрішньої області до глобальної.",
    "interviewTip": "Не плутайте з ланцюжком прототипів.",
    "options": [
      "Hierarchy of lexical environments",
      "Call stack",
      "Prototype chain",
      "Event loop"
    ]
  },
  "js-scope-19": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Підняття (hoisting) відбувається всередині IIFE так само як у звичайній функції.",
    "interviewTip": "Дуже поширена пастка на співбесідах.",
    "options": [
      "1",
      "2",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-20": {
    "prompt": "Що створює нову область видимості?",
    "explanation": "Функції, блоки `{}` (для let/const), модулі та блоки catch.",
    "interviewTip": "Будьте точними в поясненнях.",
    "options": [
      "Function",
      "Block with let/const",
      "Module",
      "All of the above"
    ]
  },
  "js-scope-21": {
    "prompt": "Чому замикання корисні?",
    "explanation": "Вони дозволяють створювати приватні змінні та зберігати стан без глобальних об'єктів.",
    "interviewTip": "Поєднуйте відповідь із прикладами з реальних проектів.",
    "options": [
      "Data encapsulation",
      "Better performance",
      "Avoid async",
      "Prevent hoisting"
    ]
  },
  "js-scope-22": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Замикання посилаються на саму змінну, а не на її копію на момент створення.",
    "interviewTip": "Важливий нюанс роботи замикань.",
    "options": [
      "10",
      "20",
      "undefined",
      "ReferenceError"
    ]
  },
  "js-scope-23": {
    "prompt": "Що таке тимчасова мертва зона (Temporal Dead Zone)?",
    "explanation": "Час між початком області видимості та фактичною ініціалізацією змінної let/const.",
    "interviewTip": "Головна відмінність від поведінки `var`.",
    "options": [
      "Time before let/const initialization",
      "Async execution delay",
      "Garbage collection phase",
      "Event loop queue"
    ]
  },
  "js-scope-24": {
    "prompt": "Що станеться, якщо повторно оголосити let в тій же області видимості?",
    "explanation": "JavaScript викине SyntaxError; повторне оголошення в одній області заборонено.",
    "interviewTip": "Це допомагає уникати випадкових перезаписів змінних.",
    "options": [
      "SyntaxError",
      "undefined",
      "Ignored",
      "Overwritten"
    ]
  },
  "js-scope-25": {
    "prompt": "Чому глобальна область видимості вважається небезпечною?",
    "explanation": "Вона збільшує зв'язність коду (coupling) та ризик конфліктів імен.",
    "interviewTip": "Гарне питання на перевірку архітектурного мислення.",
    "options": [
      "Name collisions",
      "Memory leaks",
      "Hard to test",
      "All of the above"
    ]
  }
}