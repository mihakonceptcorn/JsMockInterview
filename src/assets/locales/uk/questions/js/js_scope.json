{
  "js-scope-01": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`var a` піднімається (hoisting) всередині функції, затінюючи зовнішню змінну `a`.",
    "interviewTip": "Класичне питання на поєднання підняття (hoisting) та затінення (shadowing)."
  },
  "js-scope-02": {
    "prompt": "Що таке блочна область видимості?",
    "explanation": "Змінні, оголошені через `let` та `const`, доступні лише всередині блоку `{}`.",
    "interviewTip": "Порівняйте це з функціональною областю видимості `var`."
  },
  "js-scope-03": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`x` існує лише всередині блоку, де вона була оголошена через let/const.",
    "interviewTip": "Перевірка дотримання правил блочної області видимості."
  },
  "js-scope-04": {
    "prompt": "Що станеться?",
    "explanation": "`let` піднімається, але знаходиться в «тимчасовій мертвій зоні» (TDZ) до моменту ініціалізації.",
    "interviewTip": "Концепцію TDZ часто розуміють неправильно, тому це гарне питання."
  },
  "js-scope-05": {
    "prompt": "Яка область видимості у змінної, оголошеної через var?",
    "explanation": "`var` ігнорує блоки `{}` і обмежена лише функцією або глобальним простором.",
    "interviewTip": "Це основна причина, чому було введено `let`."
  },
  "js-scope-06": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`var` «витікає» за межі циклу for у зовнішню область видимості.",
    "interviewTip": "Класичний баг із областю видимості в циклах."
  },
  "js-scope-07": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`let` створює нову область видимості для кожної ітерації циклу.",
    "interviewTip": "Область видимості на кожній ітерації (per-iteration scope)."
  },
  "js-scope-08": {
    "prompt": "Що таке лексична область видимості?",
    "explanation": "Область видимості визначається місцем розташування коду в тексті програми під час написання.",
    "interviewTip": "JavaScript використовує саме лексичну (статичну) область видимості."
  },
  "js-scope-09": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Функція `foo` «запам'ятовує» свою лексичну область видимості в момент створення.",
    "interviewTip": "Різниця між лексичною та динамічною областями видимості."
  },
  "js-scope-10": {
    "prompt": "Що таке замикання (closure)?",
    "explanation": "Це функція разом зі своєю лексичною областю видимості (змінними, що її оточують).",
    "interviewTip": "Одна з найважливіших концепцій у JavaScript."
  },
  "js-scope-11": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Замикання підтримує змінну `a` «живою» в пам'яті навіть після виходу з функції.",
    "interviewTip": "Згадайте про утримання пам'яті замиканнями."
  },
  "js-scope-12": {
    "prompt": "Що спричиняє витік глобальної змінної?",
    "explanation": "Без суворого режиму (strict mode) неоголошені змінні автоматично стають глобальними.",
    "interviewTip": "Завжди рекомендуйте використовувати strict mode або модулі."
  },
  "js-scope-13": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Суворий режим забороняє створення неявних глобальних змінних.",
    "interviewTip": "Важливість використання `use strict`."
  },
  "js-scope-14": {
    "prompt": "Яка область видимості у змінних в ES-модулях?",
    "explanation": "Кожен модуль має власну ізольовану область видимості верхнього рівня.",
    "interviewTip": "Модулі запобігають забрудненню глобального простору імен."
  },
  "js-scope-15": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Внутрішня змінна `a` має блочну область видимості та затінює зовнішню.",
    "interviewTip": "Ще один приклад затінення (shadowing)."
  },
  "js-scope-16": {
    "prompt": "Що таке затінення змінної (variable shadowing)?",
    "explanation": "Це ситуація, коли змінна у внутрішній області видимості має те саме ім'я, що й у зовнішній.",
    "interviewTip": "Затінення може погіршити читабельність коду."
  },
  "js-scope-17": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "`const` працює за тими ж правилами області видимості, що й `let`.",
    "interviewTip": "Пам'ятайте: const — це незмінне посилання, а не незмінне значення."
  },
  "js-scope-18": {
    "prompt": "Що представляє ланцюжок областей видимості (scope chain)?",
    "explanation": "Ланцюжок, за яким JS шукає ідентифікатор від внутрішньої області до глобальної.",
    "interviewTip": "Не плутайте з ланцюжком прототипів."
  },
  "js-scope-19": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Підняття (hoisting) відбувається всередині IIFE так само як у звичайній функції.",
    "interviewTip": "Дуже поширена пастка на співбесідах."
  },
  "js-scope-20": {
    "prompt": "Що створює нову область видимості?",
    "explanation": "Функції, блоки `{}` (для let/const), модулі та блоки catch.",
    "interviewTip": "Будьте точними в поясненнях."
  },
  "js-scope-21": {
    "prompt": "Чому замикання корисні?",
    "explanation": "Вони дозволяють створювати приватні змінні та зберігати стан без глобальних об'єктів.",
    "interviewTip": "Поєднуйте відповідь із прикладами з реальних проектів."
  },
  "js-scope-22": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Замикання посилаються на саму змінну, а не на її копію на момент створення.",
    "interviewTip": "Важливий нюанс роботи замикань."
  },
  "js-scope-23": {
    "prompt": "Що таке тимчасова мертва зона (Temporal Dead Zone)?",
    "explanation": "Час між початком області видимості та фактичною ініціалізацією змінної let/const.",
    "interviewTip": "Головна відмінність від поведінки `var`."
  },
  "js-scope-24": {
    "prompt": "Що станеться, якщо повторно оголосити let в тій же області видимості?",
    "explanation": "JavaScript викине SyntaxError; повторне оголошення в одній області заборонено.",
    "interviewTip": "Це допомагає уникати випадкових перезаписів змінних."
  },
  "js-scope-25": {
    "prompt": "Чому глобальна область видимості вважається небезпечною?",
    "explanation": "Вона збільшує зв'язність коду (coupling) та ризик конфліктів імен.",
    "interviewTip": "Гарне питання на перевірку архітектурного мислення."
  }
}
