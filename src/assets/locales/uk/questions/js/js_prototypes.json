{
  "js-proto-01": {
    "prompt": "Що таке прототип у JavaScript?",
    "explanation": "Кожен об'єкт у JS має внутрішнє посилання на інший об'єкт, який називається прототипом.",
    "interviewTip": "JS використовує прототипне наслідування, а не класичне."
  },
  "js-proto-02": {
    "prompt": "На що вказує властивість `__proto__`?",
    "explanation": "`__proto__` посилається на внутрішню властивість [[Prototype]] об'єкта.",
    "interviewTip": "Рекомендований API для доступу — `Object.getPrototypeOf`."
  },
  "js-proto-03": {
    "prompt": "Що таке `Function.prototype`?",
    "explanation": "Усі функції в JavaScript успадковують методи від об'єкта Function.prototype.",
    "interviewTip": "Пам'ятайте, що функції — це теж об'єкти."
  },
  "js-proto-04": {
    "prompt": "Яким буде результат?",
    "explanation": "Оператор `new` пов'язує новий екземпляр із прототипом конструктора.",
    "interviewTip": "Властивість `prototype` існує лише у функцій."
  },
  "js-proto-05": {
    "prompt": "Де зазвичай визначаються методи для всіх екземплярів?",
    "explanation": "Методи, визначені в прототипі, є спільними для всіх екземплярів.",
    "interviewTip": "Це суттєва оптимізація пам'яті."
  },
  "js-proto-06": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Звичайні об'єкти успадковують властивості від Object.prototype.",
    "interviewTip": "Це корінь більшості ланцюжків прототипів."
  },
  "js-proto-07": {
    "prompt": "Чим закінчується ланцюжок прототипів?",
    "explanation": "Ланцюжок закінчується на null: `Object.prototype.__proto__ === null`.",
    "interviewTip": "Важлива точка термінації пошуку властивостей."
  },
  "js-proto-08": {
    "prompt": "Що перевіряє метод `hasOwnProperty`?",
    "explanation": "Він перевіряє лише власні властивості об'єкта, ігноруючи прототипи.",
    "interviewTip": "Допомагає уникнути помилкових результатів при переборі ключів."
  },
  "js-proto-09": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Властивість розпізнається через ланцюжок прототипів, якщо її немає в самому об'єкті.",
    "interviewTip": "Розуміння порядку пошуку (lookup order)."
  },
  "js-proto-10": {
    "prompt": "Що станеться, якщо перезаписати властивість prototype?",
    "explanation": "Прототип встановлюється в момент створення об'єкта.",
    "interviewTip": "Типова помилка при спробі змінити поведінку вже створених об'єктів."
  },
  "js-proto-11": {
    "prompt": "Що робить метод `Object.create(proto)`?",
    "explanation": "Створює новий об'єкт із явно вказаним прототипом.",
    "interviewTip": "Дозволяє реалізувати чисте наслідування без виклику конструктора."
  },
  "js-proto-12": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Об'єкт b успадковує властивості від a через прототип.",
    "interviewTip": "Це делегування (delegation), а не копіювання властивостей."
  },
  "js-proto-13": {
    "prompt": "Що таке властивість `constructor`?",
    "explanation": "Це посилання на функцію-конструктор, яка створила екземпляр.",
    "interviewTip": "Це посилання може бути втрачене при повній заміні об'єкта прототипу."
  },
  "js-proto-14": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Оператор `instanceof` перевіряє наявність прототипу конструктора в ланцюжку об'єкта.",
    "interviewTip": "Не завжди є безпечним способом перевірки типів."
  },
  "js-proto-15": {
    "prompt": "Чому варто уникати модифікації вбудованих прототипів?",
    "explanation": "Це створює ризик «забруднення прототипів» (prototype pollution) та конфліктів.",
    "interviewTip": "Ніколи не розширюйте прототипи Array чи Object у реальних проектах."
  },
  "js-proto-16": {
    "prompt": "Як працює пошук методу?",
    "explanation": "Пошук зупиняється на першому знайденому збігу або коли досягає null.",
    "interviewTip": "Довгі ланцюжки прототипів можуть впливати на продуктивність."
  },
  "js-proto-17": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Присвоєння властивості завжди відбувається безпосередньо в самому об'єкті.",
    "interviewTip": "Це називається «затіненням» (shadowing) властивостей прототипу."
  },
  "js-proto-18": {
    "prompt": "Що таке делегування прототипів?",
    "explanation": "JS не копіює методи, а делегує виклик об'єкту-прототипу.",
    "interviewTip": "Важлива зміна ментальної моделі порівняно з Java чи C++."
  },
  "js-proto-19": {
    "prompt": "Що таке `Object.setPrototypeOf`?",
    "explanation": "Метод, який дозволяє змінювати прототип об'єкта вже після його створення.",
    "interviewTip": "Це дуже повільна операція, її варто уникати в критичному коді."
  },
  "js-proto-20": {
    "prompt": "Що станеться, якщо метод існує і в об'єкті, і в прототипі?",
    "explanation": "Власна властивість об'єкта має пріоритет.",
    "interviewTip": "Знову ж таки, порядок пошуку в ланцюжку."
  },
  "js-proto-21": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Ланцюжок прототипів включає прототип батьківського класу.",
    "interviewTip": "Основа ручного налаштування наслідування."
  },
  "js-proto-22": {
    "prompt": "Який прототип у стрілкової функції?",
    "explanation": "Стрілкові функції є функціями, тому успадковують від Function.prototype.",
    "interviewTip": "Але вони не мають власної властивості `.prototype`."
  },
  "js-proto-23": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Прототипи самі по собі є звичайними об'єктами.",
    "interviewTip": "Прототип — це не функція (якщо це не Function.prototype)."
  },
  "js-proto-24": {
    "prompt": "Що таке prototype pollution (забруднення прототипів)?",
    "explanation": "Вразливість, при якій зловмисник може змінити базові прототипи через вхідні дані.",
    "interviewTip": "Серйозна проблема безпеки в Node.js застосунках."
  },
  "js-proto-25": {
    "prompt": "У чому сила прототипного наслідування?",
    "explanation": "Воно дозволяє динамічно ділитися поведінкою між об'єктами без створення копій.",
    "interviewTip": "Це гнучкіша модель, ніж жорсткі класи в інших мовах."
  }
}
