{
  "js-err-01": {
    "prompt": "Що таке об'єкт Error у JavaScript?",
    "explanation": "Об'єкти Error містять повідомлення про помилку та стек викликів (stack trace).",
    "interviewTip": "Використовується для обробки виняткових ситуацій."
  },
  "js-err-02": {
    "prompt": "Яка помилка виникає на етапі парсингу коду?",
    "explanation": "SyntaxError виникає ще до початку виконання коду.",
    "interviewTip": "У такому разі код взагалі не запуститься."
  },
  "js-err-03": {
    "prompt": "Яка помилка буде викинута?",
    "explanation": "Звернення до неоголошеної змінної викликає ReferenceError.",
    "interviewTip": "Це відрізняється від змінної зі значенням undefined."
  },
  "js-err-04": {
    "prompt": "Коли виникає TypeError?",
    "explanation": "При спробі викликати те, що не є функцією, або звернутися до властивості null/undefined.",
    "interviewTip": "Дуже поширена помилка під час виконання (runtime)."
  },
  "js-err-05": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Некоректний JSON викликає SyntaxError при спробі парсингу.",
    "interviewTip": "Завжди валідуйте або обробляйте JSON.parse."
  },
  "js-err-06": {
    "prompt": "Що саме перехоплює try/catch?",
    "explanation": "Лише синхронні помилки під час виконання.",
    "interviewTip": "Для асинхронного коду потрібен await або .catch()."
  },
  "js-err-07": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Асинхронні помилки всередині звичайного try/catch (без await) не перехоплюються.",
    "interviewTip": "Класична пастка асинхронного програмування."
  },
  "js-err-08": {
    "prompt": "Як перехоплювати асинхронні помилки з async/await?",
    "explanation": "Коли ви використовуєте await всередині try/catch, помилки стають «синхронними» для обробника.",
    "interviewTip": "Це рекомендований патерн розробки."
  },
  "js-err-09": {
    "prompt": "Для чого використовується блок finally?",
    "explanation": "Він виконується завжди, незалежно від того, чи була помилка.",
    "interviewTip": "Підходить для очищення ресурсів або закриття з'єднань."
  },
  "js-err-10": {
    "prompt": "Що робить оператор `throw`?",
    "explanation": "Він зупиняє нормальне виконання програми та генерує виняток.",
    "interviewTip": "Викинути (throw) можна будь-яке значення, не лише об'єкт Error."
  },
  "js-err-11": {
    "prompt": "Що найкраще використовувати як аргумент для throw?",
    "explanation": "Краще викидати об'єкти `new Error()`, бо вони містять стек викликів.",
    "interviewTip": "Це вважається найкращою практикою (best practice)."
  },
  "js-err-12": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Властивість `message` об'єкта Error містить текст помилки.",
    "interviewTip": "Використовуйте корисні поля об'єкта для логування."
  },
  "js-err-13": {
    "prompt": "Що таке ReferenceError?",
    "explanation": "Помилка, яка виникає, коли в поточному контексті не знайдено змінну.",
    "interviewTip": "Часте джерело багів через помилки в іменах або області видимості."
  },
  "js-err-14": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Спроба викликати метод у null призведе до TypeError.",
    "interviewTip": "TypeError — найпоширеніша помилка при роботі з даними."
  },
  "js-err-15": {
    "prompt": "Як створити власну помилку (custom error)?",
    "explanation": "Шляхом створення класу, що наслідує (extends) базовий клас Error.",
    "interviewTip": "Не забувайте зберігати назву та стек викликів."
  },
  "js-err-16": {
    "prompt": "Що містить Error.stack?",
    "explanation": "Список викликів функцій, що призвели до виникнення помилки.",
    "interviewTip": "Це поле не стандартизоване, але підтримується всіма сучасними браузерами."
  },
  "js-err-17": {
    "prompt": "Що таке необроблене відхилення проміса (unhandled promise rejection)?",
    "explanation": "Проміс, який було відхилено (reject), але для якого не було викликано .catch().",
    "interviewTip": "У Node.js та браузерах це може призвести до попереджень або завершення роботи."
  },
  "js-err-18": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Значення, передане в reject(), потрапляє в перший обробник catch.",
    "interviewTip": "Проміс може бути відхилений з будь-яким значенням."
  },
  "js-err-19": {
    "prompt": "Що повертає метод `catch`?",
    "explanation": "Він повертає новий проміс, що дозволяє будувати ланцюжки.",
    "interviewTip": "Після catch ланцюжок промісів може продовжуватися."
  },
  "js-err-20": {
    "prompt": "Що станеться, якщо викинути помилку всередині catch?",
    "explanation": "Помилка передасться далі в наступний обробник catch у ланцюжку.",
    "interviewTip": "Це патерн «перевикидання» (re-throw) для фільтрації помилок."
  },
  "js-err-21": {
    "prompt": "Що таке RangeError?",
    "explanation": "Виникає, коли значення не входить у допустимий діапазон (наприклад, некоректна довжина масиву).",
    "interviewTip": "Зустрічається рідше, ніж TypeError чи ReferenceError."
  },
  "js-err-22": {
    "prompt": "Чи може try/catch перехопити помилки JSON.parse?",
    "explanation": "Так, оскільки JSON.parse виконується синхронно.",
    "interviewTip": "Завжди огортайте логіку парсингу в блоки обробки винятків."
  },
  "js-err-23": {
    "prompt": "Яка найкраща практика обробки помилок?",
    "explanation": "Помилки мають бути явними та надавати достатньо контексту для виправлення.",
    "interviewTip": "Ознака професійного «production-ready» підходу."
  },
  "js-err-24": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Будь-яке значення, навіть число чи рядок, може бути викинуте через throw.",
    "interviewTip": "Але ніколи не робіть так у реальних проектах."
  },
  "js-err-25": {
    "prompt": "Чому краще викидати Error, а не звичайні рядки?",
    "explanation": "Об'єкти Error збирають метадані (стек викликів, тип), що критично для відлагодження.",
    "interviewTip": "Це «золота» відповідь на співбесіді."
  }
}
