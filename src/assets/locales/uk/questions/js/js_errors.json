{
  "js-err-01": {
    "prompt": "Що таке об'єкт Error у JavaScript?",
    "explanation": "Об'єкти Error містять повідомлення про помилку та стек викликів (stack trace).",
    "interviewTip": "Використовується для обробки виняткових ситуацій.",
    "options": [
      "Об'єкт, що представляє помилку під час виконання (runtime)",
      "Синтаксична конструкція",
      "Відхилення проміса (promise rejection)",
      "Повідомлення в консолі"
    ]
  },
  "js-err-02": {
    "prompt": "Яка помилка виникає на етапі парсингу коду?",
    "explanation": "SyntaxError виникає ще до початку виконання коду.",
    "interviewTip": "У такому разі код взагалі не запуститься.",
    "options": ["SyntaxError", "ReferenceError", "TypeError", "RangeError"]
  },
  "js-err-03": {
    "prompt": "Яка помилка буде викинута?",
    "explanation": "Звернення до неоголошеної змінної викликає ReferenceError.",
    "interviewTip": "Це відрізняється від змінної зі значенням undefined.",
    "options": ["ReferenceError", "TypeError", "SyntaxError", "undefined"]
  },
  "js-err-04": {
    "prompt": "Коли виникає TypeError?",
    "explanation": "При спробі викликати те, що не є функцією, або звернутися до властивості null/undefined.",
    "interviewTip": "Дуже поширена помилка під час виконання (runtime).",
    "options": [
      "Некоректна операція над значенням",
      "Некоректний синтаксис",
      "Значення поза діапазоном",
      "Відсутня змінна"
    ]
  },
  "js-err-05": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Некоректний JSON викликає SyntaxError при спробі парсингу.",
    "interviewTip": "Завжди валідуйте або обробляйте JSON.parse.",
    "options": ["SyntaxError", "TypeError", "ReferenceError", "Error"]
  },
  "js-err-06": {
    "prompt": "Що саме перехоплює try/catch?",
    "explanation": "Лише синхронні помилки під час виконання.",
    "interviewTip": "Для асинхронного коду потрібен await або .catch().",
    "options": [
      "Помилки під час виконання (Runtime errors)",
      "Синтаксичні помилки (Syntax errors)",
      "Автоматично асинхронні помилки",
      "Помилки компіляції"
    ]
  },
  "js-err-07": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Асинхронні помилки всередині звичайного try/catch (без await) не перехоплюються.",
    "interviewTip": "Класична пастка асинхронного програмування.",
    "options": ["Нічого", "caught", "Error", "Необроблена помилка (Unhandled)"]
  },
  "js-err-08": {
    "prompt": "Як перехоплювати асинхронні помилки з async/await?",
    "explanation": "Коли ви використовуєте await всередині try/catch, помилки стають «синхронними» для обробника.",
    "interviewTip": "Це рекомендований патерн розробки.",
    "options": ["try/catch", "тільки .then", "window.onerror", "finally"]
  },
  "js-err-09": {
    "prompt": "Для чого використовується блок finally?",
    "explanation": "Він виконується завжди, незалежно від того, чи була помилка.",
    "interviewTip": "Підходить для очищення ресурсів або закриття з'єднань.",
    "options": [
      "Логіка очищення (Cleanup)",
      "Обробка помилок",
      "Повернення значень",
      "Перехоплення помилок"
    ]
  },
  "js-err-10": {
    "prompt": "Що робить оператор `throw`?",
    "explanation": "Він зупиняє нормальне виконання програми та генерує виняток.",
    "interviewTip": "Викинути (throw) можна будь-яке значення, не лише об'єкт Error.",
    "options": [
      "Генерує виняток",
      "Логує помилку",
      "Зупиняє програму назавжди",
      "Повертає значення"
    ]
  },
  "js-err-11": {
    "prompt": "Що найкраще використовувати як аргумент для throw?",
    "explanation": "Краще викидати об'єкти `new Error()`, бо вони містять стек викликів.",
    "interviewTip": "Це вважається найкращою практикою (best practice).",
    "options": [
      "Об'єкти Error",
      "Рядки (Strings)",
      "Числа (Numbers)",
      "Булеві значення (Booleans)"
    ]
  },
  "js-err-12": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Властивість `message` об'єкта Error містить текст помилки.",
    "interviewTip": "Використовуйте корисні поля об'єкта для логування.",
    "options": ["fail", "Error", "undefined", "null"]
  },
  "js-err-13": {
    "prompt": "Що таке ReferenceError?",
    "explanation": "Помилка, яка виникає, коли в поточному контексті не знайдено змінну.",
    "interviewTip": "Часте джерело багів через помилки в іменах або області видимості.",
    "options": [
      "Доступ до неоголошеної змінної",
      "Виклик некоректної функції",
      "Некоректний синтаксис",
      "Брак пам'яті (Out of memory)"
    ]
  },
  "js-err-14": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Спроба викликати метод у null призведе до TypeError.",
    "interviewTip": "TypeError — найпоширеніша помилка при роботі з даними.",
    "options": ["true", "false", "undefined", "Error"]
  },
  "js-err-15": {
    "prompt": "Як створити власну помилку (custom error)?",
    "explanation": "Шляхом створення класу, що наслідує (extends) базовий клас Error.",
    "interviewTip": "Не забувайте зберігати назву та стек викликів.",
    "options": [
      "class MyError extends Error {}",
      "throw {}",
      "throw new Object()",
      "Error.create()"
    ]
  },
  "js-err-16": {
    "prompt": "Що містить Error.stack?",
    "explanation": "Список викликів функцій, що призвели до виникнення помилки.",
    "interviewTip": "Це поле не стандартизоване, але підтримується всіма сучасними браузерами.",
    "options": [
      "Трасування стека викликів (Call stack trace)",
      "Повідомлення про помилку",
      "Тип помилки",
      "Час виконання"
    ]
  },
  "js-err-17": {
    "prompt": "Що таке необроблене відхилення проміса (unhandled promise rejection)?",
    "explanation": "Проміс, який було відхилено (reject), але для якого не було викликано .catch().",
    "interviewTip": "У Node.js та браузерах це може призвести до попереджень або завершення роботи.",
    "options": [
      "Проміс відхилено без catch",
      "Синтаксична помилка",
      "Асинхронний таймаут",
      "Скасований проміс"
    ]
  },
  "js-err-18": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Значення, передане в reject(), потрапляє в перший обробник catch.",
    "interviewTip": "Проміс може бути відхилений з будь-яким значенням.",
    "options": ["err", "Error", "undefined", "null"]
  },
  "js-err-19": {
    "prompt": "Що повертає метод `catch`?",
    "explanation": "Він повертає новий проміс, що дозволяє будувати ланцюжки.",
    "interviewTip": "Після catch ланцюжок промісів може продовжуватися.",
    "options": ["Новий Promise", "Той самий Promise", "Undefined", "Error"]
  },
  "js-err-20": {
    "prompt": "Що станеться, якщо викинути помилку всередині catch?",
    "explanation": "Помилка передасться далі в наступний обробник catch у ланцюжку.",
    "interviewTip": "Це патерн «перевикидання» (re-throw) для фільтрації помилок.",
    "options": [
      "Promise знову відхиляється",
      "Помилка поглинається (swallowed)",
      "Виконання продовжується",
      "Ігнорується"
    ]
  },
  "js-err-21": {
    "prompt": "Що таке RangeError?",
    "explanation": "Виникає, коли значення не входить у допустимий діапазон (наприклад, некоректна довжина масиву).",
    "interviewTip": "Зустрічається рідше, ніж TypeError чи ReferenceError.",
    "options": [
      "Значення поза допустимим діапазоном",
      "Неправильна змінна",
      "Некоректний синтаксис",
      "Асинхронна помилка"
    ]
  },
  "js-err-22": {
    "prompt": "Чи може try/catch перехопити помилки JSON.parse?",
    "explanation": "Так, оскільки JSON.parse виконується синхронно.",
    "interviewTip": "Завжди огортайте логіку парсингу в блоки обробки винятків.",
    "options": ["Так", "Ні", "Тільки асинхронні", "Тільки синхронні"]
  },
  "js-err-23": {
    "prompt": "Яка найкраща практика обробки помилок?",
    "explanation": "Помилки мають бути явними та надавати достатньо контексту для виправлення.",
    "interviewTip": "Ознака професійного «production-ready» підходу.",
    "options": [
      "Швидке падіння (fail fast) та чітке логування",
      "Ігнорування помилок",
      "Повернення null",
      "Використання тільки console.log"
    ]
  },
  "js-err-24": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Будь-яке значення, навіть число чи рядок, може бути викинуте через throw.",
    "interviewTip": "Але ніколи не робіть так у реальних проектах.",
    "options": ["string", "object", "error", "undefined"]
  },
  "js-err-25": {
    "prompt": "Чому краще викидати Error, а не звичайні рядки?",
    "explanation": "Об'єкти Error збирають метадані (стек викликів, тип), що критично для відлагодження.",
    "interviewTip": "Це «золота» відповідь на співбесіді.",
    "options": [
      "Трасування стека та узгодженість",
      "Коротший синтаксис",
      "Продуктивність",
      "Вимагається JS"
    ]
  }
}
