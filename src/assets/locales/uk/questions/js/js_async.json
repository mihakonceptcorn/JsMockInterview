{
  "js-async-01": {
    "prompt": "Що таке асинхронне програмування в JavaScript?",
    "explanation": "Асинхронний код дозволяє виконувати операції без блокування основного потоку.",
    "interviewTip": "JS є однопотоковим, але підтримує асинхронність.",
    "options": [
      "Код, який виконується без блокування основного потоку",
      "Багатопотокове виконання",
      "Паралельне виконання всіх функцій",
      "Синхронні колбеки"
    ]
  },
  "js-async-02": {
    "prompt": "Який механізм відповідає за обробку асинхронних завдань?",
    "explanation": "Event Loop координує виконання асинхронного коду.",
    "interviewTip": "Критично важлива тема для співбесіди.",
    "options": ["Event Loop", "Call Stack", "Heap", "Compiler"]
  },
  "js-async-03": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "setTimeout є асинхронним, навіть із затримкою 0 мс.",
    "interviewTip": "Поведінка макрозавдань (macro-tasks).",
    "options": ["1 2 3", "1 3 2", "2 1 3", "3 2 1"]
  },
  "js-async-04": {
    "prompt": "Що таке проміс (Promise)?",
    "explanation": "Promise представляє значення, яке буде доступне в майбутньому.",
    "interviewTip": "Стани: pending / fulfilled / rejected.",
    "options": [
      "Об'єкт, що представляє можливе завершення асинхронної операції",
      "Колбек",
      "Потік (thread)",
      "Таймер"
    ]
  },
  "js-async-05": {
    "prompt": "Якого стану НЕ існує у проміса?",
    "explanation": "`resolved` — це неформальний термін, а не офіційний стан.",
    "interviewTip": "Точна термінологія має значення.",
    "options": ["pending", "fulfilled", "rejected", "resolved"]
  },
  "js-async-06": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Мікрозавдання виконуються одразу після синхронного коду.",
    "interviewTip": "Черга мікрозавдань (Microtask queue).",
    "options": ["1 2", "2 1", "undefined", "Error"]
  },
  "js-async-07": {
    "prompt": "Що таке async/await?",
    "explanation": "Синтаксичний цукор, побудований на базі промісів.",
    "interviewTip": "Це все одно асинхронний код.",
    "options": [
      "Синтаксичний цукор над Promises",
      "Нова потокова модель",
      "Заміна колбеків",
      "Блокуючий код"
    ]
  },
  "js-async-08": {
    "prompt": "Що робить ключове слово `await`?",
    "explanation": "Призупиняє виконання лише поточної асинхронної функції.",
    "interviewTip": "Не блокує Event Loop.",
    "options": [
      "Призупиняє виконання асинхронної функції",
      "Блокує весь потік",
      "Зупиняє програму",
      "Вирішує Promise синхронно"
    ]
  },
  "js-async-09": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Асинхронні функції завжди повертають проміс.",
    "interviewTip": "Результат автоматично огортається в Promise.",
    "options": ["5", "Promise", "undefined", "Error"]
  },
  "js-async-10": {
    "prompt": "Що виконається першим?",
    "explanation": "Мікрозавдання мають вищий пріоритет, ніж макрозавдання.",
    "interviewTip": "Порівняння Promise.then та setTimeout.",
    "options": [
      "Мікрозавдання (Microtasks)",
      "Макрозавдання (Macrotasks)",
      "Рендеринг",
      "Таймери"
    ]
  },
  "js-async-11": {
    "prompt": "Що робить `Promise.all`?",
    "explanation": "Відхиляється (reject), якщо хоча б один проміс завершився помилкою.",
    "interviewTip": "Принцип «швидкого відмовлення» (fail-fast).",
    "options": [
      "Виконується успішно, коли всі проміси вирішені",
      "Виконується успішно, коли перший вирішений",
      "Відхиляється за таймаутом",
      "Запускається послідовно"
    ]
  },
  "js-async-12": {
    "prompt": "Що робить `Promise.race`?",
    "explanation": "Повертає результат проміса, який завершився першим (успішно чи з помилкою).",
    "interviewTip": "Корисно для реалізації таймаутів.",
    "options": [
      "Вирішується/відхиляється з першим завершеним",
      "Чекає на всі",
      "Виконує послідовно",
      "Скасовує інші"
    ]
  },
  "js-async-13": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Await викидає помилку, якщо проміс відхилено.",
    "interviewTip": "Використовуйте try/catch.",
    "options": ["err", "after", "undefined", "Error"]
  },
  "js-async-14": {
    "prompt": "Як обробляти помилки в async/await?",
    "explanation": "Блок try/catch перехоплює помилки відхилених промісів.",
    "interviewTip": "Локальна обробка помилок.",
    "options": ["try/catch", ".then", "умовний оператор if", "тільки finally"]
  },
  "js-async-15": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Черга мікрозавдань очищується перед наступним макрозавданням.",
    "interviewTip": "Класичне питання на співбесіді.",
    "options": [
      "start end promise timeout",
      "start promise end timeout",
      "start end timeout promise",
      "promise start end timeout"
    ]
  },
  "js-async-16": {
    "prompt": "Що робить метод `finally`?",
    "explanation": "Виконується після завершення проміса, незалежно від результату.",
    "interviewTip": "Не має доступу до результату (value/error).",
    "options": [
      "Виконується незалежно від результату проміса",
      "Перехоплює помилки",
      "Скасовує проміс",
      "Повертає значення"
    ]
  },
  "js-async-17": {
    "prompt": "Що таке «пекло колбеків» (callback hell)?",
    "explanation": "Складна вкладеність функцій, яку важко читати та підтримувати.",
    "interviewTip": "Проміси допомагають вирішити цю проблему.",
    "options": [
      "Глибоко вкладені колбеки",
      "Ланцюжок промісів",
      "Використання async/await",
      "Помилка Event Loop"
    ]
  },
  "js-async-18": {
    "prompt": "Що робить `await Promise.all([...])`?",
    "explanation": "Запускає проміси паралельно і чекає на виконання всіх.",
    "interviewTip": "Оптимізація продуктивності.",
    "options": [
      "Запускає проміси паралельно",
      "Запускає послідовно",
      "Блокує потік",
      "Скасовує повільні проміси"
    ]
  },
  "js-async-19": {
    "prompt": "Чому варто уникати `await` всередині циклів?",
    "explanation": "Це призводить до послідовного виконання замість паралельного. Використовуйте Promise.all.",
    "interviewTip": "Поширена проблема продуктивності.",
    "options": [
      "Спричиняє послідовне виконання",
      "Синтаксична помилка",
      "Витік пам'яті",
      "Нескінченний цикл"
    ]
  },
  "js-async-20": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "Проміс автоматично розгортається (flattening) при поверненні.",
    "interviewTip": "Особливість розділення промісів.",
    "options": ["1", "Promise", "undefined", "Error"]
  },
  "js-async-21": {
    "prompt": "Що таке макрозавдання (macrotask)?",
    "explanation": "Завдання, яке планується через чергу завдань (наприклад, таймери, події вводу).",
    "interviewTip": "Має нижчий пріоритет за мікрозавдання.",
    "options": [
      "setTimeout, setInterval",
      "Promise.then",
      "Мікрозавдання (Microtask)",
      "Стек викликів (Call stack)"
    ]
  },
  "js-async-22": {
    "prompt": "Що станеться, якщо проміс відхилено, а `catch` відсутній?",
    "explanation": "Це призводить до помилки 'Unhandled Promise Rejection'.",
    "interviewTip": "Завжди обробляйте відхилення.",
    "options": [
      "Необроблене відхилення (Unhandled rejection)",
      "Тиха помилка",
      "Зупинка програми",
      "Ігнорується"
    ]
  },
  "js-async-23": {
    "prompt": "Що робить `queueMicrotask`?",
    "explanation": "Явно додає завдання в чергу мікрозавдань.",
    "interviewTip": "Просунута тема для Senior/Middle рівнів.",
    "options": [
      "Планує мікрозавдання",
      "Планує макрозавдання",
      "Блокує виконання",
      "Створює проміс"
    ]
  },
  "js-async-24": {
    "prompt": "Чому асинхронний код важко відлагоджувати?",
    "explanation": "Стек викликів (stack trace) може перериватися між асинхронними кроками.",
    "interviewTip": "Використовуйте асинхронні стеки викликів у DevTools.",
    "options": [
      "Порядок виконання нелінійний",
      "У JS немає дебагера",
      "Проміси приховують помилки",
      "Один потік"
    ]
  },
  "js-async-25": {
    "prompt": "Яка найкраща практика для асинхронного коду?",
    "explanation": "Код має бути читабельним, передбачуваним та містити обробку помилок.",
    "interviewTip": "Підхід, готовий до використання у продакшені.",
    "options": [
      "Використання async/await + try/catch",
      "Вкладені колбеки",
      "Ігнорування помилок",
      "Блокування потоку"
    ]
  }
}
