{
  "js-mm-01": {
    "prompt": "Де зберігаються примітивні значення?",
    "explanation": "Примітиви зазвичай зберігаються безпосередньо в стеку (stack).",
    "interviewTip": "Об'єкти ж живуть у купі (heap)."
  },
  "js-mm-02": {
    "prompt": "Де зберігаються об'єкти?",
    "explanation": "Об'єкти розміщуються в купі (heap).",
    "interviewTip": "У стеку зберігаються лише посилання на ці об'єкти."
  },
  "js-mm-03": {
    "prompt": "Що таке збір сміття (Garbage Collection)?",
    "explanation": "Це процес автоматичного звільнення пам'яті, яка більше не використовується.",
    "interviewTip": "JavaScript — це мова з автоматичним керуванням пам'яттю."
  },
  "js-mm-04": {
    "prompt": "Який алгоритм найчастіше використовують движки JS?",
    "explanation": "Сучасні движки використовують варіації алгоритму «Mark-and-Sweep» (познач та прибери).",
    "interviewTip": "V8 використовує поколінневий збір сміття (Generational GC)."
  },
  "js-mm-05": {
    "prompt": "Коли об'єкт стає доступним для видалення збирачем сміття?",
    "explanation": "Коли він стає недосяжним (unreachable) з кореневих об'єктів.",
    "interviewTip": "Виходу зміної з області видимості не завжди достатньо."
  },
  "js-mm-06": {
    "prompt": "Що таке витік пам'яті (memory leak)?",
    "explanation": "Це пам'ять, яка більше не потрібна застосунку, але залишається досяжною.",
    "interviewTip": "Часто виникає через некоректне використання замикань."
  },
  "js-mm-07": {
    "prompt": "Що є поширеним джерелом витоків пам'яті?",
    "explanation": "Від'єднані (detached) DOM-вузли, на які залишаються посилання в JS.",
    "interviewTip": "Завжди перевіряйте видалення обробників подій."
  },
  "js-mm-08": {
    "prompt": "Чому глобальні змінні небезпечні для пам'яті?",
    "explanation": "Глобальні змінні завжди досяжні, тому вони ніколи не видаляються GC.",
    "interviewTip": "Уникайте випадкового створення глобальних змінних."
  },
  "js-mm-09": {
    "prompt": "Що відбувається під час фази маркування (mark phase)?",
    "explanation": "GC обходить дерево об'єктів, позначаючи всі досяжні вузли.",
    "interviewTip": "Процес починається від коренів (roots)."
  },
  "js-mm-10": {
    "prompt": "Що таке корені збору сміття (GC roots)?",
    "explanation": "Це базові точки відліку: об'єкт window, стеки викликів, замикання.",
    "interviewTip": "З них починається перевірка досяжності пам'яті."
  },
  "js-mm-11": {
    "prompt": "Що таке поколінневий збір сміття (Generational GC)?",
    "explanation": "Стратегія, де нові об'єкти перевіряються частіше, ніж старі.",
    "interviewTip": "Більшість об'єктів «помирають» молодими."
  },
  "js-mm-12": {
    "prompt": "Що таке витік, пов'язаний із замиканням?",
    "explanation": "Замикання може утримувати посилання на великі об'єкти з зовнішньої функції.",
    "interviewTip": "За потреби явно зануляйте (null) великі посилання."
  },
  "js-mm-13": {
    "prompt": "Яка структура даних перешкоджає збору сміття?",
    "explanation": "Сильні посилання (Strong references) утримують об'єкти в пам'яті.",
    "interviewTip": "На відміну від WeakMap, звичайний Map тримає ключі «сильно»."
  },
  "js-mm-14": {
    "prompt": "Навіщо використовувати WeakMap?",
    "explanation": "Він тримає посилання на ключі-об'єкти «слабко», дозволяючи GC їх видаляти.",
    "interviewTip": "Ідеально підходить для кешування та приватних даних."
  },
  "js-mm-15": {
    "prompt": "Чи можуть ключі у WeakMap бути примітивами?",
    "explanation": "Ні, ключами обов'язково мають бути об'єкти.",
    "interviewTip": "Це ж правило стосується і WeakSet."
  },
  "js-mm-16": {
    "prompt": "Що таке фрагментація купи (heap fragmentation)?",
    "explanation": "Це наявність вільних проміжків пам'яті, що сповільнює нові розміщення.",
    "interviewTip": "Процес ущільнення (compaction) вирішує цю проблему."
  },
  "js-mm-17": {
    "prompt": "Що таке «Stop-the-world» у контексті GC?",
    "explanation": "Це повна зупинка виконання JS-коду на час роботи збирача сміття.",
    "interviewTip": "Може спричиняти візуальні лаги (jank)."
  },
  "js-mm-18": {
    "prompt": "Який інструмент допомагає знайти витоки пам'яті?",
    "explanation": "Знімки купи (Heap snapshots) у Chrome DevTools.",
    "interviewTip": "Порівнюйте знімки до та після виконання підозрілих дій."
  },
  "js-mm-19": {
    "prompt": "Що викликає надмірне навантаження на GC?",
    "explanation": "Створення великої кількості короткочасних об'єктів (GC churn).",
    "interviewTip": "Намагайтеся перевикористовувати об'єкти, де це можливо."
  },
  "js-mm-20": {
    "prompt": "Що таке пулінг об'єктів (Object Pooling)?",
    "explanation": "Техніка збереження та повторного використання об'єктів замість створення нових.",
    "interviewTip": "Використовуйте обережно, лише в критичних для швидкодії місцях."
  },
  "js-mm-21": {
    "prompt": "Чому не варто тримати великі масиви в глобальному контексті?",
    "explanation": "GC ніколи не зможе звільнити цю пам'ять, поки масив досяжний.",
    "interviewTip": "Завжди звільняйте посилання після використання."
  },
  "js-mm-22": {
    "prompt": "Що насправді робить присвоєння `null` посиланню?",
    "explanation": "Воно лише видаляє посилання; рішення про видалення об'єкта приймає GC.",
    "interviewTip": "Поширена помилка вважати, що null негайно звільняє пам'ять."
  },
  "js-mm-23": {
    "prompt": "Який API дозволяє створювати слабкі посилання?",
    "explanation": "Клас WeakRef, введений у сучасних стандартах.",
    "interviewTip": "Використовуйте лише у крайніх випадках."
  },
  "js-mm-24": {
    "prompt": "Чому використання WeakRef може бути небезпечним?",
    "explanation": "Через непередбачуваний життєвий цикл об'єкта (залежить від GC).",
    "interviewTip": "Це тема просунутого рівня для Senior розробників."
  },
  "js-mm-25": {
    "prompt": "Найкраще правило для оптимізації пам'яті?",
    "explanation": "Не намагайтеся вгадати — завжди використовуйте профілювання.",
    "interviewTip": "Це «золота» відповідь досвідченого розробника."
  }
}
