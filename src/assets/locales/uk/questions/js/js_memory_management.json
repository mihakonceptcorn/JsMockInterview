{
  "js-mm-01": {
    "prompt": "Де зберігаються примітивні значення?",
    "explanation": "Примітиви зазвичай зберігаються безпосередньо в стеку (stack).",
    "interviewTip": "Об'єкти ж живуть у купі (heap).",
    "options": [
      "Стек (Stack)",
      "Купа (Heap)",
      "Черга викликів (Call queue)",
      "Дерево DOM"
    ]
  },
  "js-mm-02": {
    "prompt": "Де зберігаються об'єкти?",
    "explanation": "Об'єкти розміщуються в купі (heap).",
    "interviewTip": "У стеку зберігаються лише посилання на ці об'єкти.",
    "options": [
      "Купа (Heap)",
      "Стек (Stack)",
      "Стек викликів (Call stack)",
      "Регістри"
    ]
  },
  "js-mm-03": {
    "prompt": "Що таке збір сміття (Garbage Collection)?",
    "explanation": "Це процес автоматичного звільнення пам'яті, яка більше не використовується.",
    "interviewTip": "JavaScript — це мова з автоматичним керуванням пам'яттю.",
    "options": [
      "Автоматичне очищення пам'яті",
      "Ручне звільнення (Manual deallocation)",
      "Стиснення купи (Heap compression)",
      "Скидання стека (Stack reset)"
    ]
  },
  "js-mm-04": {
    "prompt": "Який алгоритм найчастіше використовують движки JS?",
    "explanation": "Сучасні движки використовують варіації алгоритму «Mark-and-Sweep» (познач та прибери).",
    "interviewTip": "V8 використовує поколінневий збір сміття (Generational GC).",
    "options": [
      "Mark-and-sweep",
      "Тільки підрахунок посилань (Reference counting)",
      "Ручний збір сміття (Manual GC)",
      "Тільки Stop-and-copy"
    ]
  },
  "js-mm-05": {
    "prompt": "Коли об'єкт стає доступним для видалення збирачем сміття?",
    "explanation": "Когда він стає недосяжним (unreachable) з кореневих об'єктів.",
    "interviewTip": "Виходу зміної з області видимості не завжди достатньо.",
    "options": [
      "Відсутні досяжні посилання",
      "Змінна вийшла за область видимості",
      "Значення null",
      "Брак пам'яті"
    ]
  },
  "js-mm-06": {
    "prompt": "Що таке витік пам'яті (memory leak)?",
    "explanation": "Це пам'ять, яка більше не потрібна застосунку, але залишається досяжною.",
    "interviewTip": "Часто виникає через некоректне використання замикань.",
    "options": [
      "Невикористана пам'ять не звільняється",
      "Переповнення стека (Stack overflow)",
      "Повільний збір сміття (Slow GC)",
      "Фрагментація купи"
    ]
  },
  "js-mm-07": {
    "prompt": "Що є поширеним джерелом витоків пам'яті?",
    "explanation": "Від'єднані (detached) DOM-вузли, на які залишаються посилання в JS.",
    "interviewTip": "Завжди перевіряйте видалення обробників подій.",
    "options": [
      "Від'єднані DOM-вузли",
      "Локальні змінні",
      "Примітивні значення",
      "Параметри функції"
    ]
  },
  "js-mm-08": {
    "prompt": "Чому глобальні змінні небезпечні для пам'яті?",
    "explanation": "Глобальні змінні завжди досяжні, тому вони ніколи не видаляються GC.",
    "interviewTip": "Уникайте випадкового створення глобальних змінних.",
    "options": [
      "Вони існують протягом усього життя програми",
      "Вони уповільнюють GC",
      "Вони блокують рендеринг",
      "Вони використовують пам'ять стека"
    ]
  },
  "js-mm-09": {
    "prompt": "Що відбувається під час фази маркування (mark phase)?",
    "explanation": "GC обходить дерево об'єктів, позначаючи всі досяжні вузли.",
    "interviewTip": "Процес починається від коренів (roots).",
    "options": [
      "Позначаються досяжні об'єкти",
      "Пам'ять звільняється",
      "Купа ущільнюється (compacted)",
      "Стек очищується"
    ]
  },
  "js-mm-10": {
    "prompt": "Що таке корені збору сміття (GC roots)?",
    "explanation": "Це базові точки відліку: об'єкт window, стеки викликів, замикання.",
    "interviewTip": "З них починається перевірка досяжності пам'яті.",
    "options": [
      "Глобальні об'єкти та посилання в стеку",
      "Об'єкти в купі (Heap objects)",
      "Вузли DOM",
      "Таймери"
    ]
  },
  "js-mm-11": {
    "prompt": "Що таке поколінневий збір сміття (Generational GC)?",
    "explanation": "Стратегія, де нові об'єкти перевіряються частіше, ніж старі.",
    "interviewTip": "Більшість об'єктів «помирають» молодими.",
    "options": [
      "Об'єкти згруповані за віком",
      "Збір сміття за пріоритетом",
      "Ручні покоління",
      "Збір сміття на основі стека"
    ]
  },
  "js-mm-12": {
    "prompt": "Що таке витік, пов'язаний із замиканням?",
    "explanation": "Замикання може утримувати посилання на великі об'єкти з зовнішньої функції.",
    "interviewTip": "За потреби явно зануляйте (null) великі посилання.",
    "options": [
      "Замикання утримує невикористані посилання",
      "Рекурсія функції",
      "Переповнення стека",
      "Асинхронне виконання"
    ]
  },
  "js-mm-13": {
    "prompt": "Яка структура даних перешкоджає збору сміття?",
    "explanation": "Сильні посилання (Strong references) утримують об'єкти в пам'яті.",
    "interviewTip": "На відміну від WeakMap, звичайний Map тримає ключі «сильно».",
    "options": [
      "Сильні посилання (Strong references)",
      "Слабкі посилання (Weak references)",
      "Значення null",
      "Примітиви"
    ]
  },
  "js-mm-14": {
    "prompt": "Навіщо використовувати WeakMap?",
    "explanation": "Він тримає посилання на ключі-об'єкти «слабко», дозволяючи GC їх видаляти.",
    "interviewTip": "Ідеально підходить для кешування та приватних даних.",
    "options": [
      "Уникнення витоків пам'яті",
      "Швидший доступ",
      "Більше функцій",
      "Серіалізація"
    ]
  },
  "js-mm-15": {
    "prompt": "Чи можуть ключі у WeakMap бути примітивами?",
    "explanation": "Ні, ключами обов'язково мають бути об'єкти.",
    "interviewTip": "Це ж правило стосується і WeakSet.",
    "options": ["Ні", "Так", "Тільки рядки", "Тільки числа"]
  },
  "js-mm-16": {
    "prompt": "Що таке фрагментація купи (heap fragmentation)?",
    "explanation": "Це наявність вільних проміжків пам'яті, що сповільнює нові розміщення.",
    "interviewTip": "Процес ущільнення (compaction) вирішує цю проблему.",
    "options": [
      "Розкидані вільні блоки пам'яті",
      "Пошкодження стека (Stack corruption)",
      "Витік пам'яті",
      "Повільний збір сміття"
    ]
  },
  "js-mm-17": {
    "prompt": "Що таке «Stop-the-world» у контексті GC?",
    "explanation": "Це повна зупинка виконання JS-коду на час роботи збирача сміття.",
    "interviewTip": "Може спричиняти візуальні лаги (jank).",
    "options": [
      "Призупиняє виконання JS",
      "Працює у фоновому режимі",
      "Тільки для стека",
      "Тільки для DOM"
    ]
  },
  "js-mm-18": {
    "prompt": "Який інструмент допомагає знайти витоки пам'яті?",
    "explanation": "Знімки купи (Heap snapshots) у Chrome DevTools.",
    "interviewTip": "Порівнюйте знімки до та після виконання підозрілих дій.",
    "options": [
      "Вкладка Memory у Chrome DevTools",
      "Console.log",
      "Вкладка Network",
      "Тільки Lighthouse"
    ]
  },
  "js-mm-19": {
    "prompt": "Що викликає надмірне навантаження на GC?",
    "explanation": "Створення великої кількості короткочасних об'єктів (GC churn).",
    "interviewTip": "Намагайтеся перевикористовувати об'єкти, де це можливо.",
    "options": [
      "Часте виділення пам'яті (allocations)",
      "Асинхронний код",
      "Проміси (Promises)",
      "Event loop"
    ]
  },
  "js-mm-20": {
    "prompt": "Що таке пулінг об'єктів (Object Pooling)?",
    "explanation": "Техніка збереження та повторного використання об'єктів замість створення нових.",
    "interviewTip": "Використовуйте обережно, лише в критичних для швидкодії місцях.",
    "options": [
      "Повторне використання виділених об'єктів",
      "Клонування об'єктів",
      "Заморожування об'єктів",
      "Серіалізація об'єктів"
    ]
  },
  "js-mm-21": {
    "prompt": "Чому не варто тримати великі масиви в глобальному контексті?",
    "explanation": "GC ніколи не зможе звільнити цю пам'ять, поки масив досяжний.",
    "interviewTip": "Завжди звільняйте посилання після використання.",
    "options": [
      "Пам'ять залишається виділеною",
      "Повільніші цикли",
      "Переповнення стека",
      "Проблеми з областю видимості"
    ]
  },
  "js-mm-22": {
    "prompt": "Що насправді робить присвоєння `null` посиланню?",
    "explanation": "Воно лише видаляє посилання; рішення про видалення об'єкта приймає GC.",
    "interviewTip": "Поширена помилка вважати, що null негайно звільняє пам'ять.",
    "options": [
      "Дозволяє GC видалити об'єкт, якщо немає інших посилань",
      "Негайно звільняє пам'ять",
      "Видаляє об'єкт",
      "Ущільнює купу"
    ]
  },
  "js-mm-23": {
    "prompt": "Який API дозволяє створювати слабкі посилання?",
    "explanation": "Клас WeakRef, введений у сучасних стандартах.",
    "interviewTip": "Використовуйте лише у крайніх випадках.",
    "options": ["WeakRef", "Map", "Set", "Object"]
  },
  "js-mm-24": {
    "prompt": "Чому використання WeakRef може бути небезпечним?",
    "explanation": "Через непередбачуваний життєвий цикл об'єкта (залежить від GC).",
    "interviewTip": "Це тема просунутого рівня для Senior розробників.",
    "options": [
      "Об'єкт може зникнути в будь-який момент",
      "Це спричиняє витоки пам'яті",
      "Це блокує роботу GC",
      "Це призводить до збою браузера"
    ]
  },
  "js-mm-25": {
    "prompt": "Найкраще правило для оптимізації пам'яті?",
    "explanation": "Не намагайтеся вгадати — завжди використовуйте профілювання.",
    "interviewTip": "Це «золота» відповідь досвідченого розробника.",
    "options": [
      "Виміряти перед оптимізацією",
      "Уникати об'єктів",
      "Вимкнути GC",
      "Використовувати тільки примітиви"
    ]
  }
}
