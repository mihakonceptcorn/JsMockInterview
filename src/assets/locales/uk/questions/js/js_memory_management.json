{
  "js-mm-01": {
    "prompt": "Де зберігаються примітивні значення?",
    "explanation": "Примітиви зазвичай зберігаються безпосередньо в стеку (stack).",
    "interviewTip": "Об'єкти ж живуть у купі (heap).",
    "options": [
      "Stack",
      "Heap",
      "Call queue",
      "DOM tree"
    ]
  },
  "js-mm-02": {
    "prompt": "Де зберігаються об'єкти?",
    "explanation": "Об'єкти розміщуються в купі (heap).",
    "interviewTip": "У стеку зберігаються лише посилання на ці об'єкти.",
    "options": [
      "Heap",
      "Stack",
      "Call stack",
      "Registers"
    ]
  },
  "js-mm-03": {
    "prompt": "Що таке збір сміття (Garbage Collection)?",
    "explanation": "Це процес автоматичного звільнення пам'яті, яка більше не використовується.",
    "interviewTip": "JavaScript — це мова з автоматичним керуванням пам'яттю.",
    "options": [
      "Automatic memory cleanup",
      "Manual deallocation",
      "Heap compression",
      "Stack reset"
    ]
  },
  "js-mm-04": {
    "prompt": "Який алгоритм найчастіше використовують движки JS?",
    "explanation": "Сучасні движки використовують варіації алгоритму «Mark-and-Sweep» (познач та прибери).",
    "interviewTip": "V8 використовує поколінневий збір сміття (Generational GC).",
    "options": [
      "Mark-and-sweep",
      "Reference counting only",
      "Manual GC",
      "Stop-and-copy only"
    ]
  },
  "js-mm-05": {
    "prompt": "Коли об'єкт стає доступним для видалення збирачем сміття?",
    "explanation": "Коли він стає недосяжним (unreachable) з кореневих об'єктів.",
    "interviewTip": "Виходу зміної з області видимості не завжди достатньо.",
    "options": [
      "No reachable references",
      "Out of scope variable",
      "Null value",
      "Low memory"
    ]
  },
  "js-mm-06": {
    "prompt": "Що таке витік пам'яті (memory leak)?",
    "explanation": "Це пам'ять, яка більше не потрібна застосунку, але залишається досяжною.",
    "interviewTip": "Часто виникає через некоректне використання замикань.",
    "options": [
      "Unused memory not released",
      "Stack overflow",
      "Slow GC",
      "Heap fragmentation"
    ]
  },
  "js-mm-07": {
    "prompt": "Що є поширеним джерелом витоків пам'яті?",
    "explanation": "Від'єднані (detached) DOM-вузли, на які залишаються посилання в JS.",
    "interviewTip": "Завжди перевіряйте видалення обробників подій.",
    "options": [
      "Detached DOM nodes",
      "Local variables",
      "Primitive values",
      "Function parameters"
    ]
  },
  "js-mm-08": {
    "prompt": "Чому глобальні змінні небезпечні для пам'яті?",
    "explanation": "Глобальні змінні завжди досяжні, тому вони ніколи не видаляються GC.",
    "interviewTip": "Уникайте випадкового створення глобальних змінних.",
    "options": [
      "They live for app lifetime",
      "They slow down GC",
      "They block rendering",
      "They use stack memory"
    ]
  },
  "js-mm-09": {
    "prompt": "Що відбувається під час фази маркування (mark phase)?",
    "explanation": "GC обходить дерево об'єктів, позначаючи всі досяжні вузли.",
    "interviewTip": "Процес починається від коренів (roots).",
    "options": [
      "Reachable objects are marked",
      "Memory is freed",
      "Heap is compacted",
      "Stack is cleared"
    ]
  },
  "js-mm-10": {
    "prompt": "Що таке корені збору сміття (GC roots)?",
    "explanation": "Це базові точки відліку: об'єкт window, стеки викликів, замикання.",
    "interviewTip": "З них починається перевірка досяжності пам'яті.",
    "options": [
      "Global objects and stack references",
      "Heap objects",
      "DOM nodes",
      "Timers"
    ]
  },
  "js-mm-11": {
    "prompt": "Що таке поколінневий збір сміття (Generational GC)?",
    "explanation": "Стратегія, де нові об'єкти перевіряються частіше, ніж старі.",
    "interviewTip": "Більшість об'єктів «помирають» молодими.",
    "options": [
      "Objects grouped by age",
      "GC by priority",
      "Manual generations",
      "Stack-based GC"
    ]
  },
  "js-mm-12": {
    "prompt": "Що таке витік, пов'язаний із замиканням?",
    "explanation": "Замикання може утримувати посилання на великі об'єкти з зовнішньої функції.",
    "interviewTip": "За потреби явно зануляйте (null) великі посилання.",
    "options": [
      "Closure holding unused references",
      "Function recursion",
      "Stack overflow",
      "Async execution"
    ]
  },
  "js-mm-13": {
    "prompt": "Яка структура даних перешкоджає збору сміття?",
    "explanation": "Сильні посилання (Strong references) утримують об'єкти в пам'яті.",
    "interviewTip": "На відміну від WeakMap, звичайний Map тримає ключі «сильно».",
    "options": [
      "Strong references",
      "Weak references",
      "Null values",
      "Primitives"
    ]
  },
  "js-mm-14": {
    "prompt": "Навіщо використовувати WeakMap?",
    "explanation": "Він тримає посилання на ключі-об'єкти «слабко», дозволяючи GC їх видаляти.",
    "interviewTip": "Ідеально підходить для кешування та приватних даних.",
    "options": [
      "Avoid memory leaks",
      "Faster access",
      "More features",
      "Serialization"
    ]
  },
  "js-mm-15": {
    "prompt": "Чи можуть ключі у WeakMap бути примітивами?",
    "explanation": "Ні, ключами обов'язково мають бути об'єкти.",
    "interviewTip": "Це ж правило стосується і WeakSet.",
    "options": [
      "No",
      "Yes",
      "Only strings",
      "Only numbers"
    ]
  },
  "js-mm-16": {
    "prompt": "Що таке фрагментація купи (heap fragmentation)?",
    "explanation": "Це наявність вільних проміжків пам'яті, що сповільнює нові розміщення.",
    "interviewTip": "Процес ущільнення (compaction) вирішує цю проблему.",
    "options": [
      "Scattered free memory blocks",
      "Stack corruption",
      "Memory leak",
      "Slow GC"
    ]
  },
  "js-mm-17": {
    "prompt": "Що таке «Stop-the-world» у контексті GC?",
    "explanation": "Це повна зупинка виконання JS-коду на час роботи збирача сміття.",
    "interviewTip": "Може спричиняти візуальні лаги (jank).",
    "options": [
      "Pauses JS execution",
      "Runs in background",
      "Only for stack",
      "Only for DOM"
    ]
  },
  "js-mm-18": {
    "prompt": "Який інструмент допомагає знайти витоки пам'яті?",
    "explanation": "Знімки купи (Heap snapshots) у Chrome DevTools.",
    "interviewTip": "Порівнюйте знімки до та після виконання підозрілих дій.",
    "options": [
      "Chrome DevTools Memory tab",
      "Console.log",
      "Network tab",
      "Lighthouse only"
    ]
  },
  "js-mm-19": {
    "prompt": "Що викликає надмірне навантаження на GC?",
    "explanation": "Створення великої кількості короткочасних об'єктів (GC churn).",
    "interviewTip": "Намагайтеся перевикористовувати об'єкти, де це можливо.",
    "options": [
      "Frequent allocations",
      "Async code",
      "Promises",
      "Event loop"
    ]
  },
  "js-mm-20": {
    "prompt": "Що таке пулінг об'єктів (Object Pooling)?",
    "explanation": "Техніка збереження та повторного використання об'єктів замість створення нових.",
    "interviewTip": "Використовуйте обережно, лише в критичних для швидкодії місцях.",
    "options": [
      "Reusing allocated objects",
      "Cloning objects",
      "Freezing objects",
      "Serializing objects"
    ]
  },
  "js-mm-21": {
    "prompt": "Чому не варто тримати великі масиви в глобальному контексті?",
    "explanation": "GC ніколи не зможе звільнити цю пам'ять, поки масив досяжний.",
    "interviewTip": "Завжди звільняйте посилання після використання.",
    "options": [
      "Memory stays allocated",
      "Slower loops",
      "Stack overflow",
      "Scope issues"
    ]
  },
  "js-mm-22": {
    "prompt": "Що насправді робить присвоєння `null` посиланню?",
    "explanation": "Воно лише видаляє посилання; рішення про видалення об'єкта приймає GC.",
    "interviewTip": "Поширена помилка вважати, що null негайно звільняє пам'ять.",
    "options": [
      "Allows GC if no other refs exist",
      "Immediately frees memory",
      "Deletes object",
      "Compacts heap"
    ]
  },
  "js-mm-23": {
    "prompt": "Який API дозволяє створювати слабкі посилання?",
    "explanation": "Клас WeakRef, введений у сучасних стандартах.",
    "interviewTip": "Використовуйте лише у крайніх випадках.",
    "options": [
      "WeakRef",
      "Map",
      "Set",
      "Object"
    ]
  },
  "js-mm-24": {
    "prompt": "Чому використання WeakRef може бути небезпечним?",
    "explanation": "Через непередбачуваний життєвий цикл об'єкта (залежить від GC).",
    "interviewTip": "Це тема просунутого рівня для Senior розробників.",
    "options": [
      "Object may disappear anytime",
      "It leaks memory",
      "It blocks GC",
      "It crashes browser"
    ]
  },
  "js-mm-25": {
    "prompt": "Найкраще правило для оптимізації пам'яті?",
    "explanation": "Не намагайтеся вгадати — завжди використовуйте профілювання.",
    "interviewTip": "Це «золота» відповідь досвідченого розробника.",
    "options": [
      "Measure before optimizing",
      "Avoid objects",
      "Disable GC",
      "Use primitives only"
    ]
  }
}