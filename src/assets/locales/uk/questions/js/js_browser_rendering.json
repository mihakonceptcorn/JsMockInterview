{
  "js-br-01": {
    "prompt": "Який перший крок у конвеєрі рендерингу?",
    "explanation": "Спочатку HTML аналізується (парситься) і перетворюється на DOM.",
    "interviewTip": "Це початок критичного шляху рендерингу (CRP)."
  },
  "js-br-02": {
    "prompt": "Що створюється в результаті парсингу CSS?",
    "explanation": "CSSOM (CSS Object Model) представляє проаналізовані стилі CSS.",
    "interviewTip": "DOM + CSSOM = Render Tree (Дерево рендерингу)."
  },
  "js-br-03": {
    "prompt": "Що містить дерево рендерингу (Render Tree)?",
    "explanation": "Воно містить лише видимі елементи; приховані вузли виключаються.",
    "interviewTip": "Елементи з display: none пропускаються."
  },
  "js-br-04": {
    "prompt": "Що таке компонування (layout/reflow)?",
    "explanation": "Це крок, на якому браузер обчислює геометрію та положення кожного елемента.",
    "interviewTip": "Це дуже ресурсомістка операція."
  },
  "js-br-05": {
    "prompt": "Що викликає reflow (перекомпонування)?",
    "explanation": "Будь-які зміни геометрії (розмір, положення) вимагають повторного виконання layout.",
    "interviewTip": "Уникайте «layout thrashing» (чергування читання та запису геометрії)."
  },
  "js-br-06": {
    "prompt": "Що таке repaint (перемальовування)?",
    "explanation": "Оновлення лише візуальних аспектів елемента (наприклад, кольору), що не впливають на геометрію.",
    "interviewTip": "Ця операція швидша за reflow."
  },
  "js-br-07": {
    "prompt": "Яка властивість CSS дозволяє уникнути reflow та repaint?",
    "explanation": "Трансформації (transform) обробляються лише на етапі компонування шарів (compositor).",
    "interviewTip": "Ключовий прийом для плавної анімації."
  },
  "js-br-08": {
    "prompt": "Що таке композиція (compositing)?",
    "explanation": "Останній крок перед виведенням на екран, де шари об'єднуються.",
    "interviewTip": "Цей етап зазвичай прискорюється за допомогою GPU."
  },
  "js-br-09": {
    "prompt": "Які властивості зазвичай прискорюються графічним процесором (GPU)?",
    "explanation": "Властивості на кшталт transform та opacity, оскільки вони пропускають етапи layout та paint.",
    "interviewTip": "Дозволяє досягти 60 FPS для анімацій."
  },
  "js-br-10": {
    "prompt": "Що спричиняє «layout thrashing»?",
    "explanation": "Багаторазове примусове виконання синхронного макета всередині циклу.",
    "interviewTip": "Класична помилка продуктивності."
  },
  "js-br-11": {
    "prompt": "Що таке примусовий синхронний макет (forced synchronous layout)?",
    "explanation": "Виникає при читанні геометричних властивостей (наприклад, offsetHeight) одразу після їх зміни.",
    "interviewTip": "Уникайте читання геометрії одразу після запису."
  },
  "js-br-12": {
    "prompt": "Коли виконується requestAnimationFrame?",
    "explanation": "Це колбек, який викликається безпосередньо перед наступним перемальовуванням кадру.",
    "interviewTip": "Використовуйте саме його для створення плавних анімацій."
  },
  "js-br-13": {
    "prompt": "Що таке шар рендерингу (render layer)?",
    "explanation": "Окрема поверхня, що використовується при композиції для оптимізації відмальовування.",
    "interviewTip": "Занадто велика кількість шарів може перевантажити пам'ять."
  },
  "js-br-14": {
    "prompt": "Що змушує браузер винести елемент на власний шар?",
    "explanation": "Такі властивості як will-change підказують браузеру необхідність оптимізації.",
    "interviewTip": "Використовуйте will-change помірно."
  },
  "js-br-15": {
    "prompt": "Що таке критичний шлях рендерингу (Critical Render Path)?",
    "explanation": "Послідовність кроків від отримання HTML до появи перших пікселів на екрані.",
    "interviewTip": "Оптимізуйте його для покращення FCP."
  },
  "js-br-16": {
    "prompt": "Навіщо вбудовувати (inline) критичний CSS?",
    "explanation": "Оскільки зовнішній CSS блокує рендеринг, вбудовування прискорює показ першого контенту.",
    "interviewTip": "Популярний метод оптимізації швидкості."
  },
  "js-br-17": {
    "prompt": "Яка метрика вимірює стабільність макета?",
    "explanation": "CLS (Cumulative Layout Shift) показує, як сильно елементи «стрибають» при завантаженні.",
    "interviewTip": "Одна з основних метрик Web Vitals."
  },
  "js-br-18": {
    "prompt": "Яка метрика найкраще відображає продуктивність рендерингу?",
    "explanation": "LCP (Largest Contentful Paint) вимірює час завантаження найбільшого видимого елемента.",
    "interviewTip": "Метрика, орієнтована на досвід користувача."
  },
  "js-br-19": {
    "prompt": "Що блокує перше відмальовування (First Paint)?",
    "explanation": "CSS має бути повністю проаналізований, перш ніж браузер почне малювати.",
    "interviewTip": "Знову ж таки, працюйте над критичним CSS."
  },
  "js-br-20": {
    "prompt": "Для чого використовується функція «Paint Flashing» у DevTools?",
    "explanation": "Вона підсвічує зони екрана, які перемальовуються в даний момент.",
    "interviewTip": "Допомагає виявити зайві операції малювання в інтерфейсі."
  },
  "js-br-21": {
    "prompt": "Що станеться, якщо JS заблокує основний потік?",
    "explanation": "Рендеринг зупиниться, оскільки браузер не зможе обробити наступний кадр.",
    "interviewTip": "Розбивайте важкі JS-завдання на частини (chunking)."
  },
  "js-br-22": {
    "prompt": "Чому варто уникати занадто великих DOM-дерев?",
    "explanation": "Вартість обчислення макета (layout) зростає пропорційно кількості вузлів.",
    "interviewTip": "Використовуйте віртуалізацію списків для великих даних."
  },
  "js-br-23": {
    "prompt": "Який інструмент дозволяє профілювати рендеринг?",
    "explanation": "Панель Performance у DevTools показує кадри, час малювання та скриптів.",
    "interviewTip": "Вміння читати «flame charts» — важлива навичка для розробника."
  },
  "js-br-24": {
    "prompt": "Який бюджет часу на один кадр при 60 FPS?",
    "explanation": "Приблизно 16.6 мс (1000 мс / 60) на виконання JS та рендерингу.",
    "interviewTip": "Прагніть вкластися в цей ліміт для плавності."
  },
  "js-br-25": {
    "prompt": "Золоте правило оптимізації рендерингу?",
    "explanation": "Оптимізація на основі реальних даних вимірювань, а не припущень.",
    "interviewTip": "Відповідь рівня Senior-розробника."
  }
}
