{
  "cr-01": {
    "prompt": "Що буде відрендерено, якщо 'isLoaded' має значення false?",
    "explanation": "Тернарний оператор — це найпоширеніший спосіб виконання умовного рендерингу типу «або-або» всередині JSX.",
    "interviewTip": "Тернарним операторам надається перевага над інструкціями 'if-else' всередині JSX, оскільки вони є виразами (expressions).",
    "options": [
      "Success!",
      "Loading...",
      "Нічого",
      "Обидва: 'Success!' та 'Loading...'"
    ]
  },
  "cr-02": {
    "prompt": "Яка потенційна «пастка» існує при використанні оператора && з числом 0?",
    "explanation": "У JS вираз '0 && що завгодно' повертає 0. React не рендерить булеві значення, але він *рендерить* число 0.",
    "interviewTip": "Щоб уникнути цього, використовуйте явну перевірку на булеве значення: `{count > 0 && <p>Знайдено елементи</p>}` або тернарний оператор.",
    "options": [
      "Нічого не відрендериться.",
      "В інтерфейсі відрендериться число 0.",
      "Застосунок зламається (crash).",
      "Відрендериться '<p>Items found</p>'."
    ]
  },
  "cr-03": {
    "prompt": "Як змусити React нічого не рендерити на основі умови?",
    "explanation": "Повернення 'null' — це стандартний спосіб сказати React, щоб не виводив результат для компонента або частини інтерфейсу.",
    "interviewTip": "Повернення null все одно запускає хуки життєвого циклу компонента; воно просто не створює DOM-вузлів.",
    "options": [
      "Повернути порожній рядок \"\".",
      "Повернути null.",
      "Повернути undefined.",
      "Усі перелічені варіанти."
    ]
  },
  "cr-04": {
    "prompt": "Які з цих способів є валідними для умовного рендерингу JSX?",
    "explanation": "У React немає директив на кшталт v-if. Він покладається на стандартну логіку JavaScript.",
    "interviewTip": "Для складних умов використання допоміжної функції або змінної поза межами інструкції return часто робить код чистішим.",
    "options": [
      "Використання інструкції switch поза return.",
      "Використання тернарного оператора всередині фігурних дужок.",
      "Використання атрибута v-if на div.",
      "Використання логічного && для логіки 'якщо-це-то-те'."
    ]
  },
  "cr-05": {
    "prompt": "Яким буде результат наступного компонента?",
    "explanation": "Це називається 'Early Return' (раннє повернення). Воно запобігає виконанню решти логіки компонента, якщо умова не виконана.",
    "interviewTip": "Ранні повернення чудово підходять для обробки станів завантаження або відсутності даних.",
    "options": [
      "Відрендерить 'Welcome, undefined', якщо користувача немає.",
      "Нічого не відрендерить, якщо користувача немає.",
      "Застосунок зламається, якщо користувача немає.",
      "Відрендерить порожній тег h1."
    ]
  },
  "cr-06": {
    "prompt": "Для чого використовується логічний оператор «АБО» (||) в умовному рендерингу?",
    "explanation": "Оператор || ідеально підходить для відображення тексту за замовчуванням або компонентів-заглушок, коли дані відсутні.",
    "interviewTip": "Пам'ятайте: якщо userName — це порожній рядок \"\", оператор || також спрацює і покаже запасний варіант.",
    "options": [
      "Щоб надати fallback/значення за замовчуванням, якщо перше значення є falsy.",
      "Щоб перевірити, чи обидва значення є true.",
      "Щоб приховати div, якщо userName існує.",
      "Щоб пройти циклом по списку імен."
    ]
  },
  "cr-07": {
    "prompt": "Визначте результат цього коду:",
    "explanation": "Тернарні оператори можна використовувати всередині значень атрибутів для умовного застосування CSS-класів або інших пропсів.",
    "interviewTip": "Це основний спосіб обробки динамічних стилів у базовому React.",
    "options": [
      "div з класом 'admin-theme'.",
      "div з класом 'user-theme'.",
      "Синтаксична помилка.",
      "div з обома класами."
    ]
  },
  "cr-08": {
    "prompt": "Чому не можна використовувати цикл 'for' або інструкцію 'if' безпосередньо всередині return у JSX?",
    "explanation": "JSX трансформується у виклики React.createElement(). Аргументами функції мають бути вирази (значення), а не інструкції (statements).",
    "interviewTip": "Вирази обчислюються в значення (як 2+2); інструкції виконують дію (як if або for).",
    "options": [
      "React їх не підтримує.",
      "JSX — це просто набір викликів функцій, а ви не можете помістити statements у список аргументів.",
      "Це зробило б Virtual DOM занадто повільним.",
      "Браузери не підтримують цикли всередині HTML."
    ]
  },
  "cr-09": {
    "prompt": "Що буде відрендерено в даному випадку?",
    "explanation": "Оскільки items.length дорівнює 0, вираз обчислюється в 0. Проте в цьому специфічному контексті 0 && ... повертає 0, і React виведе цифру 0 на екран.",
    "interviewTip": "Завжди переконуйтеся, що ліва частина вашого && є справжнім булевим значенням, якщо хочете уникнути виводу цифри 0.",
    "options": [
      "<li>Show items</li>",
      "Порожній <ul>.",
      "Число 0.",
      "Список із значенням false."
    ]
  },
  "rtk-10": {
    "prompt": "Як обробити стани 'Завантаження', 'Помилка' та 'Дані' в одному компоненті?",
    "explanation": "Хоча вкладені тернарні оператори працюють, їх важко читати. Ранні повернення для станів помилки та завантаження виглядають набагато чистіше.",
    "interviewTip": "Патерн: `if (loading) return <Spinner />; if (error) return <Error />; return <Data />;`",
    "options": [
      "За допомогою вкладених тернарних операторів.",
      "Повертаючи різні блоки JSX за допомогою early returns на основі змінних статусу.",
      "Використовуючи хук useEffect для приховування елементів.",
      "Створивши три окремі застосунки."
    ]
  },
  "cr-11": {
    "prompt": "Яка мета оператора «нульового злиття» (??) у React?",
    "explanation": "Це безпечніше, ніж ||, коли 0 є валідним значенням, яке ви хочете відобразити.",
    "interviewTip": "Використовуйте ??, якщо хочете розглядати 0 та порожні рядки як реальні дані, а не як відсутність значення.",
    "options": [
      "Він працює як ||, але спрацьовує лише для null або undefined (не для 0 або \"\").",
      "Він перевіряє, чи два рядки однакові.",
      "Він видаляє змінну, якщо вона null.",
      "Це скорочення для тернарного оператора."
    ]
  },
  "cr-12": {
    "prompt": "Проаналізуйте результат:",
    "explanation": "Хоча React ігнорує «чисті» булеві значення, перетворення їх на рядок змусить їх відобразитися на екрані.",
    "interviewTip": "Це корисний трюк для налагодження (debugging), щоб побачити стан булевих змінних прямо в інтерфейсі.",
    "options": [
      "Нічого не рендериться.",
      "Рендериться 'false' як текст.",
      "Рендериться 'undefined'.",
      "Застосунок ламається."
    ]
  },
  "cr-13": {
    "prompt": "Як умовно застосувати кілька пропсів одночасно за допомогою spread-оператора?",
    "explanation": "Розгортання порожнього об'єкта {} не додає жодних пропсів, тоді як розгортання об'єкта з ключами застосовує їх динамічно.",
    "interviewTip": "Це чистий спосіб передачі пропсів «тільки для адміністратора» або спеціальних конфігурацій.",
    "options": [
      "Код вище є правильним.",
      "Ви повинні передавати пропси індивідуально.",
      "Spread не можна використовувати всередині return.",
      "isAdmin має бути рядком."
    ]
  },
  "cr-14": {
    "prompt": "Що відбувається, коли компонент демонтується (unmounts) через те, що він більше не рендериться за умовою?",
    "explanation": "Демонтування — це повне знищення екземпляра компонента та очищення його стану.",
    "interviewTip": "Якщо вам потрібно зберегти стан «живим», підніміть його до батьківського компонента або приховайте компонент через CSS (display: none) замість видалення.",
    "options": [
      "Його локальний стан (local state) знищується.",
      "Запускається його функція очищення (cleanup function) у useEffect.",
      "Він залишається у Virtual DOM, але прихований у real DOM.",
      "Його стан зберігається в батьківському компоненті."
    ]
  },
  "cr-15": {
    "prompt": "Який підхід кращий для продуктивності, якщо перемикання відбувається дуже часто?",
    "explanation": "Умовний рендеринг (&&) щоразу знищує та створює компонент заново. CSS-властивість 'display' зберігає його в DOM, що робить перемикання швидшим ціною початкової пам'яті.",
    "interviewTip": "Використовуйте приховування через CSS для компонентів із важкою логікою монтування, які часто перемикаються.",
    "options": [
      "{isVisible && <LargeComponent />}",
      "<div style={{ display: isVisible ? 'block' : 'none' }}><LargeComponent /></div>",
      "Вони однакові за продуктивністю.",
      "Використання окремого route."
    ]
  }
}
