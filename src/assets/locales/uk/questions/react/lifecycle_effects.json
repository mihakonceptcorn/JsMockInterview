{
  "le-01": {
    "prompt": "Коли за замовчуванням виконується код всередині блоку useEffect, якщо масив залежностей не вказано?",
    "explanation": "Без масиву залежностей useEffect запускається після кожного циклу рендерингу. Зазвичай цього уникають, щоб не створювати проблем із продуктивністю.",
    "interviewTip": "Завжди свідомо ставтеся до масиву залежностей, щоб уникнути нескінченних циклів.",
    "options": [
      "Тільки коли компонент демонтується (unmounts).",
      "Після кожного окремого рендерингу компонента.",
      "Тільки після першого рендерингу (mount).",
      "Тільки коли змінюється стан (state)."
    ]
  },
  "le-02": {
    "prompt": "Як гарантувати, що useEffect запуститься лише один раз, подібно до 'componentDidMount'?",
    "explanation": "Порожній масив залежностей [] підказує React, що ефект не залежить від жодних значень із пропсів або стану, тому його ніколи не потрібно запускати повторно.",
    "interviewTip": "Навіть із порожнім масивом, у режимі 'Strict Mode' під час розробки в React 18, ефекти можуть запускатися двічі, щоб допомогти вам знайти помилки в очищенні.",
    "options": [
      "Передати undefined.",
      "Передати значення null.",
      "Передати порожній масив [].",
      "Пропустити другий аргумент."
    ]
  },
  "le-03": {
    "prompt": "Яка мета функції, яку повертає хук useEffect?",
    "explanation": "Функція очищення (cleanup function) необхідна для запобігання витокам пам'яті (наприклад, видалення інтервалів, слухачів подій або активних підписок на API).",
    "interviewTip": "Завжди очищуйте побічні ефекти, які продовжують існувати поза життєвим циклом компонента.",
    "options": [
      "Для ініціалізації наступного рендерингу.",
      "Для виконання очищення перед демонтуванням компонента або перед повторним запуском ефекту.",
      "Для запуску повторного рендерингу батьківського компонента.",
      "Для обробки помилок всередині ефекту."
    ]
  },
  "le-04": {
    "prompt": "Які з наведених варіантів є валідними причинами для використання хука useEffect?",
    "explanation": "Обчислення значень на основі пропсів слід робити під час рендерингу (або через useMemo). Ефекти призначені саме для «побічних ефектів», які взаємодіють із чимось за межами екосистеми React.",
    "interviewTip": "Якщо ви можете обчислити щось під час рендерингу, вам не потрібен useEffect.",
    "options": [
      "Оновлення заголовка документа (document title) на основі стану.",
      "Обчислення значення з двох пропсів (наприклад, fullName = firstName + lastName).",
      "Отримання даних із зовнішнього API (fetching).",
      "Запуск або зупинка таймера/інтервалу."
    ]
  },
  "le-05": {
    "prompt": "Що станеться, якщо оновити змінну стану всередині useEffect без масиву залежностей?",
    "explanation": "Рендеринг запустить ефект, ефект оновить стан, оновлення стану запустить рендеринг — і цей цикл повторюватиметься нескінченно.",
    "interviewTip": "Якщо під час розробки ви чуєте, як розганяються кулери вашого процесора, перевірте, чи не забули ви масив залежностей у useEffect, який викликає функцію встановлення стану.",
    "options": [
      "Лічильник збільшиться один раз і зупиниться.",
      "Це спричинить нескінченний цикл повторних рендерингів (infinite loop).",
      "React видасть помилку 'AutoLoopError'.",
      "Інтерфейс буде плавно оновлюватися при 60fps."
    ]
  },
  "le-06": {
    "prompt": "Проаналізуйте масив залежностей нижче. Коли цей ефект запуститься повторно?",
    "explanation": "React виконує поверхневе порівняння (Object.is) для кожного елемента в масиві. Якщо будь-який елемент змінився між рендерами, ефект запускається знову.",
    "interviewTip": "Будьте обережні при передачі об'єктів або масивів у масив залежностей, оскільки нові посилання (references) викликатимуть ефект щоразу.",
    "options": [
      "При кожному рендерингу.",
      "Тільки коли змінюється 'userId' (перевірка рівності за посиланням).",
      "Тільки коли 'fetchData' викликається вручну.",
      "При кожній події кліку."
    ]
  },
  "le-07": {
    "prompt": "Що буде виведено в консоль, коли компонент демонтується (unmounts)?",
    "explanation": "Функція очищення (B) запускається лише тоді, коли компонент видаляється з DOM, якщо масив залежностей порожній.",
    "interviewTip": "Якби масив мав залежності, 'B' запускався б перед кожним повторним запуском 'A' ТА під час демонтування.",
    "options": ["A", "B", "Спочатку A, потім B", "Нічого (консоль очищається)"]
  },
  "le-08": {
    "prompt": "Як React обробляє кілька хуків useEffect в одному компоненті?",
    "explanation": "React покладається на порядок виклику хуків для підтримки стану. Вони виконуються послідовно після того, як результат рендерингу відобразиться на екрані.",
    "interviewTip": "Використовуйте кілька ефектів, щоб розділити непов'язану логіку (наприклад, один для отримання даних, інший для слухача подій).",
    "options": [
      "Виконується тільки перший з них.",
      "Виконує їх у тому порядку, в якому вони визначені.",
      "Виконує їх паралельно (у випадковому порядку).",
      "Об'єднує їх в один єдиний ефект."
    ]
  },
  "le-09": {
    "prompt": "Чому важливо включати всі реактивні значення (пропси, стан), що використовуються всередині ефекту, до масиву залежностей?",
    "explanation": "Якщо значення використовується всередині, але не вказане в залежностях, функція ефекту «пам'ятатиме» версію цього значення з моменту свого останнього створення, що призведе до багів.",
    "interviewTip": "'eslint-plugin-react-hooks' — ваш найкращий друг для автоматичного виявлення відсутніх залежностей.",
    "options": [
      "Щоб уникнути замикань на застарілих даних (stale closures), де ефект використовує старі значення з попереднього рендерингу.",
      "Щоб запобігти демонтуванню компонента.",
      "Щоб прискорити процес порівняння (diffing) у Virtual DOM.",
      "Це просто пропозиція лінтера, а не сувора необхідність."
    ]
  },
  "le-10": {
    "prompt": "Який порядок «життєвого циклу ефекту» при зміні залежностей?",
    "explanation": "React спочатку очищує ефект попереднього рендеру, а потім застосовує новий, щоб побічні ефекти не накладалися один на одного.",
    "interviewTip": "Саме тому очищення підписки перед початком нової запобігає появі дублікатів слухачів подій.",
    "options": [
      "Запускається новий ефект -> Запускається стара функція очищення.",
      "Запускається стара функція очищення -> Запускається новий ефект.",
      "Вони запускаються одночасно.",
      "Очищення запускається тільки при демонтуванні."
    ]
  },
  "le-11": {
    "prompt": "Що станеться, якщо повернути рядок замість функції з useEffect?",
    "explanation": "useEffect очікує, що результатом буде або функція (для очищення), або нічого (undefined). Повернення будьчого іншого є помилкою.",
    "interviewTip": "Повернення асинхронної функції — поширена помилка, оскільки асинхронні функції повертають Promise, а не функцію очищення.",
    "options": [
      "React виведе 'Cleanup' у консоль.",
      "React проігнорує це.",
      "React видасть попередження або помилку, оскільки очікує функцію або undefined.",
      "Це стане новим станом (state)."
    ]
  },
  "le-12": {
    "prompt": "Який хук використовується для побічних ефектів, що мають відбутися синхронно *перед* тим, як браузер відмалює екран?",
    "explanation": "useLayoutEffect запускається в той самий час, що й старий 'componentDidMount' — після мутацій DOM, але до того, як користувач їх побачить. Корисно для вимірювання DOM-елементів.",
    "interviewTip": "Надавайте перевагу useEffect у 99% випадків, щоб не блокувати візуальні оновлення.",
    "options": [
      "useEffect",
      "useLayoutEffect",
      "useSyncEffect",
      "useBeforeRender"
    ]
  },
  "le-13": {
    "prompt": "Як правильно обробляти асинхронну функцію всередині useEffect?",
    "explanation": "Ви не можете зробити сам колбек ефекту асинхронним, бо він поверне Promise замість функції очищення. Ви повинні визначити асинхронну функцію всередині ефекту.",
    "interviewTip": "Визначення функції всередині ефекту також полегшує обробку скасування (наприклад, через AbortController).",
    "options": [
      "Наведений вище код — це правильний спосіб.",
      "Зробити весь ефект асинхронним: useEffect(async () => ...).",
      "Використовувати тільки .then(), async/await заборонено.",
      "Викликати асинхронну функцію за межами компонента."
    ]
  },
  "le-14": {
    "prompt": "Що таке фаза «монтування» (Mounting) у React?",
    "explanation": "Монтування — це початок життя компонента в DOM.",
    "interviewTip": "useEffect із [] — найпоширеніший спосіб реалізації логіки 'onMount'.",
    "options": [
      "Коли компонент оновлюється новими пропсами.",
      "Коли компонент створюється та вставляється в DOM.",
      "Коли компонент видаляється з екрана.",
      "Коли користувач натискає на компонент."
    ]
  },
  "le-15": {
    "prompt": "Що з цього викличе повторний запуск ефекту з [data] у якості залежності?",
    "explanation": "React використовує поверхневу рівність. Новий літерал об'єкта `{}` — це завжди нове посилання, навіть якщо властивості виглядають однаково.",
    "interviewTip": "Саме тому ми використовуємо розгортання: `setData({...data})`.",
    "options": [
      "setData({ count: 0 }) // Нове посилання на об'єкт.",
      "data.count = 1; setData(data); // Те саме посилання на об'єкт.",
      "setData(prev => ({ ...prev, count: 1 })) // Нове посилання на об'єкт.",
      "Виклик setData з тим самим рядковим значенням 'hello', якщо data було 'hello'."
    ]
  },
  "le-16": {
    "prompt": "Що буде виведено в консоль, коли залежність 'count' змінюється з 1 на 2?",
    "explanation": "Коли залежності змінюються, React спочатку запускає очищення попереднього ефекту, а потім виконує новий ефект.",
    "interviewTip": "Це гарантує, що «старий» світ очищено до того, як почнеться «новий».",
    "options": [
      "Effect",
      "Спочатку Cleanup, потім Effect",
      "Спочатку Effect, потім Cleanup",
      "Cleanup"
    ]
  },
  "le-17": {
    "prompt": "Чи безпечно не вказувати функцію в масиві залежностей, якщо вона визначена всередині компонента?",
    "explanation": "У JS `function a(){}` !== `function a(){}`, якщо вони створені в різних циклах рендерингу. Використовуйте `useCallback`, щоб зберегти стабільність посилань на функції.",
    "interviewTip": "Перенесення функції *всередину* useEffect часто є найпростішим виправленням.",
    "options": [
      "Так, функції ніколи не змінюються.",
      "Ні, функції перестворюються при кожному рендерингу і будуть тригерити ефект щоразу, якщо їх не мемоїзувати.",
      "Тільки якщо функція не використовує стан (state).",
      "Так, React ігнорує функції в залежностях."
    ]
  }
}
