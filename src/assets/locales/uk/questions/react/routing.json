{
  "rt-01": {
    "prompt": "Який компонент використовується для визначення зв'язку між шляхом URL та компонентом React?",
    "explanation": "<Route> — це основний будівельний блок. Він рендерить свій елемент лише тоді, коли поточний URL збігається з пропсом 'path'.",
    "interviewTip": "У React Router v6 синтаксис змінився на <Route path='/...' element={<MyComponent />} />."
  },
  "rt-02": {
    "prompt": "Як програмно перейти на нову сторінку у функціональному компоненті (наприклад, після відправки форми)?",
    "explanation": "Хук 'useNavigate' повертає функцію, яка дозволяє змінювати URL без повного перезавантаження сторінки.",
    "interviewTip": "Використовуйте 'navigate('/path', { replace: true })', якщо хочете замінити поточний запис у стеку історії замість додавання нового."
  },
  "rt-03": {
    "prompt": "Яка основна різниця між стандартним тегом <a> та тегом <Link> з React Router?",
    "explanation": "Теги <a> змушують браузер оновити всю сторінку. Теги <Link> використовують History API для оновлення URL та перерендерингу лише необхідних компонентів.",
    "interviewTip": "Використання <a> для внутрішньої навігації руйнує досвід «односторінкового застосунку» (SPA) і скидає стан програми."
  },
  "rt-04": {
    "prompt": "Як отримати доступ до динамічних параметрів з URL (наприклад, 'id' у шляху '/users/:id')?",
    "explanation": "Хук 'useParams' повертає об'єкт із парами ключ/значення параметрів URL, визначених у шляху маршруту.",
    "interviewTip": "Завжди перевіряйте, щоб назва змінної при деструктуризації збігалася з назвою плейсхолдера в шляху Route."
  },
  "rt-05": {
    "prompt": "Який із цих компонентів має огортати весь ваш застосунок для ввімкнення функціональності маршрутизації?",
    "explanation": "BrowserRouter є найпоширенішим (використовує «чисті» URL-адреси), тоді як HashRouter використовує фрагмент # для сумісності зі старими серверами або статичним хостингом.",
    "interviewTip": "Більшість сучасних застосунків використовують BrowserRouter для створення SEO-дружніх посилань."
  },
  "rt-06": {
    "prompt": "Яке призначення компонента <Outlet /> у React Router v6?",
    "explanation": "Outlet використовується в елементі батьківського маршруту, щоб вказати місце, де мають рендеритися елементи дочірніх маршрутів.",
    "interviewTip": "Це ключ до створення спільних макетів (наприклад, постійної бічної панелі або навбара)."
  },
  "rt-07": {
    "prompt": "Як визначити маршрут '404 Not Found' у React Router v6?",
    "explanation": "Шлях '*' (wildcard) діє як універсальний маркер, який відповідає будь-якому URL, що не збігся з попередніми маршрутами.",
    "interviewTip": "Розміщуйте маршрут із зірочкою в самому кінці вашого списку <Routes>."
  },
  "rt-08": {
    "prompt": "Що повертає хук 'useLocation'?",
    "explanation": "useLocation надає доступ до об'єкта 'location', який корисний для відстеження переглядів сторінок або читання рядків запиту (?query=abc).",
    "interviewTip": "Ви можете використовувати 'location.state' для передачі прихованих даних між маршрутами, які не відображаються в URL."
  },
  "rt-09": {
    "prompt": "Як можна передати параметри запиту (наприклад, ?sort=asc) та прочитати їх у компоненті?",
    "explanation": "useSearchParams — це зручний для React хук для керування рядками запиту. Ви також можете вручну розпарсити location.search.",
    "interviewTip": "Параметри запиту чудово підходять для станів інтерфейсу, якими можна поділитися через посилання, як-от фільтри або умови пошуку."
  },
  "rt-10": {
    "prompt": "Що станеться, якщо у вас є кілька маршрутів, які відповідають поточному URL у React Router v6?",
    "explanation": "На відміну від v5, де обирався перший збіг (що вимагало 'exact'), v6 розумніша і автоматично обчислює найбільш специфічний збіг.",
    "interviewTip": "Це означає, що порядок маршрутів у v6 має менше значення, ніж у попередніх версіях."
  },
  "rt-11": {
    "prompt": "Як реалізувати перенаправлення (Redirect) після виходу користувача в v6?",
    "explanation": "Компонент <Navigate /> — це декларативний спосіб виконати перенаправлення під час рендерингу.",
    "interviewTip": "Використовуйте це для «захищених маршрутів» (Protected Routes), де ви перевіряєте автентифікацію перед показом сторінки."
  },
  "rt-12": {
    "prompt": "Проаналізуйте код. Яким буде URL після натискання на 'Details'?",
    "explanation": "Посилання без початкового слеша є відносними щодо поточного шляху. Оскільки ми на /products, додавання 123 дасть /products/123.",
    "interviewTip": "Використовуйте абсолютні шляхи (що починаються з /), якщо хочете перейти від кореня сайту."
  }
}
