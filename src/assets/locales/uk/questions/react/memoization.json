{
  "mem-01": {
    "prompt": "Яка основна різниця між useMemo та useCallback?",
    "explanation": "useMemo виконує функцію та запам'ятовує повернуте значення. useCallback повертає саму функцію, щоб її посилання залишалося стабільним між рендерами.",
    "interviewTip": "Запам'ятайте: useCallback(fn, deps) — це, по суті, те саме, що й useMemo(() => fn, deps).",
    "options": [
      "useMemo для класових компонентів; useCallback для функціональних.",
      "useMemo кешує результат виконання функції; useCallback кешує саме визначення функції.",
      "useCallback працює швидше за useMemo.",
      "useMemo тригерить повторний рендеринг; useCallback запобігає йому."
    ]
  },
  "mem-02": {
    "prompt": "Проаналізуйте код. Скільки разів буде виведено 'Calculating...', якщо компонент перерендериться, але 'count' залишиться незмінним?",
    "explanation": "Оскільки 'count' не змінився, useMemo повертає закешоване значення і пропускає повторне виконання функції.",
    "interviewTip": "Це ідеально підходить для уникнення «важкої» логіки (наприклад, сортування великих масивів) при кожному рендері.",
    "options": [
      "Один раз (тільки під час початкового рендерингу).",
      "Нуль разів.",
      "При кожному окремому перерендерингу.",
      "Щоразу, коли рендериться батьківський компонент."
    ]
  },
  "mem-03": {
    "prompt": "Що робить React.memo, коли ним огортають компонент?",
    "explanation": "React.memo — це компонент вищого порядку (HOC), який виконує поверхневе порівняння пропсів. Якщо вони такі ж, як минулого разу, React пропускає рендеринг цього компонента.",
    "interviewTip": "За замовчуванням React перерендерить усіх дітей, коли рендериться батько. React.memo дозволяє відмовитися від цієї поведінки.",
    "options": [
      "Автоматично зберігає стан компонента в базу даних.",
      "Запобігає повторному рендерингу компонента, якщо його пропси не змінилися.",
      "Робить компонент невидимим, поки він повністю не завантажиться.",
      "Дозволяє компоненту працювати в обхід Virtual DOM."
    ]
  },
  "mem-04": {
    "prompt": "Який із цих сценаріїв може зламати мемоїзацію (спричинивши неочікуваний перерендер)?",
    "explanation": "У JS `{} !== {}` та `()=>{} !== ()=>{} `. Вони створюють нові посилання при кожному рендері, через що React.memo вважає, що пропси змінилися.",
    "interviewTip": "Щоб виправити це, використовуйте useMemo для об'єктів та useCallback для функцій.",
    "options": [
      "Передача нового літерала об'єкта як пропса: <Child data={{}} />.",
      "Передача числового пропса: <Child count={5} />.",
      "Передача інлайнової стрілочної функції: <Child onClick={() => {}} />.",
      "Передача рядкового пропса: <Child name='Alice' />."
    ]
  },
  "mem-05": {
    "prompt": "Що таке 'Referential Equality' (посилальна рівність) у контексті оптимізації React?",
    "explanation": "React використовує поверхневу рівність (Object.is) для пропсів та масивів залежностей. Якщо посилання змінюється, оптимізація не спрацьовує.",
    "interviewTip": "Ось чому стабільні посилання (через хуки) є основою продуктивності React.",
    "options": [
      "Коли дві змінні мають однакові рядкові імена.",
      "Коли React перевіряє, чи вказують дві змінні на одну й ту саму адресу в пам'яті.",
      "Коли HTML-структура двох компонентів збігається.",
      "Коли два компоненти мають однаковий пропс key."
    ]
  },
  "mem-06": {
    "prompt": "Чому наступний 'useCallback' є проблематичним?",
    "explanation": "Порожній масив залежностей каже React ніколи не оновлювати посилання на функцію. Вона назавжди «запам'ятовує» версію 'text' з найпершого рендеру.",
    "interviewTip": "Завжди включайте кожне реактивне значення, що використовується всередині хука, до масиву залежностей.",
    "options": [
      "Це спричинить нескінченний цикл.",
      "Він завжди буде логувати значення 'text' з найпершого рендерингу (Stale Closure).",
      "Компонент зламається (crash).",
      "useCallback не може виводити дані в консоль."
    ]
  },
  "mem-07": {
    "prompt": "Коли НЕ варто використовувати useMemo або useCallback?",
    "explanation": "Мемоїзація має свою ціну (пам'ять та час на порівняння). Якщо логіка проста, витрати на роботу хука можуть бути більшими за користь.",
    "interviewTip": "Не оптимізуйте передчасно. Спочатку профілюйте додаток, щоб побачити, де насправді є вузькі місця.",
    "options": [
      "У малих компонентах із простою логікою.",
      "При передачі пропсів мемоїзованому дочірньому компоненту.",
      "При виконанні високовартісної фільтрації масивів.",
      "Коли масив залежностей дуже великий."
    ]
  },
  "mem-08": {
    "prompt": "Визначте результат цього компонента після перерендерингу:",
    "explanation": "Навіть якщо значення однакові, `[1,2,3] !== [1,2,3]` у JS. Нове посилання ініціює перерендер.",
    "interviewTip": "Винесіть статичні дані за межі компонента або огорніть їх у useMemo.",
    "options": [
      "MemoizedChild не буде перерендерено, бо вміст масиву ідентичний.",
      "MemoizedChild буде перерендерено, бо 'data' — це нове посилання на масив кожного разу.",
      "React видасть помилку.",
      "Перерендериться тільки перший елемент у списку."
    ]
  },
  "mem-09": {
    "prompt": "Що дозволяє робити другий аргумент React.memo(Component, arePropsEqual)?",
    "explanation": "За замовчуванням React.memo робить поверхневу перевірку. Ви можете надати власну функцію для глибокого порівняння або ігнорування конкретних пропсів.",
    "interviewTip": "Будьте обережні: глибоке порівняння може бути повільнішим, ніж сам перерендер!",
    "options": [
      "Дозволяє вручну визначити логіку порівняння пропсів.",
      "Встановлює час життя (time-to-live) для кешу.",
      "Дозволяє передати кастомний key компоненту.",
      "Дозволяє вирішити, які зміни стану ігнорувати."
    ]
  },
  "mem-10": {
    "prompt": "Які з цих хуків залежать від стабільності посилань для ефективної роботи?",
    "explanation": "useEffect перезапускається, якщо посилання змінюється. Споживачі Context перерендериться, якщо значення провайдера (часто об'єкт) є новим посиланням.",
    "interviewTip": "Стабільність посилань — це «місток», який робить інші хуки ефективними.",
    "options": [
      "useEffect (коли функції/об'єкти знаходяться в масиві залежностей).",
      "useState.",
      "useContext (щоб уникнути перерендерингу всіх споживачів).",
      "useRef."
    ]
  },
  "mem-11": {
    "prompt": "Як мемоїзувати важкі обчислення, що залежать від 'a' та 'b'?",
    "explanation": "useMemo приймає функцію, яка повертає значення, яке ви хочете закешувати.",
    "interviewTip": "Функція всередині useMemo має бути «чистою» — вона не повинна мати побічних ефектів.",
    "options": [
      "const val = useMemo(calculate(a, b), [a, b]);",
      "const val = useMemo(() => calculate(a, b), [a, b]);",
      "const val = useCallback(() => calculate(a, b), [a, b]);",
      "const val = React.memo(calculate(a, b));"
    ]
  },
  "mem-12": {
    "prompt": "Яким буде результат використання хука всередині useMemo?",
    "explanation": "Хуки повинні викликатися на верхньому рівні вашого компонента. Ви не можете вкладати хуки в useMemo, useEffect або будь-яку іншу функцію.",
    "interviewTip": "Це відповідає вимогам «Правил хуків» щодо порядку їх виклику.",
    "options": [
      "Це створює локальний стан для мемоїзованого значення.",
      "Це невалідно; хуки не можна викликати всередині useMemo.",
      "Це працює тільки в React 18.",
      "Це повертає функцію-сеттер."
    ]
  }
}
