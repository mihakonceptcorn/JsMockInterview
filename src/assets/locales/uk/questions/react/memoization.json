{
  "mem-01": {
    "prompt": "Яка основна різниця між useMemo та useCallback?",
    "explanation": "useMemo виконує функцію та запам'ятовує повернуте значення. useCallback повертає саму функцію, щоб її посилання залишалося стабільним між рендерами.",
    "interviewTip": "Запам'ятайте: useCallback(fn, deps) — це, по суті, те саме, що й useMemo(() => fn, deps).",
    "options": [
      "useMemo is for Class components; useCallback is for Functional components.",
      "useMemo caches the result of a function; useCallback caches the function definition itself.",
      "useCallback is faster than useMemo.",
      "useMemo triggers a re-render; useCallback prevents it."
    ]
  },
  "mem-02": {
    "prompt": "Проаналізуйте код. Скільки разів буде виведено 'Calculating...', якщо компонент перерендериться, але 'count' залишиться незмінним?",
    "explanation": "Оскільки 'count' не змінився, useMemo повертає закешоване значення і пропускає повторне виконання функції.",
    "interviewTip": "Це ідеально підходить для уникнення «важкої» логіки (наприклад, сортування великих масивів) при кожному рендері.",
    "options": [
      "Once (only on the initial render).",
      "Zero times.",
      "On every single re-render.",
      "Every time the parent component renders."
    ]
  },
  "mem-03": {
    "prompt": "Що робить React.memo, коли ним огортають компонент?",
    "explanation": "React.memo — це компонент вищого порядку (HOC), який виконує поверхневе порівняння пропсів. Якщо вони такі ж, як минулого разу, React пропускає рендеринг цього компонента.",
    "interviewTip": "За замовчуванням React перерендерить усіх дітей, коли рендериться батько. React.memo дозволяє відмовитися від цієї поведінки.",
    "options": [
      "It automatically saves the component's state to a database.",
      "It prevents the component from re-rendering if its props have not changed.",
      "It makes the component invisible until it is fully loaded.",
      "It allows the component to bypass the Virtual DOM."
    ]
  },
  "mem-04": {
    "prompt": "Який із цих сценаріїв може зламати мемоїзацію (спричинивши неочікуваний перерендер)?",
    "explanation": "У JS `{} !== {}` та `()=>{} !== ()=>{} `. Вони створюють нові посилання при кожному рендері, через що React.memo вважає, що пропси змінилися.",
    "interviewTip": "Щоб виправити це, використовуйте useMemo для об'єктів та useCallback для функцій.",
    "options": [
      "Passing a new object literal as a prop: <Child data={{}} />.",
      "Passing a numeric prop: <Child count={5} />.",
      "Passing an inline arrow function: <Child onClick={() => {}} />.",
      "Passing a string prop: <Child name='Alice' />."
    ]
  },
  "mem-05": {
    "prompt": "Що таке 'Referential Equality' (посилальна рівність) у контексті оптимізації React?",
    "explanation": "React використовує поверхневу рівність (Object.is) для пропсів та масивів залежностей. Якщо посилання змінюється, оптимізація не спрацьовує.",
    "interviewTip": "Ось чому стабільні посилання (через хуки) є основою продуктивності React.",
    "options": [
      "When two variables have the same string name.",
      "When React checks if two variables point to the exact same memory address.",
      "When the HTML structure of two components matches.",
      "When two components share the same key prop."
    ]
  },
  "mem-06": {
    "prompt": "Чому наступний 'useCallback' є проблематичним?",
    "explanation": "Порожній масив залежностей каже React ніколи не оновлювати посилання на функцію. Вона назавжди «запам'ятовує» версію 'text' з найпершого рендеру.",
    "interviewTip": "Завжди включайте кожне реактивне значення, що використовується всередині хука, до масиву залежностей.",
    "options": [
      "It will cause an infinite loop.",
      "It will always log the value of 'text' from the very first render (Stale Closure).",
      "The component will crash.",
      "useCallback cannot log to the console."
    ]
  },
  "mem-07": {
    "prompt": "Коли НЕ варто використовувати useMemo або useCallback?",
    "explanation": "Мемоїзація має свою ціну (пам'ять та час на порівняння). Якщо логіка проста, витрати на роботу хука можуть бути більшими за користь.",
    "interviewTip": "Не оптимізуйте передчасно. Спочатку профілюйте додаток, щоб побачити, де насправді є вузькі місця.",
    "options": [
      "In small components with simple logic.",
      "When passing props to a memoized child component.",
      "When performing expensive array filtering.",
      "When the dependency array is very large."
    ]
  },
  "mem-08": {
    "prompt": "Визначте результат цього компонента після перерендерингу:",
    "explanation": "Навіть якщо значення однакові, `[1,2,3] !== [1,2,3]` у JS. Нове посилання ініціює перерендер.",
    "interviewTip": "Винесіть статичні дані за межі компонента або огорніть їх у useMemo.",
    "options": [
      "MemoizedChild will not re-render because the array content is identical.",
      "MemoizedChild will re-render because 'data' is a new array reference every time.",
      "React will throw an error.",
      "Only the first item in the list will re-render."
    ]
  },
  "mem-09": {
    "prompt": "Що дозволяє робити другий аргумент React.memo(Component, arePropsEqual)?",
    "explanation": "За замовчуванням React.memo робить поверхневу перевірку. Ви можете надати власну функцію для глибокого порівняння або ігнорування конкретних пропсів.",
    "interviewTip": "Будьте обережні: глибоке порівняння може бути повільнішим, ніж сам перерендер!",
    "options": [
      "It allows you to manually define the comparison logic for props.",
      "It sets the time-to-live for the cache.",
      "It allows you to pass a custom key to the component.",
      "It lets you decide which state changes to ignore."
    ]
  },
  "mem-10": {
    "prompt": "Які з цих хуків залежать від стабільності посилань для ефективної роботи?",
    "explanation": "useEffect перезапускається, якщо посилання змінюється. Споживачі Context перерендериться, якщо значення провайдера (часто об'єкт) є новим посиланням.",
    "interviewTip": "Стабільність посилань — це «місток», який робить інші хуки ефективними.",
    "options": [
      "useEffect (when functions/objects are in the dependency array).",
      "useState.",
      "useContext (to avoid re-rendering all consumers).",
      "useRef."
    ]
  },
  "mem-11": {
    "prompt": "Як мемоїзувати важкі обчислення, що залежать від 'a' та 'b'?",
    "explanation": "useMemo приймає функцію, яка повертає значення, яке ви хочете закешувати.",
    "interviewTip": "Функція всередині useMemo має бути «чистою» — вона не повинна мати побічних ефектів.",
    "options": [
      "const val = useMemo(calculate(a, b), [a, b]);",
      "const val = useMemo(() => calculate(a, b), [a, b]);",
      "const val = useCallback(() => calculate(a, b), [a, b]);",
      "const val = React.memo(calculate(a, b));"
    ]
  },
  "mem-12": {
    "prompt": "Яким буде результат використання хука всередині useMemo?",
    "explanation": "Хуки повинні викликатися на верхньому рівні вашого компонента. Ви не можете вкладати хуки в useMemo, useEffect або будь-яку іншу функцію.",
    "interviewTip": "Це відповідає вимогам «Правил хуків» щодо порядку їх виклику.",
    "options": [
      "It creates a local state for the memoized value.",
      "It is invalid; hooks cannot be called inside useMemo.",
      "It works only in React 18.",
      "It returns a setter function."
    ]
  }
}