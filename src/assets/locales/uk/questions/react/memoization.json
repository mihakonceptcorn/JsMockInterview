{
  "mem-01": {
    "prompt": "Яка основна різниця між useMemo та useCallback?",
    "explanation": "useMemo виконує функцію та запам'ятовує повернуте значення. useCallback повертає саму функцію, щоб її посилання залишалося стабільним між рендерами.",
    "interviewTip": "Запам'ятайте: useCallback(fn, deps) — це, по суті, те саме, що й useMemo(() => fn, deps)."
  },
  "mem-02": {
    "prompt": "Проаналізуйте код. Скільки разів буде виведено 'Calculating...', якщо компонент перерендериться, але 'count' залишиться незмінним?",
    "explanation": "Оскільки 'count' не змінився, useMemo повертає закешоване значення і пропускає повторне виконання функції.",
    "interviewTip": "Це ідеально підходить для уникнення «важкої» логіки (наприклад, сортування великих масивів) при кожному рендері."
  },
  "mem-03": {
    "prompt": "Що робить React.memo, коли ним огортають компонент?",
    "explanation": "React.memo — це компонент вищого порядку (HOC), який виконує поверхневе порівняння пропсів. Якщо вони такі ж, як минулого разу, React пропускає рендеринг цього компонента.",
    "interviewTip": "За замовчуванням React перерендерить усіх дітей, коли рендериться батько. React.memo дозволяє відмовитися від цієї поведінки."
  },
  "mem-04": {
    "prompt": "Який із цих сценаріїв може зламати мемоїзацію (спричинивши неочікуваний перерендер)?",
    "explanation": "У JS `{} !== {}` та `()=>{} !== ()=>{} `. Вони створюють нові посилання при кожному рендері, через що React.memo вважає, що пропси змінилися.",
    "interviewTip": "Щоб виправити це, використовуйте useMemo для об'єктів та useCallback для функцій."
  },
  "mem-05": {
    "prompt": "Що таке 'Referential Equality' (посилальна рівність) у контексті оптимізації React?",
    "explanation": "React використовує поверхневу рівність (Object.is) для пропсів та масивів залежностей. Якщо посилання змінюється, оптимізація не спрацьовує.",
    "interviewTip": "Ось чому стабільні посилання (через хуки) є основою продуктивності React."
  },
  "mem-06": {
    "prompt": "Чому наступний 'useCallback' є проблематичним?",
    "explanation": "Порожній масив залежностей каже React ніколи не оновлювати посилання на функцію. Вона назавжди «запам'ятовує» версію 'text' з найпершого рендеру.",
    "interviewTip": "Завжди включайте кожне реактивне значення, що використовується всередині хука, до масиву залежностей."
  },
  "mem-07": {
    "prompt": "Коли НЕ варто використовувати useMemo або useCallback?",
    "explanation": "Мемоїзація має свою ціну (пам'ять та час на порівняння). Якщо логіка проста, витрати на роботу хука можуть бути більшими за користь.",
    "interviewTip": "Не оптимізуйте передчасно. Спочатку профілюйте додаток, щоб побачити, де насправді є вузькі місця."
  },
  "mem-08": {
    "prompt": "Визначте результат цього компонента після перерендерингу:",
    "explanation": "Навіть якщо значення однакові, `[1,2,3] !== [1,2,3]` у JS. Нове посилання ініціює перерендер.",
    "interviewTip": "Винесіть статичні дані за межі компонента або огорніть їх у useMemo."
  },
  "mem-09": {
    "prompt": "Що дозволяє робити другий аргумент React.memo(Component, arePropsEqual)?",
    "explanation": "За замовчуванням React.memo робить поверхневу перевірку. Ви можете надати власну функцію для глибокого порівняння або ігнорування конкретних пропсів.",
    "interviewTip": "Будьте обережні: глибоке порівняння може бути повільнішим, ніж сам перерендер!"
  },
  "mem-10": {
    "prompt": "Які з цих хуків залежать від стабільності посилань для ефективної роботи?",
    "explanation": "useEffect перезапускається, якщо посилання змінюється. Споживачі Context перерендериться, якщо значення провайдера (часто об'єкт) є новим посиланням.",
    "interviewTip": "Стабільність посилань — це «місток», який робить інші хуки ефективними."
  },
  "mem-11": {
    "prompt": "Як мемоїзувати важкі обчислення, що залежать від 'a' та 'b'?",
    "explanation": "useMemo приймає функцію, яка повертає значення, яке ви хочете закешувати.",
    "interviewTip": "Функція всередині useMemo має бути «чистою» — вона не повинна мати побічних ефектів."
  },
  "mem-12": {
    "prompt": "Яким буде результат використання хука всередині useMemo?",
    "explanation": "Хуки повинні викликатися на верхньому рівні вашого компонента. Ви не можете вкладати хуки в useMemo, useEffect або будь-яку іншу функцію.",
    "interviewTip": "Це відповідає вимогам «Правил хуків» щодо порядку їх виклику."
  }
}
