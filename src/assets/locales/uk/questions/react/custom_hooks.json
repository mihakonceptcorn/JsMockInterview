{
  "ch-01": {
    "prompt": "Яка обов'язкова угода щодо найменування спеціальних хуків у React?",
    "explanation": "Префікс 'use' є обов'язковим, оскільки він дозволяє лінтеру React автоматично перевіряти код на дотримання правил хуків (Rules of Hooks).",
    "interviewTip": "Якщо ви не почнете назву з 'use', React не знатиме, що це хук, і не зможе гарантувати стабільність порядку його викликів.",
    "options": [
      "Вони повинні закінчуватися на 'Hook' (наприклад, useDataHook).",
      "Вони повинні починатися зі слова 'use' (наприклад, useFetch).",
      "Вони повинні бути написані ВЕЛИКИМИ_ЛІТЕРАМИ.",
      "Обов'язкової угоди щодо найменування не існує."
    ]
  },
  "ch-02": {
    "prompt": "Яка головна перевага створення спеціального хука?",
    "explanation": "Спеціальні хуки дозволяють приховати складну логіку (наприклад, отримання даних, обробку форм або слухачів подій) за простим API, який можуть використовувати декілька компонентів.",
    "interviewTip": "Сприймайте спеціальні хуки як «композицію логіки», а не «композицію інтерфейсу».",
    "options": [
      "Для прискорення рендерингу Virtual DOM.",
      "Для винесення та повторного використання stateful logic між різними компонентами.",
      "Щоб замінити потребу у використанні хука useEffect.",
      "Для створення глобальної змінної в обхід системи пропсів."
    ]
  },
  "ch-03": {
    "prompt": "Якщо два компоненти використовують один і той самий спеціальний хук, чи мають вони спільний стан?",
    "explanation": "Хуки — це спосіб повторного використання *логіки*, а не *даних*. Кожного разу, коли ви викликаєте хук, увесь стан та ефекти всередині нього ізолюються для конкретного виклику.",
    "interviewTip": "Якщо вам потрібно поділитися даними, вам все одно знадобиться Context або бібліотека для керування станом, як-от Redux.",
    "options": [
      "Так, спеціальні хуки створюють singleton state для цієї логіки.",
      "Ні, кожен виклик спеціального хука створює повністю незалежний стан для цього екземпляра компонента.",
      "Тільки якщо хук імпортовано з глобального файлу.",
      "Тільки якщо компоненти є сусідніми (siblings)."
    ]
  },
  "ch-04": {
    "prompt": "Що можна викликати всередині спеціального хука?",
    "explanation": "Спеціальні хуки — це, по суті, звичайні функції з «суперздібностями»: вони можуть використовувати будь-які інші вбудовані хуки React всередині себе.",
    "interviewTip": "Саме тому спеціальні хуки такі потужні — вони є сполучною ланкою, що об'єднує кілька вбудованих хуків в одну функцію.",
    "options": [
      "Тільки стандартні функції JavaScript.",
      "Тільки інші спеціальні хуки.",
      "Інші вбудовані хуки React (useState, useEffect тощо) і навіть інші спеціальні хуки.",
      "Нічого; спеціальні хуки мають бути чистими функціями без стану."
    ]
  },
  "ch-05": {
    "prompt": "Проаналізуйте спеціальний хук нижче. Який тип значення він повертає?",
    "explanation": "Спеціальні хуки можуть повертати будь-що (масиви, об'єкти або навіть поодинокі значення). Повернення масиву — це поширений патерн, змодельований за прикладом useState.",
    "interviewTip": "Повернення масиву зручне для перейменування значень під час деструктуризації. Об'єкт краще використовувати, якщо значень, що повертаються, багато.",
    "options": [
      "Одне булеве значення.",
      "Об'єкт { value, toggle }.",
      "Масив [boolean, function].",
      "undefined"
    ]
  },
  "ch-06": {
    "prompt": "Які з наведених нижче правил хуків застосовуються до спеціальних хуків?",
    "explanation": "Спеціальні хуки обмежені тими ж правилами, що й вбудовані: вони повинні викликатися на верхньому рівні та не можуть бути умовними.",
    "interviewTip": "Порядок викликів повинен залишатися ідентичним під час кожного рендеру, щоб React міг правильно відстежувати стан.",
    "options": [
      "Хуки повинні викликатися тільки на верхньому рівні функції.",
      "Хуки можна викликати всередині обробників подій (event handlers) у спеціальному хуку.",
      "Хуки не можна викликати всередині циклів або умов.",
      "Спеціальні хуки повинні повертати JSX."
    ]
  },
  "ch-07": {
    "prompt": "Визначте потенційну проблему в цьому спеціальному хуку:",
    "explanation": "Побічні ефекти, як-от слухачі подій, повинні бути всередині useEffect з функцією очищення, щоб уникнути накопичення тисяч слухачів при повторних рендерах.",
    "interviewTip": "Завжди поєднуйте додавання ('add') із видаленням ('remove') у функції очищення.",
    "options": [
      "Хук повинен повертати об'єкт, а не число.",
      "Це викликає memory leak, оскільки додається новий слухач при кожному рендері без його видалення.",
      "window недоступний у спеціальних хуках.",
      "setSize має викликатися всередині циклу."
    ]
  },
  "ch-08": {
    "prompt": "Як передати параметри в спеціальний хук?",
    "explanation": "Оскільки спеціальні хуки — це просто функції, ви можете передавати будь-які дані (рядки, об'єкти або навіть інші функції) як аргументи.",
    "interviewTip": "Якщо аргументи змінюються, переконайтеся, що хуки *всередині* вашого спеціального хука (наприклад, useEffect) реагують на ці зміни, додавши їх до масивів залежностей.",
    "options": [
      "Ви не можете; спеціальні хуки не приймають аргументів.",
      "Передавайте їх як звичайні параметри функції при виклику хука.",
      "Шляхом встановлення глобальної змінної перед викликом хука.",
      "Використовуючи спеціальний пропс 'useParams'."
    ]
  },
  "ch-09": {
    "prompt": "У чому головна перевага наступного патерну?",
    "explanation": "Це класичний хук `useForm`. Замість того, щоб кожен компонент писав власну логіку handleChange, вони просто імпортують цей хук.",
    "interviewTip": "Стандартизація загальної логіки інтерфейсу (форми, модальні вікна) у спеціальні хуки — ознака кодової бази рівня Senior.",
    "options": [
      "Це дозволяє будь-якому компоненту використовувати ту саму логіку форми без переписування стану та обробників.",
      "Він автоматично відправляє дані на сервер.",
      "Він змушує форму працювати у фоновому режимі.",
      "Він валідує вхідні дані за допомогою AI."
    ]
  },
  "ch-10": {
    "prompt": "Чи можна викликати спеціальний хук зсередини іншого спеціального хука?",
    "explanation": "Хуки підтримують композицію. Наприклад, хук `useAuthenticatedFetch` може викликати хуки `useAuth` та `useFetch` всередині себе.",
    "interviewTip": "Композиція — це «секретний інгредієнт» гнучкості React.",
    "options": [
      "Ні, це вкладення (nesting) і воно заборонено.",
      "Так, це поширений спосіб побудови складної логіки з простіших хуків.",
      "Тільки якщо батьківський хук є class component.",
      "Тільки якщо ви використовуєте утиліту 'useCompose'."
    ]
  },
  "ch-11": {
    "prompt": "Чому варто використовувати 'useCallback' або 'useMemo' всередині спеціального хука, який повертає функції або об'єкти?",
    "explanation": "Якщо ваш хук повертає функцію `() => {}`, ця функція отримує нове посилання при кожному рендері. Якщо вона є залежністю в useEffect іншого компонента, це призведе до нескінченного циклу.",
    "interviewTip": "Забезпечення «стабільності посилань» — це ключовий обов'язок добре написаного спеціального хука.",
    "options": [
      "Щоб запобігти повторному запуску хука взагалі.",
      "Щоб забезпечити стабільність посилань (stable references), аби компоненти, що використовують хук, не рендерилися зайвий раз.",
      "Для шифрування даних, що повертаються.",
      "Щоб зробити код складнішим для зворотного проектування (reverse engineering)."
    ]
  },
  "ch-12": {
    "prompt": "Які з наведених варіантів є хорошими кандидатами для створення спеціального хука?",
    "explanation": "Проста математика — це звичайна функція. Все, що потребує стану ('State') або життєвого циклу (статус мережі, пагінація, IntersectionObserver), має быть спеціальним хуком.",
    "interviewTip": "Якщо функція не використовує жодних хуків React (useState, useEffect тощо), вона, ймовірно, має бути простою утилітою, а не хуком.",
    "options": [
      "Логіка, яка відстежує, чи перебуває користувач зараз в мережі (online/offline).",
      "Функція, яка додає два числа і повертає суму.",
      "Логіка, що обробляє пагінацію та сортування для таблиці даних.",
      "Логіка, яка перевіряє, чи видимий зараз елемент у в’юпорті (viewport)."
    ]
  },
  "ch-13": {
    "prompt": "Що станеться, якщо використати спеціальний хук всередині оператора 'if'?",
    "explanation": "React зіставляє стан із хуками на основі їхнього *індексу* в черзі викликів. Якщо пропустити хук через умову, індекси змістяться, і неправильний стан буде призначено неправильним хукам.",
    "interviewTip": "Пам'ятайте: черговість виклику хуків повинна бути ідентичною при кожному рендері.",
    "options": [
      "Дані завантажуватимуться тільки для залогінених користувачів, заощаджуючи трафік.",
      "Це працюватиме нормально під час розробки, але впаде в продакшні.",
      "React видасть помилку, бо порядок виклику хуків змінився, що призведе до збою або невідповідності стану.",
      "Хук буде викликаний один раз, а потім закешований."
    ]
  }
}
