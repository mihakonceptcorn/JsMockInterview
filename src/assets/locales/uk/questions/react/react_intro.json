{
  "ri-01": {
    "prompt": "У чому полягає основна архітектурна перевага Virtual DOM?",
    "explanation": "Virtual DOM — це легковажне представлення реального DOM. React використовує його для групування оновлень (batching) та мінімізації високовартісних прямих маніпуляцій із реальним DOM.",
    "interviewTip": "Використовуйте термін «Узгодження» (Reconciliation), коли описуєте, як React синхронізує Virtual та Real DOM.",
    "options": [
      "Він прискорює інтернет-з'єднання між клієнтом і сервером.",
      "Він дозволяє React обчислити найефективніший спосіб оновлення реального DOM.",
      "Він забезпечує спосіб зберігання даних у постійному сховищі браузера.",
      "Він усуває потребу в JavaScript у сучасних браузерах."
    ]
  },
  "ri-02": {
    "prompt": "Яке з наведених тверджень найкраще описує «декларативне» програмування в React?",
    "explanation": "У React ви оголошуєте бажаний стан інтерфейсу, а React сам керує переходами в DOM. Імперативне програмування передбачає ручне оновлення DOM для кожної зміни.",
    "interviewTip": "Декларативний код зазвичай легше відлагоджувати та розуміти, оскільки він більш передбачуваний.",
    "options": [
      "Опис того, *як* має виглядати UI для певного стану.",
      "Написання покрокових інструкцій про те, *як* змінити DOM.",
      "Використання тільки класових компонентів для визначення логіки.",
      "Ручний вибір HTML-елементів за допомогою document.querySelector."
    ]
  },
  "ri-03": {
    "prompt": "Чому React часто класифікують як «бібліотеку», а не як «фреймворк»?",
    "explanation": "На відміну від фреймворків (як Angular), React не диктує жорстких правил. Вам потрібно самостійно обирати інструменти для навігації або запитів до API.",
    "interviewTip": "Ця гнучкість дозволяє командам підбирати найкращі рішення (best-in-class) під конкретні потреби проекту.",
    "options": [
      "Він зосереджений виключно на рівні 'View' (представлення) застосунку.",
      "Він не має вбудованих рішень для маршрутизації (routing) або глобального керування станом.",
      "Він менший за розміром файлу, ніж будь-який інший інструмент JavaScript.",
      "Його не можна використовувати для створення повномасштабних корпоративних застосунків."
    ]
  },
  "ri-04": {
    "prompt": "Що насправді представляє цей код JSX після компіляції через Babel?",
    "explanation": "JSX — це «синтаксичний цукор». Babel перетворює його на вкладені виклики React.createElement, які повертають звичайні об'єкти JS (React Elements).",
    "interviewTip": "Починаючи з React 17, новий механізм трансформації JSX робить це автоматично і не вимагає 'import React' у кожному файлі.",
    "options": [
      "Рядок HTML: \"<div id='root'>Hello</div>\"",
      "Пряме посилання на DOM-вузол, створений браузером.",
      "Об'єкт JavaScript, створений за допомогою React.createElement().",
      "Функція, яка повертає Promise."
    ]
  },
  "ri-05": {
    "prompt": "Що виведе наступний код у консоль?",
    "explanation": "React-елементи позначені спеціальним символом ($$typeof) з міркувань безпеки, насамперед для запобігання XSS-атакам (міжсайтовий скриптинг).",
    "interviewTip": "Цей тег гарантує, що React рендерить лише ті об'єкти, які він створив сам.",
    "options": ["undefined", "Symbol(react.element)", "\"div\"", "null"]
  },
  "ri-06": {
    "prompt": "Що таке «принцип єдиної відповідальності» (Single Responsibility Principle) у компонентах React?",
    "explanation": "Компоненти мають бути модульними та зосередженими на одній задачі. Якщо компонент стає занадто великим, його варто розділити на менші підкомпоненти.",
    "interviewTip": "Малі, фокусовані компоненти набагато легше тестувати та використовувати повторно.",
    "options": [
      "Компонент має використовуватися лише один раз у всьому застосунку.",
      "Компонент в ідеалі повинен виконувати лише одну справу.",
      "Увесь стан має керуватися єдиним 'кореневим' компонентом.",
      "Кожен компонент має містити рівно один рядок JSX."
    ]
  },
  "ri-07": {
    "prompt": "Що станеться, якщо спробувати відрендерити наступний компонент?",
    "explanation": "React-компоненти повинні повертати один кореневий вузол. Це пов'язано з тим, що функція може повертати лише одне значення (одне дерево об'єктів).",
    "interviewTip": "Використовуйте фрагмент (<></>), щоб згрупувати елементи без додавання зайвого div-а в DOM.",
    "options": [
      "Браузер рендерить обидва заголовки поруч.",
      "Синтаксична помилка: JSX повинен мати один батьківський елемент.",
      "Рендериться тільки 'Item 1'; 'Item 2' ігнорується.",
      "Другий заголовок перезаписує перший."
    ]
  },
  "ri-08": {
    "prompt": "Що таке 'Babel' у контексті екосистеми React?",
    "explanation": "Babel бере сучасний код (JSX, ES6+) і перетворює його на версії JavaScript зі зворотною сумісністю, які можуть запускати всі браузери.",
    "interviewTip": "Vite та Create React App використовують Babel (або альтернативи, як SWC) під капотом.",
    "options": [
      "Бібліотека CSS-in-JS.",
      "Лінтер коду, який знаходить логічні помилки.",
      "JavaScript-компілятор/транспілятор, який перетворює JSX у валідний JS.",
      "Система керування базами даних для React."
    ]
  },
  "ri-09": {
    "prompt": "Проаналізуйте код нижче. Чому інтерфейс не оновиться після кліку користувача?",
    "explanation": "React не «стежить» за звичайною змінною 'likes'. Щоб ініціювати оновлення інтерфейсу, необхідно використовувати хук 'useState'.",
    "interviewTip": "Це фундаментальна концепція: зміна стану (State) = повторний рендеринг (Re-render).",
    "options": [
      "Змінна 'likes' оголошена не через 'const'.",
      "React не відстежує зміни локальних змінних; він перерендерить лише при зміні стану або пропсів.",
      "Подія onClick кнопки написана маленькими літерами.",
      "Функції не можна передавати в атрибут onClick."
    ]
  },
  "ri-10": {
    "prompt": "Що означає «односпрямований потік даних» (unidirectional data flow) у React?",
    "explanation": "У React дочірні елементи отримують дані від батьків через пропси. Якщо дітям потрібно змінити стан батька, вони використовують колбеки, передані через ті самі пропси.",
    "interviewTip": "Цей потік «зверху вниз» робить стан програми набагато передбачуванішим і простішим для відлагодження.",
    "options": [
      "Дані течуть тільки від сервера до клієнта.",
      "Дані течуть суворо від батьківських компонентів вниз до дочірніх.",
      "Стан і пропси оновлюються одночасно в обох напрямках.",
      "Користувачі можуть взаємодіяти із застосунком лише в одному напрямку (зверху вниз)."
    ]
  },
  "ri-11": {
    "prompt": "Які з цих варіантів є валідними способами рендерингу 'Fragment' у React?",
    "explanation": "Усі три варіанти правильні, причому <>...</> є найкоротшим записом.",
    "interviewTip": "Пам'ятайте, що лише повний синтаксис <React.Fragment> може приймати атрибут 'key'.",
    "options": [
      "<React.Fragment>...</React.Fragment>",
      "<Fragment>...</Fragment>",
      "<>...</>",
      "<div fragment>...</div>"
    ]
  },
  "ri-12": {
    "prompt": "Яким буде результат наступної перевірки 'typeof'?",
    "explanation": "Елементи JSX транспілюються у звичайні об'єкти JavaScript.",
    "interviewTip": "Оскільки вони є об'єктами, ви можете передавати їх як пропси, зберігати в змінних або поміщати в масиви.",
    "options": ["\"string\"", "\"object\"", "\"function\"", "\"undefined\""]
  },
  "ri-13": {
    "prompt": "Яка мета бібліотеки 'ReactDOM'?",
    "explanation": "React незалежний від платформи. ReactDOM — це специфічна «сполучна ланка», яка дозволяє React працювати у веббраузерах.",
    "interviewTip": "React Native використовує інший рендерер (нативний мобільний інтерфейс) замість ReactDOM.",
    "options": [
      "Для керування станом компонентів та хуками.",
      "Для надання логіки створення компонентів React.",
      "Для рендерингу дерева компонентів React у реальний DOM браузера.",
      "Для зв'язку з базою даних SQL."
    ]
  },
  "ri-14": {
    "prompt": "Що не так із цією інструкцією return?",
    "explanation": "Через автоматичне вставлення крапки з комою (ASI), вираз return переривається. Ви повинні розмістити JSX на тому самому рядку або огорнути його в круглі дужки.",
    "interviewTip": "Завжди огортайте багаторядковий JSX у круглі дужки: return (...);",
    "options": [
      "Інструкції return не можна використовувати у функціональних компонентах.",
      "Крапка з комою має бути всередині тегів.",
      "JavaScript автоматично вставляє крапку з комою після 'return', повертаючи 'undefined' замість JSX.",
      "Теги <h1> вимагають наявності className."
    ]
  },
  "ri-15": {
    "prompt": "Як React розрізняє HTML-тег та власний компонент у JSX?",
    "explanation": "React.createElement() використовує регістр першої літери: маленька літера означає нативний HTML, велика — змінну (компонент).",
    "interviewTip": "Якщо ви оголосили компонент як 'const myHeader = ...', використовуйте його як <MyHeader />, щоб він був розпізнаний.",
    "options": [
      "HTML-теги сині, компоненти — червоні.",
      "Власні компоненти мають починатися з великої літери; HTML-теги — з маленької.",
      "Компоненти мають завжди використовувати самозакривні теги.",
      "HTML-теги мають бути огорнуті в лапки."
    ]
  },
  "ri-16": {
    "prompt": "Що таке алгоритм «Узгодження» (Reconciliation)?",
    "explanation": "Reconciliation — це процес порівняння (diffing), під час якого React обчислює мінімальний набір змін, необхідних для оновлення браузерного UI.",
    "interviewTip": "React припускає, що якщо тип компонента змінився, все дерево під ним потрібно перезібрати заново.",
    "options": [
      "Процес перетворення CSS в JS-об'єкти.",
      "Спосіб, яким React порівнює два дерева Virtual DOM, щоб побачити зміни.",
      "Спосіб синхронізації фронтенду та бекенд-сервера.",
      "Метод поєднання кількох сторів Redux."
    ]
  },
  "ri-17": {
    "prompt": "Чому компоненти мають бути «чистими» функціями щодо своїх пропсів?",
    "explanation": "Компонент ніколи не повинен змінювати свої пропси. Він має повертати однаковий JSX для того самого набору пропсів та стану.",
    "interviewTip": "Незмінність (immutability) — це ключ до оптимізацій продуктивності React (наприклад, React.memo).",
    "options": [
      "Щоб код виглядав професійніше.",
      "Щоб забезпечити передбачуваність компонента та незмінність його вхідних даних.",
      "Тому що JavaScript не дозволяє змінювати аргументи функцій.",
      "Щоб запобігти кешуванню компонента браузером."
    ]
  },
  "ri-18": {
    "prompt": "Визначте динамічну частину цього JSX:",
    "explanation": "Фігурні дужки {} — це «вихід» у JavaScript, що дозволяє вставляти динамічні значення або логіку прямо в розмітку.",
    "interviewTip": "Ви навіть можете вставляти складну логіку, таку як map() або тернарні оператори, всередині цих дужок.",
    "options": ["className='main'", "<h1>", "{title}", "const title"]
  }
}
