{
  "ri-01": {
    "prompt": "У чому полягає основна архітектурна перевага Virtual DOM?",
    "explanation": "Virtual DOM — це легковажне представлення реального DOM. React використовує його для групування оновлень (batching) та мінімізації високовартісних прямих маніпуляцій із реальним DOM.",
    "interviewTip": "Використовуйте термін «Узгодження» (Reconciliation), коли описуєте, як React синхронізує Virtual та Real DOM."
  },
  "ri-02": {
    "prompt": "Яке з наведених тверджень найкраще описує «декларативне» програмування в React?",
    "explanation": "У React ви оголошуєте бажаний стан інтерфейсу, а React сам керує переходами в DOM. Імперативне програмування передбачає ручне оновлення DOM для кожної зміни.",
    "interviewTip": "Декларативний код зазвичай легше відлагоджувати та розуміти, оскільки він більш передбачуваний."
  },
  "ri-03": {
    "prompt": "Чому React часто класифікують як «бібліотеку», а не як «фреймворк»?",
    "explanation": "На відміну від фреймворків (як Angular), React не диктує жорстких правил. Вам потрібно самостійно обирати інструменти для навігації або запитів до API.",
    "interviewTip": "Ця гнучкість дозволяє командам підбирати найкращі рішення (best-in-class) під конкретні потреби проекту."
  },
  "ri-04": {
    "prompt": "Що насправді представляє цей код JSX після компіляції через Babel?",
    "explanation": "JSX — це «синтаксичний цукор». Babel перетворює його на вкладені виклики React.createElement, які повертають звичайні об'єкти JS (React Elements).",
    "interviewTip": "Починаючи з React 17, новий механізм трансформації JSX робить це автоматично і не вимагає 'import React' у кожному файлі."
  },
  "ri-05": {
    "prompt": "Що виведе наступний код у консоль?",
    "explanation": "React-елементи позначені спеціальним символом ($$typeof) з міркувань безпеки, насамперед для запобігання XSS-атакам (міжсайтовий скриптинг).",
    "interviewTip": "Цей тег гарантує, що React рендерить лише ті об'єкти, які він створив сам."
  },
  "ri-06": {
    "prompt": "Що таке «принцип єдиної відповідальності» (Single Responsibility Principle) у компонентах React?",
    "explanation": "Компоненти мають бути модульними та зосередженими на одній задачі. Якщо компонент стає занадто великим, його варто розділити на менші підкомпоненти.",
    "interviewTip": "Малі, фокусовані компоненти набагато легше тестувати та використовувати повторно."
  },
  "ri-07": {
    "prompt": "Що станеться, якщо спробувати відрендерити наступний компонент?",
    "explanation": "React-компоненти повинні повертати один кореневий вузол. Це пов'язано з тим, що функція може повертати лише одне значення (одне дерево об'єктів).",
    "interviewTip": "Використовуйте фрагмент (<></>), щоб згрупувати елементи без додавання зайвого div-а в DOM."
  },
  "ri-08": {
    "prompt": "Що таке 'Babel' у контексті екосистеми React?",
    "explanation": "Babel бере сучасний код (JSX, ES6+) і перетворює його на версії JavaScript зі зворотною сумісністю, які можуть запускати всі браузери.",
    "interviewTip": "Vite та Create React App використовують Babel (або альтернативи, як SWC) під капотом."
  },
  "ri-09": {
    "prompt": "Проаналізуйте код нижче. Чому інтерфейс не оновиться після кліку користувача?",
    "explanation": "React не «стежить» за звичайною змінною 'likes'. Щоб ініціювати оновлення інтерфейсу, необхідно використовувати хук 'useState'.",
    "interviewTip": "Це фундаментальна концепція: зміна стану (State) = повторний рендеринг (Re-render)."
  },
  "ri-10": {
    "prompt": "Що означає «односпрямований потік даних» (unidirectional data flow) у React?",
    "explanation": "У React дочірні елементи отримують дані від батьків через пропси. Якщо дітям потрібно змінити стан батька, вони використовують колбеки, передані через ті самі пропси.",
    "interviewTip": "Цей потік «зверху вниз» робить стан програми набагато передбачуванішим і простішим для відлагодження."
  },
  "ri-11": {
    "prompt": "Які з цих варіантів є валідними способами рендерингу 'Fragment' у React?",
    "explanation": "Усі три варіанти правильні, причому <>...</> є найкоротшим записом.",
    "interviewTip": "Пам'ятайте, що лише повний синтаксис <React.Fragment> може приймати атрибут 'key'."
  },
  "ri-12": {
    "prompt": "Яким буде результат наступної перевірки 'typeof'?",
    "explanation": "Елементи JSX транспілюються у звичайні об'єкти JavaScript.",
    "interviewTip": "Оскільки вони є об'єктами, ви можете передавати їх як пропси, зберігати в змінних або поміщати в масиви."
  },
  "ri-13": {
    "prompt": "Яка мета бібліотеки 'ReactDOM'?",
    "explanation": "React незалежний від платформи. ReactDOM — це специфічна «сполучна ланка», яка дозволяє React працювати у веббраузерах.",
    "interviewTip": "React Native використовує інший рендерер (нативний мобільний інтерфейс) замість ReactDOM."
  },
  "ri-14": {
    "prompt": "Що не так із цією інструкцією return?",
    "explanation": "Через автоматичне вставлення крапки з комою (ASI), вираз return переривається. Ви повинні розмістити JSX на тому самому рядку або огорнути його в круглі дужки.",
    "interviewTip": "Завжди огортайте багаторядковий JSX у круглі дужки: return (...);"
  },
  "ri-15": {
    "prompt": "Як React розрізняє HTML-тег та власний компонент у JSX?",
    "explanation": "React.createElement() використовує регістр першої літери: маленька літера означає нативний HTML, велика — змінну (компонент).",
    "interviewTip": "Якщо ви оголосили компонент як 'const myHeader = ...', використовуйте його як <MyHeader />, щоб він був розпізнаний."
  },
  "ri-16": {
    "prompt": "Що таке алгоритм «Узгодження» (Reconciliation)?",
    "explanation": "Reconciliation — це процес порівняння (diffing), під час якого React обчислює мінімальний набір змін, необхідних для оновлення браузерного UI.",
    "interviewTip": "React припускає, що якщо тип компонента змінився, все дерево під ним потрібно перезібрати заново."
  },
  "ri-17": {
    "prompt": "Чому компоненти мають бути «чистими» функціями щодо своїх пропсів?",
    "explanation": "Компонент ніколи не повинен змінювати свої пропси. Він має повертати однаковий JSX для того самого набору пропсів та стану.",
    "interviewTip": "Незмінність (immutability) — це ключ до оптимізацій продуктивності React (наприклад, React.memo)."
  },
  "ri-18": {
    "prompt": "Визначте динамічну частину цього JSX:",
    "explanation": "Фігурні дужки {} — це «вихід» у JavaScript, що дозволяє вставляти динамічні значення або логіку прямо в розмітку.",
    "interviewTip": "Ви навіть можете вставляти складну логіку, таку як map() або тернарні оператори, всередині цих дужок."
  }
}
