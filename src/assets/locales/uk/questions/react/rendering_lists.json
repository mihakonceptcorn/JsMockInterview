{
  "rl-01": {
    "prompt": "Яка основна мета пропса 'key' при рендерингу списку в React?",
    "explanation": "Ключі слугують стабільними ідентифікаторами для елементів між рендерами. Без них React може некоректно оновлювати список або повністю перерендерити його, втрачаючи стан.",
    "interviewTip": "Ключі повинні бути унікальними серед сусідніх елементів і стабільними (не змінюватися при кожному рендері).",
    "options": [
      "Надати назву CSS-класу для елемента списку.",
      "Допомогти React ідентифікувати, які елементи змінилися, були додані або видалені.",
      "Визначити порядок елементів у DOM.",
      "Автоматично відсортувати масив даних."
    ]
  },
  "rl-02": {
    "prompt": "Який метод JavaScript найчастіше використовується для перетворення масиву даних у список компонентів React?",
    "explanation": "Метод .map() ідеально підходить, оскільки він повертає новий масив тієї ж довжини, дозволяючи огорнути кожен елемент даних у JSX.",
    "interviewTip": "Пам'ятайте, що .forEach() повертає undefined і нічого не відрендерить у JSX.",
    "options": ["forEach", "filter", "map", "reduce"]
  },
  "rl-03": {
    "prompt": "У чому полягає потенційний недолік використання індексу масиву як ключа?",
    "explanation": "Якщо порядок елементів зміниться, індекс залишиться прив'язаним до позиції, а не до контенту. Це заплутує механізм керування станом React для цих компонентів.",
    "interviewTip": "Використовуйте індекс як ключ лише якщо список статичний (ніколи не змінюється, не фільтрується і не сортується).",
    "options": [
      "Це спричиняє синтаксичну помилку в консолі браузера.",
      "Це може призвести до помилок в інтерфейсі та проблем із продуктивністю, якщо список перевпорядковується або фільтрується.",
      "Це заважає компоненту отримувати будь-які пропси.",
      "Це робить застосунок несумісним із мобільними браузерами."
    ]
  },
  "rl-04": {
    "prompt": "Проаналізуйте код нижче. Що станеться, якщо два елементи матимуть однаковий ID?",
    "explanation": "React вимагає, щоб ключі були унікальними серед сусідів. Дублікати ключів спричиняють непередбачувану поведінку при оновленні, і React видасть попередження під час розробки.",
    "interviewTip": "Якщо у ваших даних немає унікальних ID, можна комбінувати поля (наприклад, item.type + item.id), щоб створити унікальний рядок.",
    "options": [
      "React відрендерить тільки перший елемент.",
      "Застосунок миттєво зламається (crash).",
      "React покаже попередження в консолі про дублікати ключів.",
      "Елементи будуть об'єднані в один тег <li>."
    ]
  },
  "rl-05": {
    "prompt": "Де саме слід розміщувати пропс 'key' при рендерингу списку власних компонентів?",
    "explanation": "Ключ завжди має бути на найзовнішньому елементі, який повертає функція map, щоб React міг відстежувати цей елемент у колекції.",
    "interviewTip": "Якщо ви огортаєте свій компонент у <div> або фрагмент всередині map, ключ має бути саме на цій обгортці.",
    "options": [
      "Всередині тегу <ul>.",
      "На кореневому елементі всередині callback-функції .map().",
      "Всередині тегу <h1> у компоненті UserCard.",
      "Ключі потрібні тільки для стандартних HTML-тегів, як-от <li>."
    ]
  },
  "rl-06": {
    "prompt": "Які з наведених варіантів є рекомендованими джерелами для значення 'key'?",
    "explanation": "Ключі мають бути стабільними. Випадкові числа або позначки часу змінюються при кожному рендері, що змушує весь список демонтуватися та монтуватися заново, знищуючи продуктивність.",
    "interviewTip": "Стабільні унікальні ID — це «золотий стандарт» для ключів у React.",
    "options": [
      "ID з бази даних (наприклад, UUID або первинний ключ).",
      "Результат виконання Math.random().",
      "Унікальна властивість, як-от 'slug' або 'username'.",
      "Поточна мітка часу (Date.now())."
    ]
  },
  "rl-07": {
    "prompt": "Як відрендерити список, якщо ви не хочете додавати зайвий тег-обгортку на кшталт <div> або <li>?",
    "explanation": "Скорочений синтаксис фрагмента <> не підтримує пропс 'key'. У такому разі ви повинні використовувати повний запис: <React.Fragment key={...}>.",
    "interviewTip": "Це один із небагатьох випадків, коли повний синтаксис Fragment є обов'язковим.",
    "options": [
      "Використовувати скорочений синтаксис Fragment <>...</>.",
      "Використовувати повний синтаксис <React.Fragment> із ключем.",
      "Ви обов'язково повинні використовувати <div>; іншого шляху немає.",
      "Повернути масив елементів безпосередньо."
    ]
  },
  "rl-08": {
    "prompt": "Яким буде результат наступної логіки рендерингу?",
    "explanation": "React дозволяє змішувати динамічний контент (масиви) зі статичним JSX. Він просто відрендерить їх у тому порядку, в якому вони з'являються в коді.",
    "interviewTip": "Це корисно для додавання елементів «Створити новий» або «Завантажити ще» в кінець динамічного списку.",
    "options": [
      "Список із A, B, а потім 'Extra'.",
      "Помилка: не можна змішувати ітеровані елементи зі статичними.",
      "Буде відрендерено тільки 'Extra'.",
      "Список з 'Extra', а потім A, B."
    ]
  },
  "rl-09": {
    "prompt": "Що робить React, коли виявляє зміну ключа для компонента (наприклад, ключ 1 став ключем 2)?",
    "explanation": "Зміна ключа вказує React, що ідентичність компонента змінилася. Він знищує старий екземпляр (разом із його локальним станом) і створює новий.",
    "interviewTip": "Ви можете навмисно змінювати ключ, щоб «скинути» компонент (наприклад, форму) до початкового стану.",
    "options": [
      "Він оновлює пропси існуючого компонента.",
      "Він демонтує (unmount) старий компонент і монтує абсолютно новий.",
      "Він ігнорує зміну для збереження продуктивності.",
      "Він перерендерить тільки дочірні елементи цього компонента."
    ]
  },
  "rl-10": {
    "prompt": "Чи можливо використовувати об'єкт як значення ключа?",
    "explanation": "Внутрішньо React перетворює ключі на рядки. Використання об'єкта призведе до того, що всі елементи отримають рядок '[object Object]', що зробить їх неунікальними.",
    "interviewTip": "Завжди обирайте примітивне значення (рядок або число) для вашого ключа.",
    "options": [
      "Так, React автоматично перетворить об'єкт у рядок.",
      "Ні, ключі мають бути рядками або числами.",
      "Тільки якщо об'єкт має метод toString().",
      "Так, але тільки в React 18+."
    ]
  },
  "rl-11": {
    "prompt": "Що станеться, якщо ви взагалі не вкажете ключ під час використання map?",
    "explanation": "React за замовчуванням використає індекси масиву як ключі, але виведе попередження в консоль, щоб сповістити вас про можливі проблеми з продуктивністю та баги.",
    "interviewTip": "Попередження в консолі часто ігноруються — завжди перевіряйте логи під час розробки.",
    "options": [
      "Застосунок впаде з помилкою 'KeyMissingError'.",
      "React відрендерить список правильно, але покаже попередження в консолі.",
      "React автоматично використає випадкове число як ключ.",
      "Браузер приховає елементи списку."
    ]
  },
  "rl-12": {
    "prompt": "Які з наведених сценаріїв обов'язково потребують унікальних ключів?",
    "explanation": "Сортування та видалення елементів — це операції, де алгоритм порівняння React критично покладається на ключі, щоб уникнути багів зі станом елементів.",
    "interviewTip": "Якщо користувач може маніпулювати списком, стабільний ключ є обов'язковим.",
    "options": [
      "Список новин, який можна сортувати за датою.",
      "Список полів вводу, де користувачі можуть додавати або видаляти рядки.",
      "Статичне меню навігації з 3 посиланнями, які ніколи не змінюються.",
      "Список повідомлень чату, де нові додаються в кінець."
    ]
  },
  "rl-13": {
    "prompt": "Як відрендерити список у зворотному порядку за допомогою .map()?",
    "explanation": "Оскільки .reverse() мутує оригінальний масив, ми спочатку створюємо копію `[...data]`, а потім застосовуємо reverse та map.",
    "interviewTip": "Завжди тримайте трансформації даних «незмінними» (immutable), щоб уникнути побічних ефектів.",
    "options": [
      "Наведена вище логіка є правильною.",
      "React має директиву v-for-reverse.",
      "Ви повинні використовувати цикл for замість цього.",
      "Розвернути DOM-елементи за допомогою CSS."
    ]
  },
  "rl-14": {
    "prompt": "Який найефективніший спосіб рендерингу дуже довгого списку (наприклад, 10 000 елементів)?",
    "explanation": "Віртуалізація (Windowing) рендерить лише ті елементи, які зараз видно у вікні перегляду, значно зменшуючи кількість DOM-вузлів.",
    "interviewTip": "Згадайте бібліотеки 'react-window' або 'react-virtualized' для вирішення цього завдання.",
    "options": [
      "Стандартна функція .map().",
      "Техніка під назвою 'Windowing' або 'Virtualization'.",
      "Використання циклу while для швидкості.",
      "Хук useList() від React."
    ]
  },
  "rl-15": {
    "prompt": "Чому в даному фрагменті 'Math.random()' — це поганий вибір для ключа?",
    "explanation": "При кожному рендерингу створюється новий випадковий ключ. React думає, що це абсолютно новий елемент, і створює його з нуля, втрачаючи фокус та стан.",
    "interviewTip": "Ключ повинен залишатися незмінним для одного й того самого елемента між рендерами.",
    "options": [
      "Це занадто повільно обчислюється.",
      "Це не рядок (string).",
      "Це змушує компонент перестворюватися при кожному рендерингу, втрачаючи фокус та стан.",
      "React дозволяє використовувати тільки цілі числа як ключі."
    ]
  },
  "rl-16": {
    "prompt": "Як відфільтрувати список перед рендерингом?",
    "explanation": "Ланцюжок методів (.filter().map()) є стандартним і найбільш читабельним способом обробки умовного рендерингу списків.",
    "interviewTip": "Для великих списків варто огорнути цю логіку в useMemo, щоб уникнути перерахунків при кожному рендері.",
    "options": [
      "Наведена вище логіка є правильною.",
      "React використовує 'v-if' всередині 'v-for'.",
      "Ви не можете фільтрувати дані всередині інструкції return.",
      "Використовувати окремий useEffect для фільтрації."
    ]
  },
  "rl-17": {
    "prompt": "Якщо елемент списку має власний стан (наприклад, перемикач), що станеться з цим станом, якщо елемент видалити з масиву?",
    "explanation": "Стан прив'язаний до екземпляра компонента в дереві DOM. Коли елемент видаляється з масиву, його компонент демонтується, а його стан знищується.",
    "interviewTip": "Якщо дані мають зберегтися після видалення зі списку, їх слід зберігати в стані батька або в глобальному сховищі.",
    "options": [
      "Стан переміщується до наступного елемента в списку.",
      "Стан назавжди знищується, коли компонент демонтується (unmount).",
      "Стан зберігається в батьківському компоненті.",
      "React видає попередження 'StateOrphanWarning'."
    ]
  }
}
