{
  "rl-01": {
    "prompt": "Яка основна мета пропса 'key' при рендерингу списку в React?",
    "explanation": "Ключі слугують стабільними ідентифікаторами для елементів між рендерами. Без них React може некоректно оновлювати список або повністю перерендерити його, втрачаючи стан.",
    "interviewTip": "Ключі повинні бути унікальними серед сусідніх елементів і стабільними (не змінюватися при кожному рендері)."
  },
  "rl-02": {
    "prompt": "Який метод JavaScript найчастіше використовується для перетворення масиву даних у список компонентів React?",
    "explanation": "Метод .map() ідеально підходить, оскільки він повертає новий масив тієї ж довжини, дозволяючи огорнути кожен елемент даних у JSX.",
    "interviewTip": "Пам'ятайте, що .forEach() повертає undefined і нічого не відрендерить у JSX."
  },
  "rl-03": {
    "prompt": "У чому полягає потенційний недолік використання індексу масиву як ключа?",
    "explanation": "Якщо порядок елементів зміниться, індекс залишиться прив'язаним до позиції, а не до контенту. Це заплутує механізм керування станом React для цих компонентів.",
    "interviewTip": "Використовуйте індекс як ключ лише якщо список статичний (ніколи не змінюється, не фільтрується і не сортується)."
  },
  "rl-04": {
    "prompt": "Проаналізуйте код нижче. Що станеться, якщо два елементи матимуть однаковий ID?",
    "explanation": "React вимагає, щоб ключі були унікальними серед сусідів. Дублікати ключів спричиняють непередбачувану поведінку при оновленні, і React видасть попередження під час розробки.",
    "interviewTip": "Якщо у ваших даних немає унікальних ID, можна комбінувати поля (наприклад, item.type + item.id), щоб створити унікальний рядок."
  },
  "rl-05": {
    "prompt": "Де саме слід розміщувати пропс 'key' при рендерингу списку власних компонентів?",
    "explanation": "Ключ завжди має бути на найзовнішньому елементі, який повертає функція map, щоб React міг відстежувати цей елемент у колекції.",
    "interviewTip": "Якщо ви огортаєте свій компонент у <div> або фрагмент всередині map, ключ має бути саме на цій обгортці."
  },
  "rl-06": {
    "prompt": "Які з наведених варіантів є рекомендованими джерелами для значення 'key'?",
    "explanation": "Ключі мають бути стабільними. Випадкові числа або позначки часу змінюються при кожному рендері, що змушує весь список демонтуватися та монтуватися заново, знищуючи продуктивність.",
    "interviewTip": "Стабільні унікальні ID — це «золотий стандарт» для ключів у React."
  },
  "rl-07": {
    "prompt": "Як відрендерити список, якщо ви не хочете додавати зайвий тег-обгортку на кшталт <div> або <li>?",
    "explanation": "Скорочений синтаксис фрагмента <> не підтримує пропс 'key'. У такому разі ви повинні використовувати повний запис: <React.Fragment key={...}>.",
    "interviewTip": "Це один із небагатьох випадків, коли повний синтаксис Fragment є обов'язковим."
  },
  "rl-08": {
    "prompt": "Яким буде результат наступної логіки рендерингу?",
    "explanation": "React дозволяє змішувати динамічний контент (масиви) зі статичним JSX. Він просто відрендерить їх у тому порядку, в якому вони з'являються в коді.",
    "interviewTip": "Це корисно для додавання елементів «Створити новий» або «Завантажити ще» в кінець динамічного списку."
  },
  "rl-09": {
    "prompt": "Що робить React, коли виявляє зміну ключа для компонента (наприклад, ключ 1 став ключем 2)?",
    "explanation": "Зміна ключа вказує React, що ідентичність компонента змінилася. Він знищує старий екземпляр (разом із його локальним станом) і створює новий.",
    "interviewTip": "Ви можете навмисно змінювати ключ, щоб «скинути» компонент (наприклад, форму) до початкового стану."
  },
  "rl-10": {
    "prompt": "Чи можливо використовувати об'єкт як значення ключа?",
    "explanation": "Внутрішньо React перетворює ключі на рядки. Використання об'єкта призведе до того, що всі елементи отримають рядок '[object Object]', що зробить їх неунікальними.",
    "interviewTip": "Завжди обирайте примітивне значення (рядок або число) для вашого ключа."
  },
  "rl-11": {
    "prompt": "Що станеться, якщо ви взагалі не вкажете ключ під час використання map?",
    "explanation": "React за замовчуванням використає індекси масиву як ключі, але виведе попередження в консоль, щоб сповістити вас про можливі проблеми з продуктивністю та баги.",
    "interviewTip": "Попередження в консолі часто ігноруються — завжди перевіряйте логи під час розробки."
  },
  "rl-12": {
    "prompt": "Які з наведених сценаріїв обов'язково потребують унікальних ключів?",
    "explanation": "Сортування та видалення елементів — це операції, де алгоритм порівняння React критично покладається на ключі, щоб уникнути багів зі станом елементів.",
    "interviewTip": "Якщо користувач може маніпулювати списком, стабільний ключ є обов'язковим."
  },
  "rl-13": {
    "prompt": "Як відрендерити список у зворотному порядку за допомогою .map()?",
    "explanation": "Оскільки .reverse() мутує оригінальний масив, ми спочатку створюємо копію `[...data]`, а потім застосовуємо reverse та map.",
    "interviewTip": "Завжди тримайте трансформації даних «незмінними» (immutable), щоб уникнути побічних ефектів."
  },
  "rl-14": {
    "prompt": "Який найефективніший спосіб рендерингу дуже довгого списку (наприклад, 10 000 елементів)?",
    "explanation": "Віртуалізація (Windowing) рендерить лише ті елементи, які зараз видно у вікні перегляду, значно зменшуючи кількість DOM-вузлів.",
    "interviewTip": "Згадайте бібліотеки 'react-window' або 'react-virtualized' для вирішення цього завдання."
  },
  "rl-15": {
    "prompt": "Чому в даному фрагменті 'Math.random()' — це поганий вибір для ключа?",
    "explanation": "При кожному рендерингу створюється новий випадковий ключ. React думає, що це абсолютно новий елемент, і створює його з нуля, втрачаючи фокус та стан.",
    "interviewTip": "Ключ повинен залишатися незмінним для одного й того самого елемента між рендерами."
  },
  "rl-16": {
    "prompt": "Як відфільтрувати список перед рендерингом?",
    "explanation": "Ланцюжок методів (.filter().map()) є стандартним і найбільш читабельним способом обробки умовного рендерингу списків.",
    "interviewTip": "Для великих списків варто огорнути цю логіку в useMemo, щоб уникнути перерахунків при кожному рендері."
  },
  "rl-17": {
    "prompt": "Якщо елемент списку має власний стан (наприклад, перемикач), що станеться з цим станом, якщо елемент видалити з масиву?",
    "explanation": "Стан прив'язаний до екземпляра компонента в дереві DOM. Коли елемент видаляється з масиву, його компонент демонтується, а його стан знищується.",
    "interviewTip": "Якщо дані мають зберегтися після видалення зі списку, їх слід зберігати в стані батька або в глобальному сховищі."
  }
}
