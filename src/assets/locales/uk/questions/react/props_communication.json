{
  "pc-01": {
    "prompt": "Яким буде результат наступного фрагмента коду?",
    "explanation": "Оскільки '25' було передано як рядок (у лапках), оператор '+' виконує конкатенацію рядків замість додавання чисел.",
    "interviewTip": "Завжди передавайте числа у фігурних дужках, наприклад, age={25}, щоб гарантувати збереження числового типу даних.",
    "options": [
      "26",
      "Помилка: Props доступні тільки для читання",
      "251",
      "undefined"
    ]
  },
  "pc-02": {
    "prompt": "Яке твердження найкраще описує природу 'props' у React?",
    "explanation": "React дотримується суворого правила незмінності (immutability) для пропсів, щоб забезпечити передбачуваність «Односпрямованого потоку даних» та полегшити відлагодження.",
    "interviewTip": "Ставтеся до пропсів як до «знімків» (snapshots) даних, наданих батьківським компонентом.",
    "options": [
      "Props є immutable; компонент ніколи не повинен змінювати власні пропси.",
      "Props є mutable і можуть використовуватися для збереження локальних змін компонента.",
      "Props використовуються лише для передачі CSS-класів дочірнім елементам.",
      "Props можна передавати тільки від дочірнього компонента до батьківського."
    ]
  },
  "pc-03": {
    "prompt": "Що буде відрендерено за такої структури компонентів?",
    "explanation": "'children' — це спеціальний пропс у React, який автоматично містить усе, що розміщено між відкриваючим та закриваючим тегами компонента.",
    "interviewTip": "Цей патерн відомий як 'Containment' (вміщення) або 'Composition' (композиція).",
    "options": [
      "Порожній div із класом 'container'.",
      "div, що містить тег p із текстом 'Hello World'.",
      "Рядок 'children'.",
      "Нічого, children — це невалідна назва для пропса."
    ]
  },
  "pc-04": {
    "prompt": "Які з наведених варіантів є валідними способами встановлення значень за замовчуванням для пропсів у функціональному компоненті?",
    "explanation": "Значення за замовчуванням через деструктуризацію ES6 є сучасним стандартом. .defaultProps — це застарілий спосіб. Оператор АБО всередині JSX — це швидкий інлайновий варіант.",
    "interviewTip": "Для функціональних компонентів команда React сьогодні рекомендує використовувати саме деструктуризацію ES6.",
    "options": [
      "Використання значень за замовчуванням у деструктуризації ES6: function MyComponent({ name = 'Guest' }) { ... }",
      "Використання властивості .defaultProps: MyComponent.defaultProps = { name: 'Guest' };",
      "Визначення значення за замовчуванням всередині return: <h1>{props.name || 'Guest'}</h1>",
      "Використання хука useState для встановлення значення пропса."
    ]
  },
  "pc-05": {
    "prompt": "Як дочірній компонент «надсилає дані назад» своєму батькові?",
    "explanation": "Батьки передають функції. Діти викликають ці функції, передаючи дані як аргументи. Цей патерн 'Events Up' (події вгору) зберігає односпрямований потік.",
    "interviewTip": "Це часто називають 'Lifting State Up' (підняття стану), коли дочірній елемент ініціює оновлення стану батька.",
    "options": [
      "Шляхом прямої модифікації об'єкта props.",
      "Використовуючи callback-функцію, передану від батька як пропс.",
      "Шляхом генерації кастомної події DOM через document.dispatchEvent.",
      "Шляхом оновлення глобальної змінної window."
    ]
  },
  "pc-06": {
    "prompt": "Що таке 'Prop Drilling' (прокидання пропсів)?",
    "explanation": "Прокидання пропсів ускладнює повторне використання компонентів, оскільки проміжні компоненти змушені обробляти дані, які їм насправді не потрібні.",
    "interviewTip": "Context API або бібліотеки керування станом (як Redux чи Zustand) є поширеними рішеннями для уникнення надмірного прокидання.",
    "options": [
      "Техніка для оптимізації продуктивності пропсів.",
      "Процес передачі пропсів через кілька рівнів компонентів лише для того, щоб вони досягли глибоко вкладеного нащадка.",
      "Спосіб автоматичної генерації пропсів за допомогою циклу.",
      "Метод, що використовується для валідації типів пропсів."
    ]
  },
  "pc-07": {
    "prompt": "Проаналізуйте код. Що станеться при натисканні на кнопку?",
    "explanation": "Посилання на функцію alertMsg передається як пропс. Коли натискається дочірня кнопка, вона виконує функцію за цим посиланням.",
    "interviewTip": "Це демонструє, як функціональні пропси слугують містком для комунікації між компонентами.",
    "options": [
      "Нічого не станеться, бо onAction не є нативною подією.",
      "Спрацює alert 'Hello!'.",
      "Помилка: 'onAction is not a function'.",
      "Кнопка зникне."
    ]
  },
  "pc-08": {
    "prompt": "Що робить оператор розширення (spread operator) '...' у даному контексті?",
    "explanation": "Оператор розширення розгортає ключі об'єкта в окремі атрибути всередині JSX.",
    "interviewTip": "Хоча це зручно, надмірне використання spread-оператора може ускладнити розуміння того, від яких саме даних залежить компонент.",
    "options": [
      "Передає один пропс із назвою 'userData', що містить об'єкт.",
      "Передає 'name' та 'age' як окремі індивідуальні пропси компоненту UserProfile.",
      "Видаляє властивості name та age після їх передачі.",
      "Перетворює об'єкт у рядок JSON."
    ]
  },
  "pc-09": {
    "prompt": "Що станеться, якщо ви передасте пропс під назвою 'class' власному React-компоненту?",
    "explanation": "У той час як 'class' зарезервований для HTML-елементів у JSX (де потрібно використовувати className), для *власного* компонента це просто ключ в об'єкті. Проте це заплутує, і такого зазвичай уникають.",
    "interviewTip": "Будьте послідовними та використовуйте 'className' навіть для власних компонентів, щоб уникнути плутанини з нативними DOM-елементами.",
    "options": [
      "React автоматично конвертує його в 'className'.",
      "Він працює як будь-який інший пропс; ви можете отримати до нього доступ через props.class.",
      "Застосунок впаде, бо 'class' є зарезервованим словом у JS.",
      "Пропс буде проігнорований і не передасться."
    ]
  },
  "pc-10": {
    "prompt": "Яким у наступному коді буде початкове значення 'isActive' у дочірньому компоненті?",
    "explanation": "У JSX, якщо пропс передається без значення, він за замовчуванням набуває булевого значення 'true'.",
    "interviewTip": "Це схоже на HTML-атрибути, такі як 'disabled' або 'required'.",
    "options": ["\"isActive\"", "undefined", "true", "null"]
  },
  "pc-11": {
    "prompt": "Який найкращий спосіб передати кілька пов'язаних фрагментів даних (наприклад, ім'я, email, аватар)?",
    "explanation": "Передача одного об'єкта робить API компонента чистішим і легшим для оновлення, особливо якщо структура даних надходить безпосередньо з API.",
    "interviewTip": "Якщо компоненту потрібне лише одне маленьке поле з об'єкта, передача окремих пропсів може бути кращою для продуктивності та незалежності компонентів.",
    "options": [
      "Передати їх усі як окремі індивідуальні пропси.",
      "Об'єднати їх в один об'єктний пропс (наприклад, user={userObj}).",
      "Обидва варіанти валідні, але об'єктний пропс часто виглядає охайніше для пов'язаних даних.",
      "Глобальні змінні краще підходять для цього."
    ]
  },
  "pc-12": {
    "prompt": "Чи можна передати інший React-компонент як пропс іншому компоненту?",
    "explanation": "Це потужний патерн для створення «слотів» (Slots). Він дозволяє впроваджувати компоненти інтерфейсу в специфічні частини макета.",
    "interviewTip": "Часто цей спосіб кращий за глибоку вкладеність або складну умовну логіку всередині компонента.",
    "options": [
      "Ні, пропси можуть бути тільки примітивними типами даних.",
      "Так, елементи є JavaScript-об'єктами і можуть передаватися як пропси.",
      "Тільки через пропс children.",
      "Тільки якщо ви використовуєте префікс 'render'."
    ]
  },
  "pc-13": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "React «заморожує» об'єкт пропсів. Спроба мутувати його призведе до помилки або просто не спрацює, залежно від середовища.",
    "interviewTip": "Якщо вам потрібно змінити дані, ці дані мають бути «Станом» (State), а не «Пропсами».",
    "options": [
      "\"Alice\"",
      "TypeError (у strict mode), оскільки пропси доступні тільки для читання.",
      "undefined",
      "Стан батьківського компонента оновиться на 'Alice'."
    ]
  },
  "pc-14": {
    "prompt": "Які з наведених типів даних можна передавати як пропси в React?",
    "explanation": "Пропси — це просто JavaScript. Будь-що, що можна присвоїти змінній у JS, можна передати як пропс.",
    "interviewTip": "Ця гнучкість — причина того, чому React має таку високу здатність до композиції.",
    "options": [
      "Функції",
      "Об'єкти та масиви",
      "Числа та булеві значення",
      "Інші JSX-елементи"
    ]
  },
  "pc-15": {
    "prompt": "Яким буде результат логічного виразу в цьому призначенні пропса?",
    "explanation": "Фігурні дужки дозволяють вставити будь-який вираз JS. Результат виразу (true/false) — це те, що передається як значення пропса.",
    "interviewTip": "Це чистий спосіб обробки станів інтерфейсу безпосередньо в шаблоні.",
    "options": [
      "Кнопка заблокована (disabled), якщо isLoading або isError має значення true.",
      "Кнопка заблокована тільки якщо обидва значення true.",
      "Пропс ігнорується, бо містить логіку.",
      "Синтаксична помилка."
    ]
  },
  "pc-16": {
    "prompt": "Як отримати доступ до значення пропса у функціональному компоненті?",
    "explanation": "Функціональні компоненти отримують 'props' як перший параметр. Ви можете використовувати props.name або деструктурувати його одразу.",
    "interviewTip": "Деструктуризація є стандартом: const MyComponent = ({ name }) => { ... }",
    "options": [
      "this.props.name",
      "З першого аргументу функції.",
      "Використовуючи хук useProps().",
      "Шляхом імпорту з React."
    ]
  },
  "pc-17": {
    "prompt": "Для чого використовується бібліотека 'Prop-Types'?",
    "explanation": "Prop-Types дозволяє оголосити очікуваний тип (рядок, число тощо) для кожного пропса. React покаже попередження в консолі, якщо передано неправильний тип.",
    "interviewTip": "Хоча TypeScript значною мірою замінив Prop-Types у сучасних проектах, вона все ще широко використовується в існуючих кодових базах.",
    "options": [
      "Для прискорення передачі пропсів.",
      "Для перевірки типів пропсів під час виконання (runtime), щоб виявляти баги під час розробки.",
      "Для перетворення пропсів у JSON-рядки.",
      "Для автоматичної генерації документації."
    ]
  }
}
