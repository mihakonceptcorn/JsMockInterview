{
  "pc-01": {
    "prompt": "Яким буде результат наступного фрагмента коду?",
    "explanation": "Оскільки '25' було передано як рядок (у лапках), оператор '+' виконує конкатенацію рядків замість додавання чисел.",
    "interviewTip": "Завжди передавайте числа у фігурних дужках, наприклад, age={25}, щоб гарантувати збереження числового типу даних."
  },
  "pc-02": {
    "prompt": "Яке твердження найкраще описує природу 'props' у React?",
    "explanation": "React дотримується суворого правила незмінності (immutability) для пропсів, щоб забезпечити передбачуваність «Односпрямованого потоку даних» та полегшити відлагодження.",
    "interviewTip": "Ставтеся до пропсів як до «знімків» (snapshots) даних, наданих батьківським компонентом."
  },
  "pc-03": {
    "prompt": "Що буде відрендерено за такої структури компонентів?",
    "explanation": "'children' — це спеціальний пропс у React, який автоматично містить усе, що розміщено між відкриваючим та закриваючим тегами компонента.",
    "interviewTip": "Цей патерн відомий як 'Containment' (вміщення) або 'Composition' (композиція)."
  },
  "pc-04": {
    "prompt": "Які з наведених варіантів є валідними способами встановлення значень за замовчуванням для пропсів у функціональному компоненті?",
    "explanation": "Значення за замовчуванням через деструктуризацію ES6 є сучасним стандартом. .defaultProps — це застарілий спосіб. Оператор АБО всередині JSX — це швидкий інлайновий варіант.",
    "interviewTip": "Для функціональних компонентів команда React сьогодні рекомендує використовувати саме деструктуризацію ES6."
  },
  "pc-05": {
    "prompt": "Як дочірній компонент «надсилає дані назад» своєму батькові?",
    "explanation": "Батьки передають функції. Діти викликають ці функції, передаючи дані як аргументи. Цей патерн 'Events Up' (події вгору) зберігає односпрямований потік.",
    "interviewTip": "Це часто називають 'Lifting State Up' (підняття стану), коли дочірній елемент ініціює оновлення стану батька."
  },
  "pc-06": {
    "prompt": "Що таке 'Prop Drilling' (прокидання пропсів)?",
    "explanation": "Прокидання пропсів ускладнює повторне використання компонентів, оскільки проміжні компоненти змушені обробляти дані, які їм насправді не потрібні.",
    "interviewTip": "Context API або бібліотеки керування станом (як Redux чи Zustand) є поширеними рішеннями для уникнення надмірного прокидання."
  },
  "pc-07": {
    "prompt": "Проаналізуйте код. Що станеться при натисканні на кнопку?",
    "explanation": "Посилання на функцію alertMsg передається як пропс. Коли натискається дочірня кнопка, вона виконує функцію за цим посиланням.",
    "interviewTip": "Це демонструє, як функціональні пропси слугують містком для комунікації між компонентами."
  },
  "pc-08": {
    "prompt": "Що робить оператор розширення (spread operator) '...' у даному контексті?",
    "explanation": "Оператор розширення розгортає ключі об'єкта в окремі атрибути всередині JSX.",
    "interviewTip": "Хоча це зручно, надмірне використання spread-оператора може ускладнити розуміння того, від яких саме даних залежить компонент."
  },
  "pc-09": {
    "prompt": "Що станеться, якщо ви передасте пропс під назвою 'class' власному React-компоненту?",
    "explanation": "У той час як 'class' зарезервований для HTML-елементів у JSX (де потрібно використовувати className), для *власного* компонента це просто ключ в об'єкті. Проте це заплутує, і такого зазвичай уникають.",
    "interviewTip": "Будьте послідовними та використовуйте 'className' навіть для власних компонентів, щоб уникнути плутанини з нативними DOM-елементами."
  },
  "pc-10": {
    "prompt": "Яким у наступному коді буде початкове значення 'isActive' у дочірньому компоненті?",
    "explanation": "У JSX, якщо пропс передається без значення, він за замовчуванням набуває булевого значення 'true'.",
    "interviewTip": "Це схоже на HTML-атрибути, такі як 'disabled' або 'required'."
  },
  "pc-11": {
    "prompt": "Який найкращий спосіб передати кілька пов'язаних фрагментів даних (наприклад, ім'я, email, аватар)?",
    "explanation": "Передача одного об'єкта робить API компонента чистішим і легшим для оновлення, особливо якщо структура даних надходить безпосередньо з API.",
    "interviewTip": "Якщо компоненту потрібне лише одне маленьке поле з об'єкта, передача окремих пропсів може бути кращою для продуктивності та незалежності компонентів."
  },
  "pc-12": {
    "prompt": "Чи можна передати інший React-компонент як пропс іншому компоненту?",
    "explanation": "Це потужний патерн для створення «слотів» (Slots). Він дозволяє впроваджувати компоненти інтерфейсу в специфічні частини макета.",
    "interviewTip": "Часто цей спосіб кращий за глибоку вкладеність або складну умовну логіку всередині компонента."
  },
  "pc-13": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "React «заморожує» об'єкт пропсів. Спроба мутувати його призведе до помилки або просто не спрацює, залежно від середовища.",
    "interviewTip": "Якщо вам потрібно змінити дані, ці дані мають бути «Станом» (State), а не «Пропсами»."
  },
  "pc-14": {
    "prompt": "Які з наведених типів даних можна передавати як пропси в React?",
    "explanation": "Пропси — це просто JavaScript. Будь-що, що можна присвоїти змінній у JS, можна передати як пропс.",
    "interviewTip": "Ця гнучкість — причина того, чому React має таку високу здатність до композиції."
  },
  "pc-15": {
    "prompt": "Яким буде результат логічного виразу в цьому призначенні пропса?",
    "explanation": "Фігурні дужки дозволяють вставити будь-який вираз JS. Результат виразу (true/false) — це те, що передається як значення пропса.",
    "interviewTip": "Це чистий спосіб обробки станів інтерфейсу безпосередньо в шаблоні."
  },
  "pc-16": {
    "prompt": "Як отримати доступ до значення пропса у функціональному компоненті?",
    "explanation": "Функціональні компоненти отримують 'props' як перший параметр. Ви можете використовувати props.name або деструктурувати його одразу.",
    "interviewTip": "Деструктуризація є стандартом: const MyComponent = ({ name }) => { ... }"
  },
  "pc-17": {
    "prompt": "Для чого використовується бібліотека 'Prop-Types'?",
    "explanation": "Prop-Types дозволяє оголосити очікуваний тип (рядок, число тощо) для кожного пропса. React покаже попередження в консолі, якщо передано неправильний тип.",
    "interviewTip": "Хоча TypeScript значною мірою замінив Prop-Types у сучасних проектах, вона все ще широко використовується в існуючих кодових базах."
  }
}
