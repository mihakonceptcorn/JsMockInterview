{
  "dp-01": {
    "prompt": "Яка основна мета патерна 'Compound Components' (Складені компоненти)?",
    "explanation": "Складені компоненти (як <Select> та <Option>) спільно використовують стан «за лаштунками», що дає розробнику більше контролю над структурою рендерингу, зберігаючи логіку інкапсульованою.",
    "interviewTip": "Згадайте стандартні HTML-теги <select> та <option>. Вони працюють як єдине ціле; це і є нативний складений компонент.",
    "options": [
      "Зробити рендеринг компонентів на 50% швидшим.",
      "Дозволити групі компонентів працювати разом і ділитися неявним станом без prop drilling.",
      "Поєднати React з іншими фреймворками, такими як Vue.",
      "Приховати всю логіку всередині одного монолітного компонента."
    ]
  },
  "dp-02": {
    "prompt": "Як у патерні Compound Component внутрішній стан зазвичай передається дочірнім елементам?",
    "explanation": "Хоча раніше використовувався cloneElement, зараз React Context є кращим способом передачі стану всередині групи складених компонентів.",
    "interviewTip": "Зауважте, що Context безпечніший і гнучкіший за cloneElement, оскільки він працює, навіть якщо дочірні елементи обгорнуті в інші div-и.",
    "options": [
      "Шляхом ручної передачі пропсів кожному дочірньому елементу.",
      "Використовуючи React Context для надання стану всім вкладеним нащадкам.",
      "Використовуючи глобальні змінні window.",
      "Шляхом клонування кожного дочірнього елемента та впровадження пропсів через React.cloneElement."
    ]
  },
  "dp-03": {
    "prompt": "Що таке 'Higher-Order Component' (HOC) — компонент вищого порядку?",
    "explanation": "HOC — це патерн для повторного використання логіки компонентів. Вони діють як обгортки, які «посилюють» оригінальний компонент новими пропсами або поведінкою.",
    "interviewTip": "Хоча HOC стали менш поширеними після появи хуків, вони все ще використовуються для наскрізної логіки, такої як аутентифікація або логування.",
    "options": [
      "Компонент, який рендериться у верхній частині сторінки.",
      "Функція, яка приймає компонент і повертає новий компонент із доданою функціональністю.",
      "Хук, який замінює потребу в стані (state).",
      "Компонент, що містить понад 1000 рядків коду."
    ]
  },
  "dp-04": {
    "prompt": "Проаналізуйте патерн 'Render Prop'. Що саме передається дочірньому елементу?",
    "explanation": "Render prop — це пропс у вигляді функції, яку компонент використовує, щоб знати, що рендерити. Він «ділиться» своїм внутрішнім станом із цією функцією.",
    "interviewTip": "Render props дуже гнучкі, але іноді можуть призвести до «пекла обгорток» (wrapper hell) при надмірній вкладеності.",
    "options": [
      "Статичний об'єкт.",
      "Функція, яка каже компоненту, що рендерити на основі внутрішнього стану.",
      "Пряме посилання на DOM.",
      "Булевий прапорець (flag)."
    ]
  },
  "dp-05": {
    "prompt": "Які з наведених характеристик притаманні 'Controlled Component' (Керованому компоненту)?",
    "explanation": "Керовані компоненти дозволяють React бути «Єдиним джерелом істини». Некеровані компоненти покладаються на DOM (і Ref-и) для зберігання даних.",
    "interviewTip": "Використовуйте керовані компоненти майже для всього, якщо у вас немає специфічної причини для продуктивності використовувати Ref.",
    "options": [
      "Дані компонента зберігаються в React state.",
      "Компонент керує власним внутрішнім станом через DOM.",
      "Зміни обробляються через callback onChange, який оновлює стан.",
      "Пропс value встановлюється батьківським компонентом."
    ]
  },
  "dp-06": {
    "prompt": "Як реалізувати патерн 'Controlled Props', щоб дозволити користувачеві «перехопити» внутрішній стан компонента?",
    "explanation": "Цей патерн дозволяє компоненту керувати власним станом за замовчуванням, але дає батьківському компоненту можливість «контролювати» його, якщо передано відповідний пропс.",
    "interviewTip": "Це поширений патерн у просунутих бібліотеках інтерфейсу, таких як Downshift або Material UI.",
    "options": [
      "Код вище показує логіку для компонента, який може бути як керованим, так і некерованим.",
      "Шляхом постійного використання глобального Redux store.",
      "Шляхом повного видалення внутрішнього стану.",
      "Примушуючи користувача передавати всі пропси."
    ]
  },
  "dp-07": {
    "prompt": "Що таке патерн 'Container/Presentational'?",
    "explanation": "Презентаційні компоненти відповідають лише за вигляд. Контейнери — «розумні», вони відповідають за логіку роботи (API-запити, стан).",
    "interviewTip": "Хуки значною мірою замінили цей патерн, оскільки тепер ви можете винести «розумну» логіку в кастомний хук замість компонента-обгортки.",
    "options": [
      "Патерн, що розділяє отримання даних (Container) від рендерингу UI (Presentational).",
      "Спосіб помістити весь CSS у файл контейнера.",
      "Метод групування компонентів за їхнім розміром.",
      "Спосіб рендерингу React-компонентів усередині Docker-контейнера."
    ]
  },
  "dp-08": {
    "prompt": "Визначте проблему при використанні HOC (компонентів вищого порядку):",
    "explanation": "Велика вкладеність HOC ускладнює відлагодження, оскільки незрозуміло, який саме HOC передає конкретний пропс. Хуки вирішують це завдяки пласкій структурі.",
    "interviewTip": "Це одна з головних причин, чому спільнота React перейшла від HOC до хуків.",
    "options": [
      "Це змушує компонент рендеритися швидше.",
      "Це призводить до «Пекла обгорток» (Wrapper Hell), що ускладнює відстеження походження пропсів.",
      "React не дозволяє використовувати більше ніж два HOC.",
      "Компонент втратить свій стан (state)."
    ]
  },
  "dp-09": {
    "prompt": "Чого дозволяє досягти патерн 'Slot' (слоти) у React?",
    "explanation": "Слоти — це форма композиції, яка дозволяє батьківському компоненту визначати специфічні «отвори» в інтерфейсі, які дочірній компонент заповнює контентом.",
    "interviewTip": "Слотами часто легше керувати, ніж складними булевими прапорцями (flags) всередині компонента.",
    "options": [
      "Він дозволяє передавати JSX-елементи як пропси для розміщення в конкретних місцях.",
      "Він використовується для збереження даних у слоті на сервері.",
      "Він генерує випадкові ID для компонентів.",
      "Це спосіб використання 3D-моделей у React."
    ]
  },
  "dp-10": {
    "prompt": "Як за допомогою патернів уникнути 'prop drilling' (прокидання пропсів) у глибоко вкладеному дереві компонентів?",
    "explanation": "Складені компоненти використовують Context для трансляції стану всім нащадкам, фактично усуваючи потребу в ручному прокиданні пропсів.",
    "interviewTip": "Згадайте, що це зберігає API компонента «чистим», оскільки користувачі не бачать процесу передачі стану.",
    "options": [
      "Використовуючи патерн Render Prop на верхньому рівні.",
      "Використовуючи патерн Compound Components разом із React Context.",
      "Копіюючи дані в буфер обміну.",
      "Використовуючи цикл for для впровадження пропсів."
    ]
  },
  "dp-11": {
    "prompt": " які патерни вважаються «застарілими» через впровадження хуків?",
    "explanation": "Mixins (міксини) повністю застаріли. HOC та Render Props все ще валідні, але використовуються рідше, бо хуки вирішують ті ж проблеми без зайвої вкладеності.",
    "interviewTip": "Compound Components (складені компоненти) все ще дуже актуальні, бо вони вирішують іншу задачу — проектування структури UI та API.",
    "options": [
      "Mixins (Міксини).",
      "Higher-Order Components (частково).",
      "Compound Components.",
      "Render Props (частково)."
    ]
  },
  "dp-12": {
    "prompt": "Що таке патерн 'Prop Collection'?",
    "explanation": "Цей патерн спрощує роботу користувача, збираючи атрибути доступності, обробники подій та інші властивості в один об'єкт, який можна розгорнути (spread).",
    "interviewTip": "Це широко використовується в 'Headless UI' бібліотеках, таких як Radix UI або Reach UI.",
    "options": [
      "Спосіб видалення невикористаних пропсів.",
      "Патерн, де хук повертає функцію, яка надає всі необхідні пропси для конкретного елемента.",
      "Колекція всіх CSS-класів у застосунку.",
      "Спосіб зберігання пропсів у базі даних."
    ]
  }
}
