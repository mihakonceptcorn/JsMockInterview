{
  "dp-01": {
    "prompt": "Яка основна мета патерна 'Compound Components' (Складені компоненти)?",
    "explanation": "Складені компоненти (як <Select> та <Option>) спільно використовують стан «за лаштунками», що дає розробнику більше контролю над структурою рендерингу, зберігаючи логіку інкапсульованою.",
    "interviewTip": "Згадайте стандартні HTML-теги <select> та <option>. Вони працюють як єдине ціле; це і є нативний складений компонент."
  },
  "dp-02": {
    "prompt": "Як у патерні Compound Component внутрішній стан зазвичай передається дочірнім елементам?",
    "explanation": "Хоча раніше використовувався cloneElement, зараз React Context є кращим способом передачі стану всередині групи складених компонентів.",
    "interviewTip": "Зауважте, що Context безпечніший і гнучкіший за cloneElement, оскільки він працює, навіть якщо дочірні елементи обгорнуті в інші div-и."
  },
  "dp-03": {
    "prompt": "Що таке 'Higher-Order Component' (HOC) — компонент вищого порядку?",
    "explanation": "HOC — це патерн для повторного використання логіки компонентів. Вони діють як обгортки, які «посилюють» оригінальний компонент новими пропсами або поведінкою.",
    "interviewTip": "Хоча HOC стали менш поширеними після появи хуків, вони все ще використовуються для наскрізної логіки, такої як аутентифікація або логування."
  },
  "dp-04": {
    "prompt": "Проаналізуйте патерн 'Render Prop'. Що саме передається дочірньому елементу?",
    "explanation": "Render prop — це пропс у вигляді функції, яку компонент використовує, щоб знати, що рендерити. Він «ділиться» своїм внутрішнім станом із цією функцією.",
    "interviewTip": "Render props дуже гнучкі, але іноді можуть призвести до «пекла обгорток» (wrapper hell) при надмірній вкладеності."
  },
  "dp-05": {
    "prompt": "Які з наведених характеристик притаманні 'Controlled Component' (Керованому компоненту)?",
    "explanation": "Керовані компоненти дозволяють React бути «Єдиним джерелом істини». Некеровані компоненти покладаються на DOM (і Ref-и) для зберігання даних.",
    "interviewTip": "Використовуйте керовані компоненти майже для всього, якщо у вас немає специфічної причини для продуктивності використовувати Ref."
  },
  "dp-06": {
    "prompt": "Як реалізувати патерн 'Controlled Props', щоб дозволити користувачеві «перехопити» внутрішній стан компонента?",
    "explanation": "Цей патерн дозволяє компоненту керувати власним станом за замовчуванням, але дає батьківському компоненту можливість «контролювати» його, якщо передано відповідний пропс.",
    "interviewTip": "Це поширений патерн у просунутих бібліотеках інтерфейсу, таких як Downshift або Material UI."
  },
  "dp-07": {
    "prompt": "Що таке патерн 'Container/Presentational'?",
    "explanation": "Презентаційні компоненти відповідають лише за вигляд. Контейнери — «розумні», вони відповідають за логіку роботи (API-запити, стан).",
    "interviewTip": "Хуки значною мірою замінили цей патерн, оскільки тепер ви можете винести «розумну» логіку в кастомний хук замість компонента-обгортки."
  },
  "dp-08": {
    "prompt": "Визначте проблему при використанні HOC (компонентів вищого порядку):",
    "explanation": "Велика вкладеність HOC ускладнює відлагодження, оскільки незрозуміло, який саме HOC передає конкретний пропс. Хуки вирішують це завдяки пласкій структурі.",
    "interviewTip": "Це одна з головних причин, чому спільнота React перейшла від HOC до хуків."
  },
  "dp-09": {
    "prompt": "Чого дозволяє досягти патерн 'Slot' (слоти) у React?",
    "explanation": "Слоти — це форма композиції, яка дозволяє батьківському компоненту визначати специфічні «отвори» в інтерфейсі, які дочірній компонент заповнює контентом.",
    "interviewTip": "Слотами часто легше керувати, ніж складними булевими прапорцями (flags) всередині компонента."
  },
  "dp-10": {
    "prompt": "Як за допомогою патернів уникнути 'prop drilling' (прокидання пропсів) у глибоко вкладеному дереві компонентів?",
    "explanation": "Складені компоненти використовують Context для трансляції стану всім нащадкам, фактично усуваючи потребу в ручному прокиданні пропсів.",
    "interviewTip": "Згадайте, що це зберігає API компонента «чистим», оскільки користувачі не бачать процесу передачі стану."
  },
  "dp-11": {
    "prompt": " які патерни вважаються «застарілими» через впровадження хуків?",
    "explanation": "Mixins (міксини) повністю застаріли. HOC та Render Props все ще валідні, але використовуються рідше, бо хуки вирішують ті ж проблеми без зайвої вкладеності.",
    "interviewTip": "Compound Components (складені компоненти) все ще дуже актуальні, бо вони вирішують іншу задачу — проектування структури UI та API."
  },
  "dp-12": {
    "prompt": "Що таке патерн 'Prop Collection'?",
    "explanation": "Цей патерн спрощує роботу користувача, збираючи атрибути доступності, обробники подій та інші властивості в один об'єкт, який можна розгорнути (spread).",
    "interviewTip": "Це широко використовується в 'Headless UI' бібліотеках, таких як Radix UI або Reach UI."
  }
}
