{
  "ss-01": {
    "prompt": "Яку основна проблему вирішує React Query порівняно з використанням useEffect для отримання даних?",
    "explanation": "Хоча useEffect може завантажувати дані, він не підтримує кешування або фонове оновлення. React Query керує життєвим циклом ваших серверних даних за вас.",
    "interviewTip": "Зауважте, що React Query розглядає «Серверний стан» (Server State) як щось, чим клієнт не володіє, а лише «позичає».",
    "options": [
      "Він змушує API-запити працювати швидше на сервері.",
      "Він забезпечує вбудоване кешування та синхронізацію, запобігаючи зайвим дубльованим мережевим запитам.",
      "Він замінює потребу в будь-якому CSS у застосунку.",
      "Він дозволяє React підключатися безпосередньо до бази даних SQL."
    ]
  },
  "ss-02": {
    "prompt": "Проаналізуйте код. Що містить змінна 'data', поки 'isLoading' має значення true?",
    "explanation": "Під час найпершого запиту (стан початкового завантаження) 'data' має значення undefined, поки проміс не буде виконано.",
    "interviewTip": "Якщо у вас є закешовані дані з попередньої сесії, 'isLoading' може бути false, тоді як 'isFetching' буде true.",
    "options": [
      "Попередню версію даних.",
      "Порожній масив [].",
      "undefined",
      "Рядок-заглушку 'Loading...'"
    ]
  },
  "ss-03": {
    "prompt": "Для чого використовується 'queryKey' у React Query?",
    "explanation": "queryKey (зазвичай масив) підказує React Query, коли потрібно оновити дані. Якщо ключ змінюється (наприклад, ['user', id]), запит автоматично запускається знову.",
    "interviewTip": "Сприймайте queryKey як «масив залежностей» для ваших серверних даних.",
    "options": [
      "Це пароль, що використовується для доступу до API.",
      "Він слугує унікальним ідентифікатором запиту для керування кешуванням та відстеження залежностей.",
      "Це URL-адреса кінцевої точки (endpoint) API.",
      "Він визначає порядок виконання запитів."
    ]
  },
  "ss-04": {
    "prompt": "Які властивості повертає хук 'useQuery' для допомоги в керуванні станами UI?",
    "explanation": "useQuery надає багатий набір булевих прапорців та об'єктів даних для обробки будь-якого стану мережі.",
    "interviewTip": "Різниця між 'isLoading' та 'isFetching' — це поширене питання рівня Senior (початкове завантаження проти фонового оновлення).",
    "options": [
      "status (loading, error, success).",
      "isFetching (чи виконується запит у даний момент?).",
      "revalidate (функція для видалення кешу).",
      "error (об'єкт помилки, якщо запит не вдався)."
    ]
  },
  "ss-05": {
    "prompt": "Як виконувати «Мутації даних» (POST/PUT/DELETE) у React Query?",
    "explanation": "useMutation використовується для будь-яких побічних ефектів на стороні сервера. Він надає методи 'mutate' та 'mutateAsync' для ініціації виклику.",
    "interviewTip": "Завжди згадуйте про 'Invalidation' (інвалідацію) — після мутації ви зазвичай хочете повідомити React Query, що старі дані тепер є «застарілими».",
    "options": ["usePost", "useAction", "useMutation", "useUpdate"]
  },
  "ss-06": {
    "prompt": "Що робить метод 'queryClient.invalidateQueries'?",
    "explanation": "Це «магія» React Query. Після оновлення даних ви робите ключ недійсним, і інтерфейс автоматично оновлюється з новими значеннями з сервера.",
    "interviewTip": "Це також стандартний спосіб обробки запасних варіантів (fallbacks) при «оптимістичних оновленнях».",
    "options": [
      "Він видаляє всі дані з сервера.",
      "Він позначає конкретний запит як «застарілий» (stale) і запускає фонове оновлення, якщо цей запит зараз використовується.",
      "Він заважає користувачеві натиснути кнопку відправки.",
      "Він закриває всі активні мережеві з'єднання."
    ]
  },
  "ss-07": {
    "prompt": "Що таке 'Stale Time' (час застарівання) у React Query?",
    "explanation": "За замовчуванням staleTime дорівнює 0, що означає, що дані вважаються застарілими миттєво. Встановлення більшого значення зменшує мережевий трафік для даних, які рідко змінюються.",
    "interviewTip": "Не плутайте 'staleTime' з 'gcTime' (раніше cacheTime). gcTime визначає, коли неактивні дані будуть повністю видалені з пам'яті.",
    "options": [
      "Час, через який запит вважається таким, що перевищив тайм-аут.",
      "Тривалість, протягом якої дані вважаються «свіжими» і не потребують фонового оновлення.",
      "Вік браузера користувача.",
      "Час, який користувач проводить на одній сторінці."
    ]
  },
  "ss-08": {
    "prompt": "Визначте проблему в наступному фрагменті коду:",
    "explanation": "'queryFn' має бути функцією, яку React Query зможе викликати пізніше. Правильний синтаксис: `queryFn: () => fetchUser(id)`.",
    "interviewTip": "Це часта помилка, яка призводить до нескінченних циклів або виконання запиту не в тій фазі.",
    "options": [
      "queryKey має бути рядком.",
      "fetchUser(id) виконується негайно під час рендерингу замість того, щоб бути посиланням на функцію.",
      "Змінна id має бути рядком.",
      "useQuery не підтримує ID."
    ]
  },
  "ss-09": {
    "prompt": "Як React Query обробляє втрату інтернет-з'єднання?",
    "explanation": "React Query має вбудовану «офлайн-підтримку» і автоматично призупиняє або відновлює запити залежно від статусу підключення браузера.",
    "interviewTip": "Ви можете налаштувати кількість спроб ('retry') та затримку між ними ('retryDelay') у глобальній конфігурації.",
    "options": [
      "Це призводить до збою застосунку.",
      "Він автоматично повторює запит, коли з'єднання відновлюється.",
      "Він показує синій екран смерті.",
      "Він перемикається на локальну базу даних SQL."
    ]
  },
  "ss-10": {
    "prompt": "Що таке «Оптимістичне оновлення» (Optimistic Update)?",
    "explanation": "Ви оновлюєте кеш вручну одразу після натискання кнопки 'Submit'. Якщо сервер повертає помилку, ви «відкочуєте» стан до попереднього.",
    "interviewTip": "Це робить ваш додаток візуально «миттєвим» навіть на повільних з'єднаннях.",
    "options": [
      "Спосіб оновити UI негайно, ще до того, як сервер підтвердить зміну.",
      "Метод прискорення часу відповіді сервера.",
      "Стратегія обробки помилок шляхом припущення найкращого сценарію.",
      "Функція, яка працює тільки в React 19."
    ]
  },
  "ss-11": {
    "prompt": "Який компонент необхідний у корені вашого додатка для використання React Query?",
    "explanation": "Ви повинні створити `const queryClient = new QueryClient()` і передати його в компонент `<QueryClientProvider client={queryClient}>`.",
    "interviewTip": "Цей провайдер тримає 'Query Cache' (кеш запитів), що дозволяє ділитися даними по всьому додатку без використання Redux.",
    "options": [
      "<QueryProvider>",
      "<ReactQueryContext>",
      "<QueryClientProvider>",
      "<ServerStateProvider>"
    ]
  },
  "ss-12": {
    "prompt": "Яким буде результат встановлення опції 'enabled: false' у useQuery?",
    "explanation": "Опція 'enabled' використовується для «залежних запитів» (очікування на userId) або ручних запусків.",
    "interviewTip": "Використовуйте це, щоб запобігти запуску запиту, поки у вас немає всіх необхідних даних (наприклад, ID з попереднього запиту).",
    "options": [
      "Запит видаляється.",
      "Запит вимкнено; він запуститься лише якщо викликати 'refetch' вручну.",
      "Запит запускається один раз і зупиняється.",
      "Запит працює тільки на сервері."
    ]
  }
}
