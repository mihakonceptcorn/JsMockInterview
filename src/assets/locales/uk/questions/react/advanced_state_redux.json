{
  "rtk-01": {
    "prompt": "Яка основна мета 'Slice' (зрізу) у Redux Toolkit?",
    "explanation": "Функція `createSlice` автоматично генерує творців дій (action creators) та типи дій на основі наданих вами редюсерів, що значно скорочує кількість шаблонного коду.",
    "interviewTip": "У класичному Redux вам доводилося писати дії та редюсери в окремих файлах. Слайси роблять код модульним та лаконічним.",
    "options": [
      "Розділити UI на менші компоненти.",
      "Об'єднати initial state, редюсери та дії для конкретної фічі в одному місці.",
      "Розділити базу даних на кілька таблиць.",
      "Обробляти виключно API-виклики."
    ]
  },
  "rtk-02": {
    "prompt": "Як Redux Toolkit дозволяє безпечно «мутувати» стан всередині редюсера?",
    "explanation": "RTK використовує бібліотеку Immer, яка відстежує зміни в «чернетці» (draft state) і створює для вас абсолютно новий незмінний об'єкт стану.",
    "interviewTip": "Це головна перевага: ви отримуєте простоту синтаксису мутації, зберігаючи безпеку незмінності (immutability).",
    "options": [
      "Він використовує спеціальний компілятор, який змінює код на CSS.",
      "Він використовує бібліотеку Immer «під капотом», щоб перетворити «мутації» на незмінні оновлення.",
      "Він дійсно мутує глобальний стан, але React це не турбує.",
      "Це працює лише якщо ви використовуєте ключове слово 'mutable'."
    ]
  },
  "rtk-03": {
    "prompt": "Який хук використовується для отримання даних зі стану Redux store?",
    "explanation": "Хук `useSelector` приймає функцію-селектор, яка отримує весь стан сховища та повертає лише ту частину, яка вам потрібна.",
    "interviewTip": "useSelector також створює підписку на сховище і перерендерить компонент лише тоді, коли вибрані дані змінюються.",
    "options": ["useStore", "useDispatch", "useSelector", "useContext"]
  },
  "rtk-04": {
    "prompt": "Який правильний спосіб ініціювати зміну стану з компонента?",
    "explanation": "Хук `useDispatch` повертає функцію dispatch із сховища Redux. Ви викликаєте її з об'єктом дії (action), щоб запустити відповідний редюсер.",
    "interviewTip": "Диспатч — це *єдиний* спосіб ініціювати зміну стану в Redux, дотримуючись принципу «Єдиного джерела істини».",
    "options": ["trigger", "dispatch", "send", "action"]
  },
  "rtk-05": {
    "prompt": "Які основні принципи Redux?",
    "explanation": "Redux покладається на передбачуваність. Глобальний стан зберігається в одному дереві, а редюсери мають бути чистими функціями, які приймають (state, action) і повертають новий стан.",
    "interviewTip": "Передбачуваність робить можливими такі функції, як 'Time Travel Debugging' (налагодження з подорожжю у часі).",
    "options": [
      "Єдине джерело істини (один store).",
      "Стан доступний лише для читання (зміни тільки через actions).",
      "Стан може бути змінений будь-яким компонентом безпосередньо.",
      "Зміни вносяться за допомогою чистих функцій (редюсерів)."
    ]
  },
  "rtk-06": {
    "prompt": "Для чого використовується 'createAsyncThunk' у Redux Toolkit?",
    "explanation": "createAsyncThunk генерує типи дій для життєвого циклу проміса (pending, fulfilled, rejected) і автоматично обробляє логіку диспатчу.",
    "interviewTip": "Обробляйте результати танка (thunk) у секції 'extraReducers' вашого слайсу.",
    "options": [
      "Для синхронізації стану з localStorage.",
      "Для обробки асинхронної логіки, такої як API-запити.",
      "Для створення кастомних UI-анімацій.",
      "Для об'єднання кількох слайсів в один."
    ]
  },
  "rtk-07": {
    "prompt": "Де ви об'єднуєте всі свої слайси для створення глобального сховища (store)?",
    "explanation": "Функція `configureStore` спрощує налаштування сховища. Вона автоматично додає розширення Redux DevTools та проміжне програмне забезпечення 'thunk'.",
    "interviewTip": "configureStore — це заміна застарілої функції createStore в екосистемі RTK.",
    "options": [
      "Всередині файлу App.js.",
      "Використовуючи функцію configureStore.",
      "Всередині кастомного хука.",
      "У файлі index.html."
    ]
  },
  "rtk-08": {
    "prompt": "Що станеться, якщо редюсер не буде «чистою функцією» (наприклад, використовує Math.random() або викликає API)?",
    "explanation": "Редюсери повинні бути детермінованими. При однакових стані та дії вони завжди мають повертати однаковий результат. Побічні ефекти (side effects) належать танкам або middleware.",
    "interviewTip": "Запам'ятайте: Редюсери = Логіка/Обчислення; Танки = Побічні ефекти/Асинхронна робота.",
    "options": [
      "Код не скомпілюється.",
      "Зміни стану стануть непередбачуваними, а інструменти налагодження, такі як DevTools, зламаються.",
      "React автоматично виправить функцію.",
      "Redux запустить функцію в окремому потоці."
    ]
  },
  "rtk-09": {
    "prompt": "Як отримати доступ до даних (payload) дії всередині редюсера?",
    "explanation": "У Redux Toolkit дані, надіслані разом із дією, автоматично поміщаються у властивість `payload` об'єкта action.",
    "interviewTip": "Приклад: виклик dispatch(incrementByAmount(10)) призведе до того, що action.payload дорівнюватиме 10.",
    "options": [
      "action.data",
      "action.payload",
      "action.value",
      "action.params"
    ]
  },
  "rtk-10": {
    "prompt": "Яке призначення компонента <Provider> у Redux?",
    "explanation": "Як і Context API, Redux Provider використовує механізм контексту React, щоб передати сховище (store) до хуків, таких як useSelector.",
    "interviewTip": "Зазвичай ви огортаєте <Provider> навколо всього додатка <App /> у головному файлі (index.js).",
    "options": [
      "Для отримання даних із сервера.",
      "Щоб огорнути React-застосунок і зробити Redux store доступним для всіх компонентів.",
      "Для шифрування стану перед його збереженням.",
      "Для керування локальним станом компонента."
    ]
  },
  "rtk-11": {
    "prompt": "Які переваги використання Redux DevTools?",
    "explanation": "DevTools надає візуальну панель, де можна побачити, як кожна дія змінює стан, що значно полегшує налагодження.",
    "interviewTip": "Це одна з найвагоміших причин обирати Redux для складних застосунків.",
    "options": [
      "Перегляд історії кожної надісланої дії.",
      "Редагування стану в реальному часі для тестування змін UI.",
      "Автоматичне написання CSS для ваших компонентів.",
      "«Подорож у часі» до попередніх станів."
    ]
  },
  "rtk-12": {
    "prompt": "Знайдіть помилку у використанні цього селектора:",
    "explanation": "Завжди враховуйте початковий стан. Якщо дані ще не завантажені, звернення до індексу порожнього або невизначеного списку призведе до помилки.",
    "interviewTip": "Використовуйте опціональний ланцюжок: state.users?.[0].",
    "options": [
      "Селектори повинні бути визначені в окремому файлі.",
      "Якщо state.users не визначено (наприклад, під час завантаження), застосунок видасть помилку.",
      "useSelector не може отримати доступ до масивів.",
      "Повернуте значення має бути рядком."
    ]
  }
}
