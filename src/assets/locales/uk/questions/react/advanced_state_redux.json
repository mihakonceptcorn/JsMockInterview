{
  "rtk-01": {
    "prompt": "Яка основна мета 'Slice' (зрізу) у Redux Toolkit?",
    "explanation": "Функція `createSlice` автоматично генерує творців дій (action creators) та типи дій на основі наданих вами редюсерів, що значно скорочує кількість шаблонного коду.",
    "interviewTip": "У класичному Redux вам доводилося писати дії та редюсери в окремих файлах. Слайси роблять код модульним та лаконічним."
  },
  "rtk-02": {
    "prompt": "Як Redux Toolkit дозволяє безпечно «мутувати» стан всередині редюсера?",
    "explanation": "RTK використовує бібліотеку Immer, яка відстежує зміни в «чернетці» (draft state) і створює для вас абсолютно новий незмінний об'єкт стану.",
    "interviewTip": "Це головна перевага: ви отримуєте простоту синтаксису мутації, зберігаючи безпеку незмінності (immutability)."
  },
  "rtk-03": {
    "prompt": "Який хук використовується для отримання даних зі стану Redux store?",
    "explanation": "Хук `useSelector` приймає функцію-селектор, яка отримує весь стан сховища та повертає лише ту частину, яка вам потрібна.",
    "interviewTip": "useSelector також створює підписку на сховище і перерендерить компонент лише тоді, коли вибрані дані змінюються."
  },
  "rtk-04": {
    "prompt": "Який правильний спосіб ініціювати зміну стану з компонента?",
    "explanation": "Хук `useDispatch` повертає функцію dispatch із сховища Redux. Ви викликаєте її з об'єктом дії (action), щоб запустити відповідний редюсер.",
    "interviewTip": "Диспатч — це *єдиний* спосіб ініціювати зміну стану в Redux, дотримуючись принципу «Єдиного джерела істини»."
  },
  "rtk-05": {
    "prompt": "Які основні принципи Redux?",
    "explanation": "Redux покладається на передбачуваність. Глобальний стан зберігається в одному дереві, а редюсери мають бути чистими функціями, які приймають (state, action) і повертають новий стан.",
    "interviewTip": "Передбачуваність робить можливими такі функції, як 'Time Travel Debugging' (налагодження з подорожжю у часі)."
  },
  "rtk-06": {
    "prompt": "Для чого використовується 'createAsyncThunk' у Redux Toolkit?",
    "explanation": "createAsyncThunk генерує типи дій для життєвого циклу проміса (pending, fulfilled, rejected) і автоматично обробляє логіку диспатчу.",
    "interviewTip": "Обробляйте результати танка (thunk) у секції 'extraReducers' вашого слайсу."
  },
  "rtk-07": {
    "prompt": "Де ви об'єднуєте всі свої слайси для створення глобального сховища (store)?",
    "explanation": "Функція `configureStore` спрощує налаштування сховища. Вона автоматично додає розширення Redux DevTools та проміжне програмне забезпечення 'thunk'.",
    "interviewTip": "configureStore — це заміна застарілої функції createStore в екосистемі RTK."
  },
  "rtk-08": {
    "prompt": "Що станеться, якщо редюсер не буде «чистою функцією» (наприклад, використовує Math.random() або викликає API)?",
    "explanation": "Редюсери повинні бути детермінованими. При однакових стані та дії вони завжди мають повертати однаковий результат. Побічні ефекти (side effects) належать танкам або middleware.",
    "interviewTip": "Запам'ятайте: Редюсери = Логіка/Обчислення; Танки = Побічні ефекти/Асинхронна робота."
  },
  "rtk-09": {
    "prompt": "Як отримати доступ до даних (payload) дії всередині редюсера?",
    "explanation": "У Redux Toolkit дані, надіслані разом із дією, автоматично поміщаються у властивість `payload` об'єкта action.",
    "interviewTip": "Приклад: виклик dispatch(incrementByAmount(10)) призведе до того, що action.payload дорівнюватиме 10."
  },
  "rtk-10": {
    "prompt": "Яке призначення компонента <Provider> у Redux?",
    "explanation": "Як і Context API, Redux Provider використовує механізм контексту React, щоб передати сховище (store) до хуків, таких як useSelector.",
    "interviewTip": "Зазвичай ви огортаєте <Provider> навколо всього додатка <App /> у головному файлі (index.js)."
  },
  "rtk-11": {
    "prompt": "Які переваги використання Redux DevTools?",
    "explanation": "DevTools надає візуальну панель, де можна побачити, як кожна дія змінює стан, що значно полегшує налагодження.",
    "interviewTip": "Це одна з найвагоміших причин обирати Redux для складних застосунків."
  },
  "rtk-12": {
    "prompt": "Знайдіть помилку у використанні цього селектора:",
    "explanation": "Завжди враховуйте початковий стан. Якщо дані ще не завантажені, звернення до індексу порожнього або невизначеного списку призведе до помилки.",
    "interviewTip": "Використовуйте опціональний ланцюжок: state.users?.[0]."
  }
}
