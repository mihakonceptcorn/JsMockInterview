{
  "rd-01": {
    "prompt": "Яка основна мета хука 'useRef' у React?",
    "explanation": "useRef повертає звичайний JavaScript-об'єкт, який зберігається протягом усього життя компонента. Зміна властивості .current не викликає повторного рендерингу.",
    "interviewTip": "Уявіть useRef як «коробку», яка може містити будь-яке значення, але найчастіше вона тримає DOM-елемент."
  },
  "rd-02": {
    "prompt": "Як отримати доступ до DOM-вузла за допомогою рефа у функціональному компоненті?",
    "explanation": "Коли ви передаєте реф елементу JSX, React встановлює властивість '.current' цього об'єкта рефа на відповідний DOM-вузол.",
    "interviewTip": "Завжди перевіряйте, чи існує inputRef.current, перш ніж викликати методи на ньому, щоб уникнути помилок звернення до null."
  },
  "rd-03": {
    "prompt": "Що відбувається зі значенням, збереженим у 'useRef', коли компонент перерендериться?",
    "explanation": "На відміну від локальних змінних, які створюються заново при кожному рендері, значення useRef зберігаються React протягом усього життєвого циклу компонента.",
    "interviewTip": "Це робить рефи ідеальними для зберігання таймерів, ID інтервалів або попередніх значень пропсів."
  },
  "rd-04": {
    "prompt": "У яких сценаріях доречно використовувати Ref?",
    "explanation": "Якщо щось можна зробити «декларативно» за допомогою стану, використовуйте стан. Використовуйте рефи лише для «імперативних» дій, таких як фокусування або вимірювання елементів.",
    "interviewTip": "Документація React називає рефи «аварійним виходом» (escape hatch) — використовуйте їх лише тоді, коли стану недостатньо."
  },
  "rd-05": {
    "prompt": "Яка мета використання 'forwardRef'?",
    "explanation": "За замовчуванням ви не можете передати пропс 'ref' функціональному компоненту. forwardRef «прокидає» реф від батька до конкретного елемента всередині дочірнього компонента.",
    "interviewTip": "Це поширений патерн для компонентів дизайн-систем, таких як інпути або кнопки."
  },
  "rd-06": {
    "prompt": "Коли саме React оновлює властивість 'ref.current'?",
    "explanation": "React призначає DOM-вузол властивості .current під час монтування компонента і встановлює її в null при демонтуванні.",
    "interviewTip": "Через такий таймінг ви повинні звертатися до DOM-рефів лише всередині useEffect або в обробниках подій."
  },
  "rd-07": {
    "prompt": "Яким буде результат виконання коду після натискання кнопки 'Log'?",
    "explanation": "Кожного разу, коли компонент рендериться, лічильник збільшується. Оскільки це реф, значення зберігається, але воно саме по собі не *ініціює* рендеринг.",
    "interviewTip": "Це чудовий спосіб відстежувати, скільки разів компонент перерендерився, для відлагодження продуктивності."
  },
  "rd-08": {
    "prompt": "Як правильно зберегти ID інтервалу у функціональному компоненті?",
    "explanation": "Локальна змінна скидалася б при кожному рендері. useState викликав би зайвий рендеринг при встановленні ID. useRef — ідеальна «золота середина».",
    "interviewTip": "Завжди очищуйте інтервали у функції очищення useEffect, щоб уникнути витоків пам'яті."
  },
  "rd-09": {
    "prompt": "Чи можна використовувати 'useRef' для зберігання значень, які не є DOM-елементами?",
    "explanation": "useRef — це, по суті, універсальний контейнер для будь-якого мутабельного значення, яке ви хочете зберегти між рендерами.",
    "interviewTip": "Це часто використовується для зберігання 'previousProps' (попередніх пропсів) для порівняльної логіки."
  },
  "rd-10": {
    "prompt": "Яка різниця між 'useRef' та 'createRef'?",
    "explanation": "У функціональних компонентах createRef втрачатиме своє значення при кожному перерендерингу. useRef розроблений для того, щоб «підключатися» до постійного сховища React.",
    "interviewTip": "Якщо ви використаєте createRef всередині функціонального компонента, він буде скидатися кожного разу, коли запускається функція."
  },
  "rd-11": {
    "prompt": "Визначте проблему в цьому коді:",
    "explanation": "Під час першого рендеру DOM ще не створено, тому myRef.current дорівнює undefined/null. Ви повинні звертатися до нього лише в useEffect або під час події.",
    "interviewTip": "Це дуже поширений баг типу 'TypeError: Cannot read property of null'."
  },
  "rd-12": {
    "prompt": "Як обробляти кілька рефів у списку, згенерованому через .map()?",
    "explanation": "Ви не можете викликати хуки всередині циклів. Замість цього створіть один реф на масив або Map і призначайте кожен елемент за індексом або ключем.",
    "interviewTip": "Патерн: `<li ref={el => (itemsRef.current[i] = el)} />` (це називається callback ref)."
  },
  "rd-13": {
    "prompt": "Що робить 'useImperativeHandle'?",
    "explanation": "Використовується разом із forwardRef; він дозволяє приховати нативний DOM-вузол і замість цього надати батьківському компоненту лише специфічні методи (наприклад, .focus() або .scrollTo()).",
    "interviewTip": "Це корисно для інкапсуляції — не дозволяйте батькові втручатися у внутрішню структуру дочірнього елемента."
  },
  "rd-14": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "На відміну від оновлень стану, які є асинхронними, оновлення ref.current відбуваються миттєво. Збільшене значення доступне відразу.",
    "interviewTip": "Це ключова відмінність: стан — для даних, від яких залежить UI; рефи — для даних, які UI *не* рендерить напряму."
  }
}
