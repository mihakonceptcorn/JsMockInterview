{
  "rd-01": {
    "prompt": "Яка основна мета хука 'useRef' у React?",
    "explanation": "useRef повертає звичайний JavaScript-об'єкт, який зберігається протягом усього життя компонента. Зміна властивості .current не викликає повторного рендерингу.",
    "interviewTip": "Уявіть useRef як «коробку», яка може містити будь-яке значення, але найчастіше вона тримає DOM-елемент.",
    "options": [
      "Запускати повторний рендеринг щоразу, коли змінюється значення.",
      "Зберігати мутабельне (mutable) значення, яке зберігається між рендерами без ініціації повторного рендерингу.",
      "Валідувати типи пропсів, що передаються компоненту.",
      "Створювати глобальний стан, доступний для всіх компонентів."
    ]
  },
  "rd-02": {
    "prompt": "Як отримати доступ до DOM-вузла за допомогою рефа у функціональному компоненті?",
    "explanation": "Коли ви передаєте реф елементу JSX, React встановлює властивість '.current' цього об'єкта рефа на відповідний DOM-вузол.",
    "interviewTip": "Завжди перевіряйте, чи існує inputRef.current, перш ніж викликати методи на ньому, щоб уникнути помилок звернення до null.",
    "options": [
      "inputRef.focus()",
      "inputRef.current.focus()",
      "inputRef.value.focus()",
      "document.getElementById('input').focus()"
    ]
  },
  "rd-03": {
    "prompt": "Що відбувається зі значенням, збереженим у 'useRef', коли компонент перерендериться?",
    "explanation": "На відміну від локальних змінних, які створюються заново при кожному рендері, значення useRef зберігаються React протягом усього життєвого циклу компонента.",
    "interviewTip": "Це робить рефи ідеальними для зберігання таймерів, ID інтервалів або попередніх значень пропсів.",
    "options": [
      "Воно скидається до початкового значення, вказаного в useRef(initial).",
      "Воно зберігається і залишається точно таким же, як було до рендерингу.",
      "Воно очищається і стає null.",
      "Це спричиняє нескінченний цикл рендерингу."
    ]
  },
  "rd-04": {
    "prompt": "У яких сценаріях доречно використовувати Ref?",
    "explanation": "Якщо щось можна зробити «декларативно» за допомогою стану, використовуйте стан. Використовуйте рефи лише для «імперативних» дій, таких як фокусування або вимірювання елементів.",
    "interviewTip": "Документація React називає рефи «аварійним виходом» (escape hatch) — використовуйте їх лише тоді, коли стану недостатньо.",
    "options": [
      "Керування фокусом, виділенням тексту або відтворенням медіа.",
      "Зберігання поточного тексту поля вводу для його відображення в UI.",
      "Інтеграція зі сторонніми DOM-бібліотеками.",
      "Запуск анімації, яка залежить від зміни стану."
    ]
  },
  "rd-05": {
    "prompt": "Яка мета використання 'forwardRef'?",
    "explanation": "За замовчуванням ви не можете передати пропс 'ref' функціональному компоненту. forwardRef «прокидає» реф від батька до конкретного елемента всередині дочірнього компонента.",
    "interviewTip": "Це поширений патерн для компонентів дизайн-систем, таких як інпути або кнопки.",
    "options": [
      "Дозволити батьківському компоненту отримати доступ до DOM-рефа всередині дочірнього компонента.",
      "Прискорити рендеринг функціональних компонентів.",
      "Запобігти повторному рендерингу компонента при зміні пропсів.",
      "Автоматично фокусувати перший інпут у компоненті."
    ]
  },
  "rd-06": {
    "prompt": "Коли саме React оновлює властивість 'ref.current'?",
    "explanation": "React призначає DOM-вузол властивості .current під час монтування компонента і встановлює її в null при демонтуванні.",
    "interviewTip": "Через такий таймінг ви повинні звертатися до DOM-рефів лише всередині useEffect або в обробниках подій.",
    "options": [
      "Під час фази рендерингу (render phase).",
      "До того, як DOM-елементи будуть створені.",
      "Після того, як компонент зафіксовано на екрані (під час mount/update).",
      "Тільки коли розробник викликає ref.update()."
    ]
  },
  "rd-07": {
    "prompt": "Яким буде результат виконання коду після натискання кнопки 'Log'?",
    "explanation": "Кожного разу, коли компонент рендериться, лічильник збільшується. Оскільки це реф, значення зберігається, але воно саме по собі не *ініціює* рендеринг.",
    "interviewTip": "Це чудовий спосіб відстежувати, скільки разів компонент перерендерився, для відлагодження продуктивності.",
    "options": [
      "Завжди буде логуватися 0.",
      "Буде логуватися кількість разів, яку компонент був відрендерений.",
      "Це спричинить помилку 'Max depth exceeded'.",
      "Текст кнопки зміниться на значення лічильника."
    ]
  },
  "rd-08": {
    "prompt": "Як правильно зберегти ID інтервалу у функціональному компоненті?",
    "explanation": "Локальна змінна скидалася б при кожному рендері. useState викликав би зайвий рендеринг при встановленні ID. useRef — ідеальна «золота середина».",
    "interviewTip": "Завжди очищуйте інтервали у функції очищення useEffect, щоб уникнути витоків пам'яті.",
    "options": [
      "Використовуючи локальну змінну: let timer = setInterval(...)",
      "Використовуючи useState: const [timer, setTimer] = useState(...)",
      "Використовуючи useRef, як показано в коді.",
      "Інтервали не підтримуються у функціональних компонентах."
    ]
  },
  "rd-09": {
    "prompt": "Чи можна використовувати 'useRef' для зберігання значень, які не є DOM-елементами?",
    "explanation": "useRef — це, по суті, універсальний контейнер для будь-якого мутабельного значення, яке ви хочете зберегти між рендерами.",
    "interviewTip": "Це часто використовується для зберігання 'previousProps' (попередніх пропсів) для порівняльної логіки.",
    "options": [
      "Ні, це тільки для HTML-елементів.",
      "Так, він може зберігати будь-яке значення JavaScript (рядки, об'єкти, функції).",
      "Тільки якщо значення є числом.",
      "Тільки якщо замість нього використовувати хук useMemo."
    ]
  },
  "rd-10": {
    "prompt": "Яка різниця між 'useRef' та 'createRef'?",
    "explanation": "У функціональних компонентах createRef втрачатиме своє значення при кожному перерендерингу. useRef розроблений для того, щоб «підключатися» до постійного сховища React.",
    "interviewTip": "Якщо ви використаєте createRef всередині функціонального компонента, він буде скидатися кожного разу, коли запускається функція.",
    "options": [
      "createRef переважно використовується в класових компонентах.",
      "useRef завжди повертає той самий об'єкт; createRef створює новий об'єкт при кожному рендерингу.",
      "createRef швидший за useRef.",
      "useRef працює тільки з DOM-вузлами."
    ]
  },
  "rd-11": {
    "prompt": "Визначте проблему в цьому коді:",
    "explanation": "Під час першого рендеру DOM ще не створено, тому myRef.current дорівнює undefined/null. Ви повинні звертатися до нього лише в useEffect або під час події.",
    "interviewTip": "Це дуже поширений баг типу 'TypeError: Cannot read property of null'.",
    "options": [
      "Тегу div бракує ключа (key).",
      "myRef.current дорівнює null під час першого рендерингу, що призводить до збою.",
      "useRef не може отримати доступ до innerText.",
      "Рефи мають бути ініціалізовані рядком."
    ]
  },
  "rd-12": {
    "prompt": "Як обробляти кілька рефів у списку, згенерованому через .map()?",
    "explanation": "Ви не можете викликати хуки всередині циклів. Замість цього створіть один реф на масив або Map і призначайте кожен елемент за індексом або ключем.",
    "interviewTip": "Патерн: `<li ref={el => (itemsRef.current[i] = el)} />` (це називається callback ref).",
    "options": [
      "Створити масив рефів, використовуючи один useRef([]).",
      "Викликати useRef всередині callback-функції .map().",
      "Передати індекс як ім'я рефа: ref={index}.",
      "React не підтримує декілька рефів у циклі."
    ]
  },
  "rd-13": {
    "prompt": "Що робить 'useImperativeHandle'?",
    "explanation": "Використовується разом із forwardRef; він дозволяє приховати нативний DOM-вузол і замість цього надати батьківському компоненту лише специфічні методи (наприклад, .focus() або .scrollTo()).",
    "interviewTip": "Це корисно для інкапсуляції — не дозволяйте батькові втручатися у внутрішню структуру дочірнього елемента.",
    "options": [
      "Він змушує компонент рендеритися швидше.",
      "Він дозволяє дочірньому компоненту налаштовувати значення екземпляра (instance value), яке відкривається батьківському компоненту через реф.",
      "Він змушує React оновлювати DOM негайно.",
      "Він замінює хук useState для складних форм."
    ]
  },
  "rd-14": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "На відміну від оновлень стану, які є асинхронними, оновлення ref.current відбуваються миттєво. Збільшене значення доступне відразу.",
    "interviewTip": "Це ключова відмінність: стан — для даних, від яких залежить UI; рефи — для даних, які UI *не* рендерить напряму.",
    "options": ["0", "1", "Попереднє значення count.", "undefined"]
  }
}
