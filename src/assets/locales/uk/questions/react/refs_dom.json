{
  "rd-01": {
    "prompt": "Яка основна мета хука 'useRef' у React?",
    "explanation": "useRef повертає звичайний JavaScript-об'єкт, який зберігається протягом усього життя компонента. Зміна властивості .current не викликає повторного рендерингу.",
    "interviewTip": "Уявіть useRef як «коробку», яка може містити будь-яке значення, але найчастіше вона тримає DOM-елемент.",
    "options": [
      "To trigger a re-render whenever the value changes.",
      "To store a mutable value that persists across renders without causing a re-render.",
      "To validate the types of props passed to a component.",
      "To create a global state accessible by all components."
    ]
  },
  "rd-02": {
    "prompt": "Як отримати доступ до DOM-вузла за допомогою рефа у функціональному компоненті?",
    "explanation": "Коли ви передаєте реф елементу JSX, React встановлює властивість '.current' цього об'єкта рефа на відповідний DOM-вузол.",
    "interviewTip": "Завжди перевіряйте, чи існує inputRef.current, перш ніж викликати методи на ньому, щоб уникнути помилок звернення до null.",
    "options": [
      "inputRef.focus()",
      "inputRef.current.focus()",
      "inputRef.value.focus()",
      "document.getElementById('input').focus()"
    ]
  },
  "rd-03": {
    "prompt": "Що відбувається зі значенням, збереженим у 'useRef', коли компонент перерендериться?",
    "explanation": "На відміну від локальних змінних, які створюються заново при кожному рендері, значення useRef зберігаються React протягом усього життєвого циклу компонента.",
    "interviewTip": "Це робить рефи ідеальними для зберігання таймерів, ID інтервалів або попередніх значень пропсів.",
    "options": [
      "It is reset to the initial value provided in useRef(initial).",
      "It is preserved and stays exactly as it was before the render.",
      "It is cleared and becomes null.",
      "It causes an infinite render loop."
    ]
  },
  "rd-04": {
    "prompt": "У яких сценаріях доречно використовувати Ref?",
    "explanation": "Якщо щось можна зробити «декларативно» за допомогою стану, використовуйте стан. Використовуйте рефи лише для «імперативних» дій, таких як фокусування або вимірювання елементів.",
    "interviewTip": "Документація React називає рефи «аварійним виходом» (escape hatch) — використовуйте їх лише тоді, коли стану недостатньо.",
    "options": [
      "Managing focus, text selection, or media playback.",
      "Storing the current text of an input field to display it in the UI.",
      "Integrating with third-party DOM libraries.",
      "Triggering an animation that depends on state changes."
    ]
  },
  "rd-05": {
    "prompt": "Яка мета використання 'forwardRef'?",
    "explanation": "За замовчуванням ви не можете передати пропс 'ref' функціональному компоненту. forwardRef «прокидає» реф від батька до конкретного елемента всередині дочірнього компонента.",
    "interviewTip": "Це поширений патерн для компонентів дизайн-систем, таких як інпути або кнопки.",
    "options": [
      "To allow a parent component to access a DOM ref inside a child component.",
      "To speed up the rendering of functional components.",
      "To prevent a component from re-rendering when props change.",
      "To automatically focus the first input in a component."
    ]
  },
  "rd-06": {
    "prompt": "Коли саме React оновлює властивість 'ref.current'?",
    "explanation": "React призначає DOM-вузол властивості .current під час монтування компонента і встановлює її в null при демонтуванні.",
    "interviewTip": "Через такий таймінг ви повинні звертатися до DOM-рефів лише всередині useEffect або в обробниках подій.",
    "options": [
      "During the render phase.",
      "Before the DOM elements are created.",
      "After the component is committed to the screen (during mount/update).",
      "Only when the developer calls ref.update()."
    ]
  },
  "rd-07": {
    "prompt": "Яким буде результат виконання коду після натискання кнопки 'Log'?",
    "explanation": "Кожного разу, коли компонент рендериться, лічильник збільшується. Оскільки це реф, значення зберігається, але воно саме по собі не *ініціює* рендеринг.",
    "interviewTip": "Це чудовий спосіб відстежувати, скільки разів компонент перерендерився, для відлагодження продуктивності.",
    "options": [
      "It will always log 0.",
      "It will log the number of times the component has rendered.",
      "It will cause a 'Max depth exceeded' error.",
      "The button text will change to the count."
    ]
  },
  "rd-08": {
    "prompt": "Як правильно зберегти ID інтервалу у функціональному компоненті?",
    "explanation": "Локальна змінна скидалася б при кожному рендері. useState викликав би зайвий рендеринг при встановленні ID. useRef — ідеальна «золота середина».",
    "interviewTip": "Завжди очищуйте інтервали у функції очищення useEffect, щоб уникнути витоків пам'яті.",
    "options": [
      "Using a local variable: let timer = setInterval(...)",
      "Using useState: const [timer, setTimer] = useState(...)",
      "Using useRef as shown in the code.",
      "Intervals are not supported in functional components."
    ]
  },
  "rd-09": {
    "prompt": "Чи можна використовувати 'useRef' для зберігання значень, які не є DOM-елементами?",
    "explanation": "useRef — це, по суті, універсальний контейнер для будь-якого мутабельного значення, яке ви хочете зберегти між рендерами.",
    "interviewTip": "Це часто використовується для зберігання 'previousProps' (попередніх пропсів) для порівняльної логіки.",
    "options": [
      "No, it's only for HTML elements.",
      "Yes, it can store any JavaScript value (strings, objects, functions).",
      "Only if the value is a number.",
      "Only if you use the useMemo hook instead."
    ]
  },
  "rd-10": {
    "prompt": "Яка різниця між 'useRef' та 'createRef'?",
    "explanation": "У функціональних компонентах createRef втрачатиме своє значення при кожному перерендерингу. useRef розроблений для того, щоб «підключатися» до постійного сховища React.",
    "interviewTip": "Якщо ви використаєте createRef всередині функціонального компонента, він буде скидатися кожного разу, коли запускається функція.",
    "options": [
      "createRef is primarily used in Class components.",
      "useRef always returns the same object; createRef creates a new object every render.",
      "createRef is faster than useRef.",
      "useRef only works with DOM nodes."
    ]
  },
  "rd-11": {
    "prompt": "Визначте проблему в цьому коді:",
    "explanation": "Під час першого рендеру DOM ще не створено, тому myRef.current дорівнює undefined/null. Ви повинні звертатися до нього лише в useEffect або під час події.",
    "interviewTip": "Це дуже поширений баг типу 'TypeError: Cannot read property of null'.",
    "options": [
      "The div tag is missing a key.",
      "myRef.current is null during the first render, leading to a crash.",
      "useRef cannot access innerText.",
      "Refs must be initialized with a string."
    ]
  },
  "rd-12": {
    "prompt": "Як обробляти кілька рефів у списку, згенерованому через .map()?",
    "explanation": "Ви не можете викликати хуки всередині циклів. Замість цього створіть один реф на масив або Map і призначайте кожен елемент за індексом або ключем.",
    "interviewTip": "Патерн: `<li ref={el => (itemsRef.current[i] = el)} />` (це називається callback ref).",
    "options": [
      "Create an array of refs using a single useRef([]).",
      "Call useRef inside the .map() callback.",
      "Pass the index as the ref name: ref={index}.",
      "React doesn't support multiple refs in a loop."
    ]
  },
  "rd-13": {
    "prompt": "Що робить 'useImperativeHandle'?",
    "explanation": "Використовується разом із forwardRef; він дозволяє приховати нативний DOM-вузол і замість цього надати батьківському компоненту лише специфічні методи (наприклад, .focus() або .scrollTo()).",
    "interviewTip": "Це корисно для інкапсуляції — не дозволяйте батькові втручатися у внутрішню структуру дочірнього елемента.",
    "options": [
      "It makes the component render faster.",
      "It allows a child component to customize the instance value that is exposed to a parent using a ref.",
      "It forces React to update the DOM immediately.",
      "It replaces the useState hook for complex forms."
    ]
  },
  "rd-14": {
    "prompt": "Що буде виведено в консоль?",
    "explanation": "На відміну від оновлень стану, які є асинхронними, оновлення ref.current відбуваються миттєво. Збільшене значення доступне відразу.",
    "interviewTip": "Це ключова відмінність: стан — для даних, від яких залежить UI; рефи — для даних, які UI *не* рендерить напряму.",
    "options": [
      "0",
      "1",
      "The previous count.",
      "undefined"
    ]
  }
}