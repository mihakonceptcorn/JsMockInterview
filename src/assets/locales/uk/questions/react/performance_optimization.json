{
  "po-01": {
    "prompt": "Яка основна мета використання 'React.lazy' та 'Suspense'?",
    "explanation": "React.lazy дозволяє рендерити динамічний імпорт як звичайний компонент. Suspense забезпечує резервний інтерфейс (наприклад, спінер), поки цей компонент завантажується.",
    "interviewTip": "Це зменшує початковий розмір бандла (bundle size), що покращує метрику 'Time to Interactive' (час до інтерактивності)."
  },
  "po-02": {
    "prompt": "Проаналізуйте код. Що відбувається з 'HugeComponent', коли додаток завантажується вперше?",
    "explanation": "Завдяки динамічному імпорту import(), інструмент збірки (Webpack або Vite) створює окремий чанк для цього компонента, який завантажується по мережі лише за потреби.",
    "interviewTip": "Ледаче завантаження (lazy loading) найкраще підходить для компонентів, які не видно одразу, наприклад, модальних вікон або окремих маршрутів (Routes)."
  },
  "po-03": {
    "prompt": "Які з цих методів є ефективними для виявлення «вузьких місць» у продуктивності React-додатка?",
    "explanation": "Профайлер (Profiler) показує, які компоненти рендерилися і чому. Функція 'Highlight updates' дає візуальний фідбек про перерендери, а вкладка Network допомагає знайти занадто важкий код.",
    "interviewTip": "Графік 'Flamegraph' у профайлері допомагає точно визначити, який саме компонент у глибокому дереві спричиняє затримку."
  },
  "po-04": {
    "prompt": "Для чого використовується «віконний режим» (Windowing) або віртуалізація?",
    "explanation": "Якщо у вас 10 000 елементів, рендеринг усіх створить понад 10 000 DOM-вузлів, що сповільнить браузер. Віртуалізація тримає DOM малим (наприклад, лише 20 вузлів у полі зору).",
    "interviewTip": "Згадайте бібліотеки 'react-window' або 'react-virtualized' як галузевий стандарт для цього завдання."
  },
  "po-05": {
    "prompt": "Як вплине на продуктивність визначення одного компонента всередині тіла іншого компонента?",
    "explanation": "Оскільки функція компонента створюється заново, React щоразу бачить її як абсолютно новий тип. Це знищує весь стан (state) дочірнього елемента і змушує його повністю перемонтуватися.",
    "interviewTip": "Завжди визначайте свої компоненти поза основною функцією або в окремих файлах."
  },
  "po-06": {
    "prompt": "Що таке 'Throttling' та 'Debouncing' у контексті подій React?",
    "explanation": "Debouncing (усунення брязкоту) чекає на паузу в активності (наприклад, при друку), тоді як Throttling (дроселювання) обмежує кількість викликів до одного разу на X мілісекунд (наприклад, при скролі).",
    "interviewTip": "Використовуйте 'lodash.debounce' або подібні утиліти, щоб запобігти 100 API-запитам, поки користувач вводить одне слово."
  },
  "po-07": {
    "prompt": "Як 'Transition API' (useTransition) допомагає з продуктивністю в React 18+?",
    "explanation": "startTransition підказує React, що оновлення (наприклад, фільтрація величезного списку) може бути перерване більш терміновими завданнями, такими як введення тексту або клік.",
    "interviewTip": "Використовуйте 'useTransition', щоб запобігти «зависанню» інтерфейсу під час важких завдань рендерингу."
  },
  "po-08": {
    "prompt": "У чому перевага перенесення стану (state) вниз до дочірнього компонента?",
    "explanation": "Це називається «локалізація стану». Якщо лише модальному вікну потрібно знати, чи воно відкрите, тримайте стан там, щоб уникнути рендерингу всього додатка при кожному перемиканні.",
    "interviewTip": "Перед використанням useMemo завжди перевіряйте, чи можна просто змінити структуру дерева компонентів, щоб уникнути зайвих рендерів."
  },
  "po-09": {
    "prompt": "Чому використання індексу масиву як ключа (key) — це погано для продуктивності в динамічних списках?",
    "explanation": "Якщо список перевпорядковується, елемент за індексом 0 змінюється, але ключ '0' залишається. React думає, що змінився вміст, а не те, що елемент просто перемістився.",
    "interviewTip": "Стабільні ключі (наприклад, ID) дозволяють React просто переміщати DOM-вузли замість їх повторного створення."
  },
  "po-10": {
    "prompt": "Що робить хук 'useDeferredValue'?",
    "explanation": "Подібно до useTransition, але для значень. Він дає «відкладену» версію значення, яка оновлюється з невеликою затримкою після термінового оновлення, зберігаючи плавність UI.",
    "interviewTip": "Ідеально підходить для пошукового введення, де поле вводу оновлюється миттєво, а список результатів — трохи згодом."
  },
  "po-11": {
    "prompt": "Які з цих патернів можуть призвести до витоків пам'яті в React?",
    "explanation": "Коли компонент демонтується, глобальні речі, такі як таймери та слухачі подій, залишаються в пам'яті, якщо ви не зупините їх вручну.",
    "interviewTip": "Завжди використовуйте функцію повернення в useEffect, щоб «прибрати за собою»!"
  },
  "po-12": {
    "prompt": "Яким буде результат використання інлайнових функцій як пропсів для компонента, огорнутого в 'React.memo'?",
    "explanation": "React.memo використовує поверхневе порівняння. Оскільки `() => {} !== () => {}`, перевірка мемоїзації не спрацьовує і компонент перерендериться.",
    "interviewTip": "Поєднуйте 'React.memo' з 'useCallback' у батьківському компоненті, щоб оптимізація дійсно працювала."
  }
}
