{
  "po-01": {
    "prompt": "Яка основна мета використання 'React.lazy' та 'Suspense'?",
    "explanation": "React.lazy дозволяє рендерити динамічний імпорт як звичайний компонент. Suspense забезпечує резервний інтерфейс (наприклад, спінер), поки цей компонент завантажується.",
    "interviewTip": "Це зменшує початковий розмір бандла (bundle size), що покращує метрику 'Time to Interactive' (час до інтерактивності).",
    "options": [
      "Щоб прискорити алгоритм порівняння Virtual DOM.",
      "Для впровадження code-splitting шляхом завантаження компонентів лише тоді, коли вони потрібні.",
      "Для автоматичної мініфікації CSS-файлів.",
      "Для кешування відповідей API в пам'яті браузера."
    ]
  },
  "po-02": {
    "prompt": "Проаналізуйте код. Що відбувається з 'HugeComponent', коли додаток завантажується вперше?",
    "explanation": "Завдяки динамічному імпорту import(), інструмент збірки (Webpack або Vite) створює окремий чанк для цього компонента, який завантажується по мережі лише за потреби.",
    "interviewTip": "Ледаче завантаження (lazy loading) найкраще підходить для компонентів, які не видно одразу, наприклад, модальних вікон або окремих маршрутів (Routes).",
    "options": [
      "Він завантажується миттєво як частина основного бандла.",
      "Він завантажується лише тоді, коли рендериться компонент App.",
      "Він ігнорується браузером.",
      "Він рендериться тільки на сервері (pre-rendered)."
    ]
  },
  "po-03": {
    "prompt": "Які з цих методів є ефективними для виявлення «вузьких місць» у продуктивності React-додатка?",
    "explanation": "Профайлер (Profiler) показує, які компоненти рендерилися і чому. Функція 'Highlight updates' дає візуальний фідбек про перерендери, а вкладка Network допомагає знайти занадто важкий код.",
    "interviewTip": "Графік 'Flamegraph' у профайлері допомагає точно визначити, який саме компонент у глибокому дереві спричиняє затримку.",
    "options": [
      "Використання вкладки 'Profiler' у React Developer Tools.",
      "Увімкнення опції 'Highlight updates' у налаштуваннях React DevTools.",
      "Перевірка вкладки 'Network' для аналізу розмірів бандлів.",
      "Збільшення швидкості процесора на машині розробника."
    ]
  },
  "po-04": {
    "prompt": "Для чого використовується «віконний режим» (Windowing) або віртуалізація?",
    "explanation": "Якщо у вас 10 000 елементів, рендеринг усіх створить понад 10 000 DOM-вузлів, що сповільнить браузер. Віртуалізація тримає DOM малим (наприклад, лише 20 вузлів у полі зору).",
    "interviewTip": "Згадайте бібліотеки 'react-window' або 'react-virtualized' як галузевий стандарт для цього завдання.",
    "options": [
      "Щоб дозволити застосунку працювати в кількох вікнах браузера одночасно.",
      "Щоб рендерити в довгому списку тільки ті елементи, які зараз видно на екрані.",
      "Щоб створити прозорий фон для інтерфейсу.",
      "Для обробки спливаючих вікон (pop-ups) у браузері."
    ]
  },
  "po-05": {
    "prompt": "Як вплине на продуктивність визначення одного компонента всередині тіла іншого компонента?",
    "explanation": "Оскільки функція компонента створюється заново, React щоразу бачить її як абсолютно новий тип. Це знищує весь стан (state) дочірнього елемента і змушує його повністю перемонтуватися.",
    "interviewTip": "Завжди визначайте свої компоненти поза основною функцією або в окремих файлах.",
    "options": [
      "Це працює швидше, оскільки область видимості (scope) менша.",
      "Це вкрай неефективно, бо 'Child' перевизначається як абсолютно новий компонент при кожному рендерингу 'Parent'.",
      "React оптимізує це автоматично.",
      "Це дозволено тільки в React 19."
    ]
  },
  "po-06": {
    "prompt": "Що таке 'Throttling' та 'Debouncing' у контексті подій React?",
    "explanation": "Debouncing (усунення брязкоту) чекає на паузу в активності (наприклад, при друку), тоді як Throttling (дроселювання) обмежує кількість викликів до одного разу на X мілісекунд (наприклад, при скролі).",
    "interviewTip": "Використовуйте 'lodash.debounce' або подібні утиліти, щоб запобігти 100 API-запитам, поки користувач вводить одне слово.",
    "options": [
      "Методи шифрування введених користувачем даних.",
      "Техніки обмеження частоти виконання функції (наприклад, виклику API під час пошуку або ресайзу вікна).",
      "Способи прискорення CSS-анімацій.",
      "Інструменти для видалення невикористовуваних змінних стану."
    ]
  },
  "po-07": {
    "prompt": "Як 'Transition API' (useTransition) допомагає з продуктивністю в React 18+?",
    "explanation": "startTransition підказує React, що оновлення (наприклад, фільтрація величезного списку) може бути перерване більш терміновими завданнями, такими як введення тексту або клік.",
    "interviewTip": "Використовуйте 'useTransition', щоб запобігти «зависанню» інтерфейсу під час важких завдань рендерингу.",
    "options": [
      "Він додає CSS-переходи (transitions) між сторінками.",
      "Він дозволяє позначити певні оновлення стану як «нетермінові», зберігаючи чуйність інтерфейсу.",
      "Він автоматично стискає зображення.",
      "Він змушує браузер використовувати більше оперативної пам'яті (RAM)."
    ]
  },
  "po-08": {
    "prompt": "У чому перевага перенесення стану (state) вниз до дочірнього компонента?",
    "explanation": "Це називається «локалізація стану». Якщо лише модальному вікну потрібно знати, чи воно відкрите, тримайте стан там, щоб уникнути рендерингу всього додатка при кожному перемиканні.",
    "interviewTip": "Перед використанням useMemo завжди перевіряйте, чи можна просто змінити структуру дерева компонентів, щоб уникнути зайвих рендерів.",
    "options": [
      "Це збільшує складність застосунку.",
      "Це обмежує повторні рендеринги тільки цим дочірнім компонентом замість усього батьківського дерева.",
      "Це робить дані доступними для всіх компонентів.",
      "Це не дає жодної переваги для продуктивності."
    ]
  },
  "po-09": {
    "prompt": "Чому використання індексу масиву як ключа (key) — це погано для продуктивності в динамічних списках?",
    "explanation": "Якщо список перевпорядковується, елемент за індексом 0 змінюється, але ключ '0' залишається. React думає, що змінився вміст, а не те, що елемент просто перемістився.",
    "interviewTip": "Стабільні ключі (наприклад, ID) дозволяють React просто переміщати DOM-вузли замість їх повторного створення.",
    "options": [
      "Браузеру потрібно занадто багато часу, щоб прочитати числа.",
      "Це заплутує алгоритм порівняння (diffing) React під час перевпорядкування, що призводить до некоректних оновлень DOM і зайвих рендерів.",
      "Ключі мають бути рядками, а не числами.",
      "Індекси не підтримуються в React 18."
    ]
  },
  "po-10": {
    "prompt": "Що робить хук 'useDeferredValue'?",
    "explanation": "Подібно до useTransition, але для значень. Він дає «відкладену» версію значення, яка оновлюється з невеликою затримкою після термінового оновлення, зберігаючи плавність UI.",
    "interviewTip": "Ідеально підходить для пошукового введення, де поле вводу оновлюється миттєво, а список результатів — трохи згодом.",
    "options": [
      "Він відкладає рендеринг значення до наступного дня.",
      "Він дозволяє відкласти оновлення частини інтерфейсу, яка потребує багато часу для рендерингу.",
      "Він кешує значення в куках (cookies).",
      "Він запобігає будь-яким змінам значення."
    ]
  },
  "po-11": {
    "prompt": "Які з цих патернів можуть призвести до витоків пам'яті в React?",
    "explanation": "Коли компонент демонтується, глобальні речі, такі як таймери та слухачі подій, залишаються в пам'яті, якщо ви не зупините їх вручну.",
    "interviewTip": "Завжди використовуйте функцію повернення в useEffect, щоб «прибрати за собою»!",
    "options": [
      "Запуск setInterval без його очищення у функції cleanup.",
      "Використання великої кількості викликів console.log.",
      "Додавання слухача подій до window без його подальшого видалення.",
      "Оголошення занадто великої кількості змінних."
    ]
  },
  "po-12": {
    "prompt": "Яким буде результат використання інлайнових функцій як пропсів для компонента, огорнутого в 'React.memo'?",
    "explanation": "React.memo використовує поверхневе порівняння. Оскільки `() => {} !== () => {}`, перевірка мемоїзації не спрацьовує і компонент перерендериться.",
    "interviewTip": "Поєднуйте 'React.memo' з 'useCallback' у батьківському компоненті, щоб оптимізація дійсно працювала.",
    "options": [
      "Кнопка ніколи не буде перерендерена.",
      "Кнопка все одно буде перерендерена при кожному рендері батька, бо функція — це нове посилання кожного разу.",
      "React проігнорує функцію.",
      "Функція буде автоматично мемоїзована."
    ]
  }
}
