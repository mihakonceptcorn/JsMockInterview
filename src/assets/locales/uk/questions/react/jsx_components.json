{
  "jc-01": {
    "prompt": "Що станеться, якщо назвати React-компонент з маленької літери (наприклад, function myHeader())?",
    "explanation": "React використовує регістр літер, щоб розрізняти нативні HTML-теги (рядки) та власні компоненти (функції/класи).",
    "interviewTip": "Завжди використовуйте PascalCase для назв компонентів (наприклад, MyComponent).",
    "options": [
      "React will treat it as a standard HTML tag and fail to render the component logic.",
      "React will automatically capitalize it during compilation.",
      "The app will crash with a 'LowercaseError'.",
      "It will work perfectly as long as the file name is capitalized."
    ]
  },
  "jc-02": {
    "prompt": "Яким буде результат наступного коду компонента?",
    "explanation": "JSX повинен мати рівно один кореневий елемент. Ви не можете повернути кілька сусідніх тегів без спільної обгортки.",
    "interviewTip": "Це можна виправити за допомогою <div> або фрагмента (<>...</>).",
    "options": [
      "It renders an h1 followed by a p tag.",
      "It only renders the h1 tag.",
      "A syntax error: 'Adjacent JSX elements must be wrapped in an enclosing tag'.",
      "The p tag is nested inside the h1 tag."
    ]
  },
  "jc-03": {
    "prompt": "Як передати змінну JavaScript як атрибут у JSX?",
    "explanation": "Щоб передати змінну як пропс або атрибут, необхідно використовувати фігурні дужки без лапок.",
    "interviewTip": "Якщо ви поставите лапки навколо дужок, React сприйме весь вираз як звичайний рядок.",
    "options": [
      "<a href='{myUrl}'>Link</a>",
      "<a href={myUrl}>Link</a>",
      "<a href=(myUrl)>Link</a>",
      "<a href=\"myUrl\">Link</a>"
    ]
  },
  "jc-04": {
    "prompt": "Що буде відрендерено цим фрагментом коду?",
    "explanation": "React не рендерить булеві значення, null або undefined. Оскільки isAdmin дорівнює false, оператор && зупиняється, і нічого не відображається.",
    "interviewTip": "Будьте обережні з 0; на відміну від false, React *буде* рендерити число 0.",
    "options": [
      "<div>false</div>",
      "<div></div> (nothing inside)",
      "<div><button>Delete</button></div>",
      "An error"
    ]
  },
  "jc-05": {
    "prompt": "Яка мета використання React Fragments (<> ... </>)?",
    "explanation": "Фрагменти дозволяють дотримуватися правила «одного кореня», не засмічуючи HTML зайвими тегами <div>.",
    "interviewTip": "Фрагменти особливо корисні при роботі з CSS Flexbox або Grid, де зайві батьківські div-и можуть зламати макет.",
    "options": [
      "To speed up the execution of JavaScript logic.",
      "To group multiple elements without adding an extra node to the DOM tree.",
      "To automatically generate CSS classes for children.",
      "To protect components from being re-rendered."
    ]
  },
  "jc-06": {
    "prompt": "Які з цих варіантів є правильними для застосування інлайнових стилів у JSX?",
    "explanation": "Інлайнові стилі мають бути об'єктами. Можна використовувати camelCase (fontSize) або kebab-case у лапках ('background-color').",
    "interviewTip": "Подвійні фігурні дужки {{ }} означають передачу об'єкта JS всередину виразу JSX.",
    "options": [
      "style={{ color: 'red', fontSize: '20px' }}",
      "style='color: red;'",
      "style={{ 'background-color': 'blue' }}",
      "style={myStyleObject}"
    ]
  },
  "jc-07": {
    "prompt": "Як написати коментар всередині шаблону JSX?",
    "explanation": "Коментарі в JSX мають бути огорнуті у фігурні дужки та використовувати синтаксис багаторядкових коментарів JavaScript.",
    "interviewTip": "Однорядкові коментарі // всередині дужок іноді можуть випадково закоментувати закриваючу дужку.",
    "options": [
      "",
      "// Comment",
      "{/* Comment */}",
      "/* Comment */"
    ]
  },
  "jc-08": {
    "prompt": "Яким буде результат цього компонента?",
    "explanation": "React може рендерити масиви безпосередньо. Він просто об'єднує (конкатенує) елементи в інтерфейсі.",
    "interviewTip": "Зазвичай ви будете використовувати .map(), щоб огорнути кожен елемент у тег, наприклад <li>, щоб уникнути злипання тексту.",
    "options": [
      "A list with 3 bullet points.",
      "An error: 'Arrays are not valid as children'.",
      "ABC (the items joined as a string).",
      "A string representation: ['A', 'B', 'C']."
    ]
  },
  "jc-09": {
    "prompt": "Який атрибут у JSX використовується замість стандартного HTML-атрибута 'for' для лейблів?",
    "explanation": "'for' є зарезервованим ключовим словом у JavaScript (для циклів), тому JSX використовує 'htmlFor' для уникнення конфліктів.",
    "interviewTip": "З цієї ж причини 'class' стає 'className'.",
    "options": [
      "labelFor",
      "htmlFor",
      "forID",
      "className"
    ]
  },
  "jc-10": {
    "prompt": "Що поверне наступний вираз?",
    "explanation": "Вирази всередині фігурних дужок обчислюються, і їхній результат рендериться.",
    "interviewTip": "Ви можете виконувати будь-які обчислення JS або викликати функції всередині цих дужок.",
    "options": [
      "An empty div.",
      "\"10 + 20\"",
      "30",
      "undefined"
    ]
  },
  "jc-11": {
    "prompt": "Чому в JSX обов'язково закривати всі теги, навіть самозакриваючі, як-от <img> або <br>?",
    "explanation": "JSX — це не HTML, а розширення синтаксису, що слідує правилам XML, де кожен тег має бути закритим (наприклад, <br />).",
    "interviewTip": "Це поширена помилка для розробників, які переходять зі звичайного HTML на React.",
    "options": [
      "Because JSX is based on XML/XHTML rules which require strict closing.",
      "To make the code look more consistent.",
      "It is a requirement of the CSS-in-JS engine.",
      "Browsers will crash if tags aren't closed in JSX."
    ]
  },
  "jc-12": {
    "prompt": "Які з наведених варіантів є валідними способами не рендерити нічого з компонента?",
    "explanation": "Повернення null, false або undefined вказує React не рендерити жодного інтерфейсу. Порожній div рендерить реальний DOM-вузол.",
    "interviewTip": "Повернення null є індустріальним стандартом для «умовного приховування» компонента.",
    "options": [
      "return null;",
      "return false;",
      "return <div></div>;",
      "return undefined;"
    ]
  },
  "jc-13": {
    "prompt": "Яким буде результат виводу в консоль у цьому компоненті?",
    "explanation": "Теги JSX трансформуються в об'єкти, які описують інтерфейс. Саме це покаже 'console.log'.",
    "interviewTip": "Ці об'єкти є будівельними блоками Virtual DOM.",
    "options": [
      "The string \"<h1>Hello</h1>\".",
      "A JavaScript object (React Element).",
      "A real DOM node.",
      "undefined"
    ]
  },
  "jc-14": {
    "prompt": "Як відрендерити рядок, що містить HTML, без його екранування?",
    "explanation": "React за замовчуванням екранує всі рядки задля безпеки. 'dangerouslySetInnerHTML' — це свідомий спосіб рендерингу сирого HTML.",
    "interviewTip": "Назва нагадує, що це може відкрити ваш додаток для XSS-атак, якщо рядок походить із ненадійного джерела.",
    "options": [
      "<div>{htmlStr}</div>",
      "<div>{{htmlStr}}</div>",
      "<div dangerouslySetInnerHTML={{ __html: htmlStr }} />",
      "<div renderAsHtml={htmlStr} />"
    ]
  },
  "jc-15": {
    "prompt": "Що не так із цим компонентом?",
    "explanation": "JavaScript припиняє виконання функції після ключового слова 'return'. Код під ним ніколи не виконається.",
    "interviewTip": "Завжди огортайте багаторядковий інтерфейс у круглі дужки, щоб гарантувати повернення всього блоку.",
    "options": [
      "Variable 'name' cannot be used inside h1.",
      "The p tag is unreachable because it comes after the return statement.",
      "h1 and p must be inside a div.",
      "The h1 is not closed."
    ]
  },
  "jc-16": {
    "prompt": "Чи можна використовувати оператор JavaScript 'if' безпосередньо всередині блоку JSX?",
    "explanation": "Дужки {} приймають лише вирази (expressions). Інструкції (statements), такі як 'if', 'for' та 'switch', не дозволені всередині JSX.",
    "interviewTip": "Саме тому тернарні оператори (умова ? а : б) такі популярні в React.",
    "options": [
      "Yes, if it's inside curly braces.",
      "No, you must use ternary operators or logical && because 'if' is a statement, not an expression.",
      "Yes, but only in Class components.",
      "Yes, if you use the 'v-if' attribute."
    ]
  },
  "jc-17": {
    "prompt": "Що поверне перевірка 'typeof' для фрагмента?",
    "explanation": "React-фрагменти (та інші вбудовані типи, як-от Suspense або Profiler) є внутрішніми символами React (Symbols).",
    "interviewTip": "Фрагменти — це спеціальні «порожні» типи, які рендерер знає як обробляти без створення DOM-вузла.",
    "options": [
      "\"string\"",
      "\"object\"",
      "\"symbol\"",
      "\"function\""
    ]
  },
  "js-18": {
    "prompt": "Який із цих варіантів є правильним для передачі булевого пропса 'isActive' як true?",
    "explanation": "Передача лише назви пропса за замовчуванням встановлює його в true. {true} — це також явний і правильний варіант.",
    "interviewTip": "Більшість розробників віддають перевагу скороченню <Tab isActive /> для булевих прапорців."
  }
}