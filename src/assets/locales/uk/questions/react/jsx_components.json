{
  "jc-01": {
    "prompt": "Що станеться, якщо назвати React-компонент з маленької літери (наприклад, function myHeader())?",
    "explanation": "React використовує регістр літер, щоб розрізняти нативні HTML-теги (рядки) та власні компоненти (функції/класи).",
    "interviewTip": "Завжди використовуйте PascalCase для назв компонентів (наприклад, MyComponent)."
  },
  "jc-02": {
    "prompt": "Яким буде результат наступного коду компонента?",
    "explanation": "JSX повинен мати рівно один кореневий елемент. Ви не можете повернути кілька сусідніх тегів без спільної обгортки.",
    "interviewTip": "Це можна виправити за допомогою <div> або фрагмента (<>...</>)."
  },
  "jc-03": {
    "prompt": "Як передати змінну JavaScript як атрибут у JSX?",
    "explanation": "Щоб передати змінну як пропс або атрибут, необхідно використовувати фігурні дужки без лапок.",
    "interviewTip": "Якщо ви поставите лапки навколо дужок, React сприйме весь вираз як звичайний рядок."
  },
  "jc-04": {
    "prompt": "Що буде відрендерено цим фрагментом коду?",
    "explanation": "React не рендерить булеві значення, null або undefined. Оскільки isAdmin дорівнює false, оператор && зупиняється, і нічого не відображається.",
    "interviewTip": "Будьте обережні з 0; на відміну від false, React *буде* рендерити число 0."
  },
  "jc-05": {
    "prompt": "Яка мета використання React Fragments (<> ... </>)?",
    "explanation": "Фрагменти дозволяють дотримуватися правила «одного кореня», не засмічуючи HTML зайвими тегами <div>.",
    "interviewTip": "Фрагменти особливо корисні при роботі з CSS Flexbox або Grid, де зайві батьківські div-и можуть зламати макет."
  },
  "jc-06": {
    "prompt": "Які з цих варіантів є правильними для застосування інлайнових стилів у JSX?",
    "explanation": "Інлайнові стилі мають бути об'єктами. Можна використовувати camelCase (fontSize) або kebab-case у лапках ('background-color').",
    "interviewTip": "Подвійні фігурні дужки {{ }} означають передачу об'єкта JS всередину виразу JSX."
  },
  "jc-07": {
    "prompt": "Як написати коментар всередині шаблону JSX?",
    "explanation": "Коментарі в JSX мають бути огорнуті у фігурні дужки та використовувати синтаксис багаторядкових коментарів JavaScript.",
    "interviewTip": "Однорядкові коментарі // всередині дужок іноді можуть випадково закоментувати закриваючу дужку."
  },
  "jc-08": {
    "prompt": "Яким буде результат цього компонента?",
    "explanation": "React може рендерити масиви безпосередньо. Він просто об'єднує (конкатенує) елементи в інтерфейсі.",
    "interviewTip": "Зазвичай ви будете використовувати .map(), щоб огорнути кожен елемент у тег, наприклад <li>, щоб уникнути злипання тексту."
  },
  "jc-09": {
    "prompt": "Який атрибут у JSX використовується замість стандартного HTML-атрибута 'for' для лейблів?",
    "explanation": "'for' є зарезервованим ключовим словом у JavaScript (для циклів), тому JSX використовує 'htmlFor' для уникнення конфліктів.",
    "interviewTip": "З цієї ж причини 'class' стає 'className'."
  },
  "jc-10": {
    "prompt": "Що поверне наступний вираз?",
    "explanation": "Вирази всередині фігурних дужок обчислюються, і їхній результат рендериться.",
    "interviewTip": "Ви можете виконувати будь-які обчислення JS або викликати функції всередині цих дужок."
  },
  "jc-11": {
    "prompt": "Чому в JSX обов'язково закривати всі теги, навіть самозакриваючі, як-от <img> або <br>?",
    "explanation": "JSX — це не HTML, а розширення синтаксису, що слідує правилам XML, де кожен тег має бути закритим (наприклад, <br />).",
    "interviewTip": "Це поширена помилка для розробників, які переходять зі звичайного HTML на React."
  },
  "jc-12": {
    "prompt": "Які з наведених варіантів є валідними способами не рендерити нічого з компонента?",
    "explanation": "Повернення null, false або undefined вказує React не рендерити жодного інтерфейсу. Порожній div рендерить реальний DOM-вузол.",
    "interviewTip": "Повернення null є індустріальним стандартом для «умовного приховування» компонента."
  },
  "jc-13": {
    "prompt": "Яким буде результат виводу в консоль у цьому компоненті?",
    "explanation": "Теги JSX трансформуються в об'єкти, які описують інтерфейс. Саме це покаже 'console.log'.",
    "interviewTip": "Ці об'єкти є будівельними блоками Virtual DOM."
  },
  "jc-14": {
    "prompt": "Як відрендерити рядок, що містить HTML, без його екранування?",
    "explanation": "React за замовчуванням екранує всі рядки задля безпеки. 'dangerouslySetInnerHTML' — це свідомий спосіб рендерингу сирого HTML.",
    "interviewTip": "Назва нагадує, що це може відкрити ваш додаток для XSS-атак, якщо рядок походить із ненадійного джерела."
  },
  "jc-15": {
    "prompt": "Що не так із цим компонентом?",
    "explanation": "JavaScript припиняє виконання функції після ключового слова 'return'. Код під ним ніколи не виконається.",
    "interviewTip": "Завжди огортайте багаторядковий інтерфейс у круглі дужки, щоб гарантувати повернення всього блоку."
  },
  "jc-16": {
    "prompt": "Чи можна використовувати оператор JavaScript 'if' безпосередньо всередині блоку JSX?",
    "explanation": "Дужки {} приймають лише вирази (expressions). Інструкції (statements), такі як 'if', 'for' та 'switch', не дозволені всередині JSX.",
    "interviewTip": "Саме тому тернарні оператори (умова ? а : б) такі популярні в React."
  },
  "jc-17": {
    "prompt": "Що поверне перевірка 'typeof' для фрагмента?",
    "explanation": "React-фрагменти (та інші вбудовані типи, як-от Suspense або Profiler) є внутрішніми символами React (Symbols).",
    "interviewTip": "Фрагменти — це спеціальні «порожні» типи, які рендерер знає як обробляти без створення DOM-вузла."
  },
  "js-18": {
    "prompt": "Який із цих варіантів є правильним для передачі булевого пропса 'isActive' як true?",
    "explanation": "Передача лише назви пропса за замовчуванням встановлює його в true. {true} — це також явний і правильний варіант.",
    "interviewTip": "Більшість розробників віддають перевагу скороченню <Tab isActive /> для булевих прапорців."
  }
}
