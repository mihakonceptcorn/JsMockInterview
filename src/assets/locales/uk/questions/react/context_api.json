{
  "ca-09": {
    "prompt": "Як передати функцію через Context, щоб дозволити дочірнім компонентам оновлювати стан?",
    "explanation": "Значення Context можуть бути будь-якого типу JS. Передача об'єкта, що містить і стан, і функцію його встановлення (setter), є найпоширенішим патерном для глобального керування станом.",
    "interviewTip": "Завжди переконуйтеся, що об'єкт, який передається у 'value', мемоїзований (череp useMemo), якщо він визначений всередині компонента. Інакше створюватиметься нове посилання при кожному рендері.",
    "options": [
      "Ви не можете передавати функції через Context.",
      "Включити функцію в об'єкт, що передається в пропс 'value'.",
      "Використовувати окремий 'FunctionProvider'.",
      "Викликати функцію безпосередньо в тегах Provider."
    ]
  },
  "ca-10": {
    "prompt": "Знайдіть помилку в логіці споживання контексту:",
    "explanation": "Об'єкт контексту сам по собі є лише дескриптором. Ви повинні використовувати хук 'useContext', щоб «витягнути» фактичне значення з цього контексту.",
    "interviewTip": "Уявіть об'єкт Context як «ключ», а 'useContext' — як «замок», який він відкриває.",
    "options": [
      "theme має бути рядком.",
      "Ви повинні викликати useContext(ThemeContext), щоб отримати фактичне значення.",
      "У пропсі style пропущена крапка з комою.",
      "Display має бути написаний з великої літери."
    ]
  },
  "ca-11": {
    "prompt": "Які з цих способів є валідними для уникнення проблем із продуктивністю при використанні Context?",
    "explanation": "Розділення контекстів на кілька менших та мемоїзація — це дві найефективніші стратегії. Переміщення провайдера вище по дереву насправді збільшує кількість компонентів, на які може вплинути рендер.",
    "interviewTip": "Якщо 'React.memo' не допомагає, проблема, швидше за все, у самому значенні контексту, яке змінюється занадто часто.",
    "options": [
      "Розділення великого контексту на кілька менших.",
      "Використання 'React.memo' для компонентів-споживачів (consumers).",
      "Переміщення Provider вище по дереву компонентів.",
      "Мемоїзація пропса 'value' провайдера за допомогою 'useMemo'."
    ]
  },
  "ca-12": {
    "prompt": "Що станеться, якщо компонент викликає 'useContext', але його батьківський Provider пізніше демонтується?",
    "explanation": "Коли Provider зникає, хук шукає значення вище по дереву і, нічого не знайшовши, повертається до початкового значення за замовчуванням (default value).",
    "interviewTip": "Це гарантує «безпеку» компонента навіть під час динамічних змін макета.",
    "options": [
      "Компонент зламається (crash).",
      "Компонент повернеться до значення за замовчуванням, визначеного в 'createContext'.",
      "Компонент назавжди збереже останнє відоме значення.",
      "Компонент також автоматично демонтується."
    ]
  }
}
