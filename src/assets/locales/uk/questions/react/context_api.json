{
  "ca-09": {
    "prompt": "Як передати функцію через Context, щоб дозволити дочірнім компонентам оновлювати стан?",
    "explanation": "Значення Context можуть бути будь-якого типу JS. Передача об'єкта, що містить і стан, і функцію його встановлення (setter), є найпоширенішим патерном для глобального керування станом.",
    "interviewTip": "Завжди переконуйтеся, що об'єкт, який передається у 'value', мемоїзований (череp useMemo), якщо він визначений всередині компонента. Інакше створюватиметься нове посилання при кожному рендері."
  },
  "ca-10": {
    "prompt": "Знайдіть помилку в логіці споживання контексту:",
    "explanation": "Об'єкт контексту сам по собі є лише дескриптором. Ви повинні використовувати хук 'useContext', щоб «витягнути» фактичне значення з цього контексту.",
    "interviewTip": "Уявіть об'єкт Context як «ключ», а 'useContext' — як «замок», який він відкриває."
  },
  "ca-11": {
    "prompt": "Які з цих способів є валідними для уникнення проблем із продуктивністю при використанні Context?",
    "explanation": "Розділення контекстів на кілька менших та мемоїзація — це дві найефективніші стратегії. Переміщення провайдера вище по дереву насправді збільшує кількість компонентів, на які може вплинути рендер.",
    "interviewTip": "Якщо 'React.memo' не допомагає, проблема, швидше за все, у самому значенні контексту, яке змінюється занадто часто."
  },
  "ca-12": {
    "prompt": "Що станеться, якщо компонент викликає 'useContext', але його батьківський Provider пізніше демонтується?",
    "explanation": "Коли Provider зникає, хук шукає значення вище по дереву і, нічого не знайшовши, повертається до початкового значення за замовчуванням (default value).",
    "interviewTip": "Це гарантує «безпеку» компонента навіть під час динамічних змін макета."
  }
}
