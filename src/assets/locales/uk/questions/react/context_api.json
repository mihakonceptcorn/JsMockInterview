{
  "ca-01": {
    "prompt": "Які три основні кроки потрібні для впровадження React Context?",
    "options": [
      "Створити Context, визначити State, експортувати Component.",
      "Створити Context, надати Context (Provide), використати Context (Consume).",
      "Ініціалізувати Ref, передати Prop, запустити Effect.",
      "Імпортувати Redux, налаштувати Store, відобразити Dispatch."
    ],
    "explanation": "Спочатку ви створюєте об'єкт контексту, огортаєте батьківське дерево за допомогою Provider, а потім використовуєте hook або consumer у дочірньому елементі для доступу до даних.",
    "interviewTip": "Найпоширенішим способом використання контексту сьогодні є хук 'useContext'."
  },
  "ca-02": {
    "prompt": "Що відбувається з компонентами, які використовують Context, коли оновлюється пропс 'value' у Provider?",
    "options": [
      "Перерендериться лише батьківський компонент.",
      "Перерендериться кожен компонент у додатку.",
      "Усі компоненти, що викликають 'useContext' для цього конкретного контексту, будуть перерендерені.",
      "Нічого не станеться до повного оновлення сторінки."
    ],
    "explanation": "Context запускає повторний рендеринг для всіх споживачів (consumers) кожного разу, коли змінюється значення. Ось чому слід зберігати значення контексту стабільними або розділяти великі контексти.",
    "interviewTip": "Для оптимізації розгляньте можливість мемоїзації об'єкта значення контексту за допомогою 'useMemo'."
  },
  "ca-03": {
    "prompt": "Яким буде результат виконання наступного коду, якщо для 'UserContext' немає Provider вище Header?",
    "code": "const UserContext = createContext('Guest');\nfunction Header() {\n  const user = useContext(UserContext);\n  return <h1>{user}</h1>;\n}",
    "options": [
      "Додаток вийде з ладу з помилкою 'ProviderNotFound'.",
      "Відобразиться 'Guest'.",
      "Нічого не відобразиться (null).",
      "Відобразиться 'undefined'."
    ],
    "explanation": "Якщо в дереві компонентів не знайдено Provider, 'useContext' повертає значення за замовчуванням, передане в 'createContext(defaultValue)'.",
    "interviewTip": "Значення за замовчуванням корисні для тестування компонентів в ізоляції без необхідності огортати їх у провайдери."
  },
  "ca-04": {
    "prompt": "Які з наведених варіантів є хорошими випадками використання React Context?",
    "options": [
      "Керування поточною темою (Dark/Light mode).",
      "Зберігання тексту одного поля пошуку.",
      "Обробка автентифікації користувача / профілю поточного користувача.",
      "Керування складними високочастотними даними, як-от координати в грі в реальному часі."
    ],
    "explanation": "Context чудово підходить для «глобальних» даних, які не змінюються занадто часто. Для високочастотних оновлень Context може спричинити проблеми з продуктивністю.",
    "interviewTip": "Для станів із високою частотою оновлень часто краще підходять бібліотеки на кшталт Redux, Zustand або Recoil."
  },
  "ca-05": {
    "prompt": "Проаналізуйте код. Як має бути структурований 'App', щоб поділитися значенням 'theme'?",
    "code": "const ThemeContext = createContext();\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext.Provider value={theme}>\n      <Layout />\n    </ThemeContext.Provider>\n  );\n}",
    "options": [
      "Код правильний у поточному вигляді.",
      "Provider потребує пропс 'state' замість 'value'.",
      "ThemeContext.Provider має бути поза межами функції App.",
      "Ви повинні огорнути Provider в ще один div."
    ],
    "explanation": "Пропс 'value' — це стандартний спосіб передачі даних у дерево Context. Будь-який компонент всередині <Layout /> тепер може отримати доступ до 'theme'.",
    "interviewTip": "Якщо ви також хочете дозволити дочірнім компонентам змінювати тему, передайте `{ theme, setTheme }` як значення (value)."
  },
  "ca-06": {
    "prompt": "Чому 'useContext' є кращим за старий компонент 'Context.Consumer'?",
    "options": [
      "Він робить код більш продуктивним.",
      "Він дозволяє уникнути «пекла обгорток» (wrapper hell) та вкладених render-пропсів, що робить код пласкішим та чистішим.",
      "Він дозволяє використовувати Context у класових компонентах.",
      "Він автоматично мемоїзує дані."
    ],
    "explanation": "До появи хуків вам доводилося використовувати патерн render-prop, через що дерево JSX ставало дуже глибоким і складним для розуміння.",
    "interviewTip": "Спрощення дерева компонентів — одна з головних естетичних переваг Hooks API."
  },
  "ca-07": {
    "prompt": "Чи можна використовувати кілька провайдерів (Providers) в одному додатку?",
    "options": [
      "Ні, React дозволяє лише один Context на додаток.",
      "Так, і ви можете вкладати їх один в одного для надання різних типів даних (наприклад, Auth, Theme, Settings).",
      "Так, але тільки якщо вони стосуються одного і того ж об'єкта Context.",
      "Тільки якщо ви використовуєте хук 'useMultiContext'."
    ],
    "explanation": "Вкладення провайдерів є стандартною практикою. Компонент завжди буде споживати значення від *найближчого* провайдера конкретного контексту, що знаходиться вище в дереві.",
    "interviewTip": "Це часто називають 'Context Composition' (композиція контекстів)."
  },
  "ca-08": {
    "prompt": "Який основний ризик розміщення занадто великої кількості даних в одному об'єкті Context?",
    "options": [
      "Дані можуть бути пошкоджені.",
      "Зайві перерендери: якщо будь-яка частина об'єкта контексту зміниться, усі компоненти, що використовують цей контекст, будуть перерендерені.",
      "Розмір файлу додатка подвоїться.",
      "Це перешкоджає використанню кастомних хуків."
    ],
    "explanation": "Оскільки оновлення Context запускає рендеринг для всіх споживачів, великі «монолітні» контексти можуть призвести до затримок продуктивності.",
    "interviewTip": "Рішенням є 'Context Splitting' — створення окремих контекстів для логічно різних даних (наприклад, UserContext та ThemeContext)."
  },
  "ca-09": {
    "prompt": "Як передати функцію через Context, щоб дозволити дочірнім компонентам оновлювати стан?",
    "explanation": "Значеннями контексту можуть бути будь-які типи JS. Передача об'єкта, що містить і стан, і його setter, є найпоширенішим патерном для глобального керування станом.",
    "interviewTip": "Завжди переконуйтеся, що об'єкт, переданий у 'value', мемоїзований, якщо він визначений всередині компонента, інакше він створюватиме нове посилання при кожному рендерингу.",
    "options": [
      "Ви не можете передавати функції через Context.",
      "Включіть функцію в об'єкт, який передається в пропс 'value'.",
      "Використовуйте окремий 'FunctionProvider'.",
      "Викликайте функцію безпосередньо в тегах Provider."
    ]
  },
  "ca-10": {
    "prompt": "Знайдіть помилку в цій логіці споживання контексту (Consumer):",
    "explanation": "Самий об'єкт контексту — це лише дескриптор. Ви повинні використовувати хук 'useContext', щоб «витягнути» значення з цього контексту.",
    "interviewTip": "Уявіть об'єкт Context як «Ключ», а 'useContext' як «Замок», який його відкриває.",
    "options": [
      "theme має бути рядком.",
      "Ви повинні викликати useContext(ThemeContext), щоб отримати реальне значення.",
      "У пропсі style пропущено крапку з комою.",
      "Display має бути написаний з великої літери."
    ]
  },
  "ca-11": {
    "prompt": "Які з цих варіантів є валідними способами уникнення проблем із продуктивністю при використанні Context?",
    "explanation": "Розділення (splitting) та мемоїзація — дві найефективніші стратегії. Переміщення провайдера вище насправді збільшує кількість потенційних компонентів, на які вплине рендеринг.",
    "interviewTip": "Якщо 'React.memo' не допомагає, вузьким місцем, швидше за все, є саме значення контексту, яке змінюється занадто часто.",
    "options": [
      "Розділення великого контексту на кілька менших.",
      "Використання 'React.memo' для компонентів-споживачів.",
      "Переміщення Provider вище по дереву компонентів.",
      "Мемоїзація пропса 'value' провайдера за допомогою 'useMemo'."
    ]
  },
  "ca-12": {
    "prompt": "Що станеться, якщо компонент викликає 'useContext', але його батьківський Provider пізніше був демонтований?",
    "explanation": "Коли Provider зникає, хук шукає вгору по дереву і, нічого не знайшовши, повертається до початкового значення за замовчуванням.",
    "interviewTip": "Це гарантує, що компонент залишається «безпечним» навіть під час динамічних змін макета.",
    "options": [
      "Додаток вийде з ладу.",
      "Компонент повернеться до значення за замовчуванням, визначеного в 'createContext'.",
      "Компонент назавжди збереже останнє відоме значення.",
      "Компонент також автоматично демонтується."
    ]
  }
}
