{
  "sb-01": {
    "prompt": "Що відбувається, коли ви оновлюєте змінну стану React за допомогою її функції-сетера?",
    "explanation": "Виклик сетера стану повідомляє React, що дані змінилися, що ініціює повторний рендеринг для синхронізації інтерфейсу з новими даними.",
    "interviewTip": "Пам'ятайте, що оновлення стану є асинхронними та групуються (batched) задля підвищення продуктивності.",
    "options": [
      "The browser window reloads to fetch new data.",
      "The component and its children are scheduled to re-render.",
      "The variable is updated, but the UI remains the same until a manual refresh.",
      "The entire application state is reset to its initial values."
    ]
  },
  "sb-02": {
    "prompt": "Який правильний спосіб ініціалізувати змінну стану 'count' значенням 0?",
    "explanation": "useState повертає масив, де перший елемент — це поточний стан, а другий — функція оновлення. Ми використовуємо деструктуризацію масиву, щоб дати їм імена.",
    "interviewTip": "Завжди використовуйте 'const' для змінних стану, тому що ви ніколи не повинні мутувати їх напряму; лише сетер має їх змінювати.",
    "options": [
      "const [count, setCount] = useState(0);",
      "const count = useState(0);",
      "let [count, setCount] = useState(0);",
      "const [setCount, count] = useState(0);"
    ]
  },
  "sb-03": {
    "prompt": "Яким буде значення 'count', відображене в інтерфейсі, після одного натискання кнопки?",
    "explanation": "Оскільки 'count' береться з області видимості поточного рендеру, усі три виклики бачать 'count' як 0. React групує їх, і результатом буде 0 + 1.",
    "interviewTip": "Це класичний приклад «застарілого замикання» (Stale Closure). Щоб виправити це, використовуйте функціональний патерн оновлення: setCount(prev => prev + 1).",
    "options": [
      "3",
      "0",
      "1",
      "undefined"
    ]
  },
  "sb-04": {
    "prompt": "Які з наведених тверджень щодо правил хуків (Rules of Hooks) є правильними?",
    "explanation": "Хуки повинні мати стабільний порядок виклику. Розміщення їх у циклах або умовах порушує здатність React правильно відстежувати стан.",
    "interviewTip": "Якщо вам потрібен хук за умовою, помістіть умову *всередину* хука (наприклад, у useEffect), а не огортайте нею сам хук.",
    "options": [
      "Hooks must be called at the top level of the component.",
      "Hooks can be called inside loops if the array length is constant.",
      "Hooks can only be called from React functional components or custom hooks.",
      "Hooks can be called inside 'if' statements if the condition is based on props."
    ]
  },
  "sb-05": {
    "prompt": "Як правильно оновити стан-об'єкт, зберігаючи існуючі поля?",
    "explanation": "Функція-сетер повністю замінює стан. Щоб оновити поле, ви повинні розгорнути (spread) існуючий стан і перезаписати потрібне поле.",
    "interviewTip": "Пряма мутація 'user.age' не спрацює, бо React використовує Object.is для перевірки змін. Якщо посилання на об'єкт те саме, рендеринг не відбудеться.",
    "options": [
      "setUser({ age: 26 });",
      "user.age = 26; setUser(user);",
      "setUser({ ...user, age: 26 });",
      "setUser(Object.assign(user, { age: 26 }));"
    ]
  },
  "sb-06": {
    "prompt": "Яка основна перевага патерна «лінивої ініціалізації» (Lazy Initializer)?",
    "explanation": "Якщо ви передаєте початкове значення напряму, воно обчислюється при кожному рендері. Якщо ви передаєте функцію, React виконує її лише під час першого рендеру.",
    "interviewTip": "Використовуйте це для важких завдань, як-от парсинг великого JSON зі сховища або складні математичні обчислення.",
    "options": [
      "It makes the state update asynchronously.",
      "It ensures the function only runs once during the initial mount.",
      "It automatically caches the result in localStorage.",
      "It allows the state to be shared with other components."
    ]
  },
  "sb-07": {
    "prompt": "Як отримати доступ до значення поля введення в «керованому компоненті» (Controlled Component)?",
    "explanation": "Синтетичний об'єкт події 'e' у React містить властивість 'target', що вказує на DOM-елемент, який має властивість 'value'.",
    "interviewTip": "У керованих компонентах стан є «єдиним джерелом істини» для значення інпуту.",
    "options": [
      "e.target.value",
      "e.value",
      "text.current",
      "this.input.value"
    ]
  },
  "sb-08": {
    "prompt": "Що таке 'SyntheticEvent' у React?",
    "explanation": "React створює ці обгортки, щоб події поводилися ідентично в Chrome, Safari, Firefox та Edge.",
    "interviewTip": "Ви все одно можете отримати доступ до нативної події браузера через 'e.nativeEvent', якщо це абсолютно необхідно.",
    "options": [
      "An event that is created by a library like Redux.",
      "A cross-browser wrapper around the browser’s native event.",
      "An event that doesn't actually exist in the DOM.",
      "A way to simulate user clicks during automated testing."
    ]
  },
  "sb-09": {
    "prompt": "Що станеться, якщо ви оновите стан тим самим значенням, яке він має зараз?",
    "explanation": "React використовує Object.is для порівняння нового стану зі старим. Якщо вони ідентичні, React уникає зайвої роботи з рендерингу.",
    "interviewTip": "Ось чому мутація масиву та виклик setState(тойСамийМасив) не працює — посилання ідентичне.",
    "options": [
      "React will re-render exactly once more.",
      "React will bail out and skip the re-render entirely.",
      "The component will unmount and remount.",
      "The app will throw an 'IdentityError'."
    ]
  },
  "sb-10": {
    "prompt": "Проаналізуйте код. Що буде виведено в консоль після натискання кнопки?",
    "explanation": "Встановлення стану є асинхронним. Змінна 'val' належить до поточного кадру виконання і не зміниться до наступного рендеру.",
    "interviewTip": "Якщо вам потрібно виконати дію після оновлення стану, використовуйте хук 'useEffect'.",
    "options": [
      "20",
      "10",
      "undefined",
      "null"
    ]
  },
  "sb-11": {
    "prompt": "Які з цих способів є валідними для запуску функції при натисканні кнопки?",
    "explanation": "Варіант А передає посилання. Варіант С створює анонімну функцію. Варіант D помилковий, бо він виконує функцію *під час* рендерингу.",
    "interviewTip": "Остерігайтеся запису 'onClick={handleClick()}'; це спричинить нескінченний цикл, якщо handleClick оновлює стан.",
    "options": [
      "onClick={handleClick}",
      "onclick={handleClick}",
      "onClick={() => handleClick()}",
      "onClick={handleClick()}"
    ]
  },
  "sb-12": {
    "prompt": "Як очистити інтервал, створений всередині компонента при використанні таймерів стану?",
    "explanation": "Щоб запобігти витокам пам'яті та неочікуваній поведінці, ви повинні очищати побічні ефекти, як-от інтервали, коли компонент демонтується.",
    "interviewTip": "Це ключова частина керування життєвим циклом компонента.",
    "options": [
      "Call deleteInterval() in the button click.",
      "Use the cleanup function of a useEffect hook.",
      "Set the interval variable to null.",
      "React clears all intervals automatically on every render."
    ]
  },
  "sb-13": {
    "prompt": "Що таке «підняття стану» (State Lifting)?",
    "explanation": "Коли двом сусіднім компонентам потрібно бути синхронізованими, ви переносити стан до їхнього спільного батька і передаєте його назад через пропси.",
    "interviewTip": "Це стандартний спосіб спільного використання стану без використання Context.",
    "options": [
      "A way to make state globally available to all components.",
      "Moving state to the closest common parent of components that need to share it.",
      "Deleting state from a component to improve performance.",
      "Using a library like Redux to handle state."
    ]
  },
  "sb-14": {
    "prompt": "Яке значення за замовчуванням має 'event.preventDefault()' у формі 'onSubmit'?",
    "explanation": "За замовчуванням HTML-форми перезавантажують сторінку. У React-додатках (SPA) ми запобігаємо цьому, щоб обробити відправку через JS.",
    "interviewTip": "Завжди пам'ятайте про це в обробниках форм, щоб не втратити стан вашої програми.",
    "options": [
      "It stops the browser from reloading the page.",
      "It clears the state of all input fields.",
      "It validates the form data automatically.",
      "It prevents the user from clicking the submit button twice."
    ]
  },
  "sb-15": {
    "prompt": "Як правильно обробити оновлення стану, яке залежить від попереднього стану?",
    "explanation": "Функціональні оновлення гарантують, що ви працюєте з найсвіжішим станом, навіть якщо в черзі є кілька оновлень.",
    "interviewTip": "Цей патерн є необхідним, коли оновлення стану ініціюються швидко (наприклад, в інтервалі або під час високочастотних подій).",
    "options": [
      "Passing a function to the setter (Functional Update).",
      "Passing the updated variable directly.",
      "Using a global variable for the calculation.",
      "Calling useState again."
    ]
  },
  "sb-16": {
    "prompt": "Де можна визначити стан у функціональному компоненті?",
    "explanation": "Згідно з правилами хуків, вони повинні викликатися в самому верху вашої функції компонента.",
    "interviewTip": "React використовує порядок викликів, щоб зіставити стан із правильним екземпляром компонента.",
    "options": [
      "Anywhere inside the function body.",
      "Inside event handlers.",
      "Only at the top level of the component function.",
      "Inside the return statement."
    ]
  },
  "sb-17": {
    "prompt": "Що таке «некерований компонент» (Uncontrolled Component)?",
    "explanation": "У некерованих компонентах дані форми обробляються самим DOM. Ви використовуєте 'useRef', щоб отримати значення, коли це потрібно.",
    "interviewTip": "Керованим компонентам зазвичай віддають перевагу для складних форм, тоді як некеровані підходять для простих одноразових полів.",
    "options": [
      "A component that doesn't use state and relies on the DOM (via Refs) for data.",
      "A component that has a bug causing it to re-render infinitely.",
      "A component that doesn't accept any props.",
      "A component that is not part of the Virtual DOM."
    ]
  }
}