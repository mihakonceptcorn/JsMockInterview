{
  "nm-01": {
    "prompt": "In the legacy architecture, what is the role of 'RCTBridgeModule' on iOS?",
    "explanation": "To expose a native class to JS, it must implement the RCTBridgeModule protocol and use the RCT_EXPORT_MODULE macro.",
    "interviewTip": "Remember that data passed through this bridge must be serialized into JSON, which can be a bottleneck."
  },
  "nm-02": {
    "prompt": "What is the primary technical improvement of 'Turbo Modules' over the legacy Native Modules?",
    "explanation": "Legacy modules are all initialized at app launch, slowing down startup. Turbo Modules are loaded on demand and allow synchronous calls via JSI (JavaScript Interface).",
    "interviewTip": "If an interviewer asks about app startup performance, mention 'Lazy Loading' of Turbo Modules."
  },
  "nm-03": {
    "prompt": "Analyze the Android native code. What is the purpose of the @ReactMethod annotation?",
    "explanation": "Without this annotation, the method remains invisible to the React Native bridge, even if the class itself is exported.",
    "interviewTip": "Only methods marked with @ReactMethod can be triggered via 'NativeModules.ModuleName.methodName()'."
  },
  "nm-04": {
    "prompt": "How does JavaScript communicate with the native side in the New Architecture without serialization?",
    "explanation": "JSI allows the JavaScript engine (Hermes) to hold a reference to a C++ object, enabling direct, synchronous method calls instead of passing JSON messages.",
    "interviewTip": "JSI is what makes 'Reanimated' so fast—it allows the UI to update without waiting for the bridge."
  },
  "nm-05": {
    "prompt": "What is the purpose of 'Codegen' in the New Architecture?",
    "explanation": "Codegen ensures type safety between JS and Native code. It creates the 'glue' code automatically so you don't have to write C++ boilerplate manually.",
    "interviewTip": "Codegen helps prevent runtime crashes caused by sending the wrong data types across the JS-Native boundary."
  },
  "nm-06": {
    "prompt": "Which of these are valid ways to send data from Native back to JavaScript?",
    "explanation": "Callbacks and Promises are for responses to specific calls. Events (EventEmitter) are for native actions the JS didn't trigger, like a GPS location update.",
    "interviewTip": "Always remember to remove event listeners in 'useEffect' cleanup to avoid memory leaks."
  },
  "nm-07": {
    "prompt": "What is a 'Native UI Component' (as opposed to a Native Module)?",
    "explanation": "While Native Modules provide 'logic', Native UI Components provide 'views'. You use 'requireNativeComponent' to bring them into your JSX.",
    "interviewTip": "If you need a very complex UI element that doesn't exist in RN, you build a 'ViewManager' on the native side."
  },
  "nm-08": {
    "prompt": "Identify the issue in this iOS native method:",
    "explanation": "Legacy bridge methods are asynchronous and return 'void'. To get a result back to JS, you must pass an RCTResponseSenderBlock or an RCTPromiseResolveBlock.",
    "interviewTip": "In the New Architecture with JSI, you actually *can* return values synchronously."
  },
  "nm-09": {
    "prompt": "What does the 'RCT_EXPORT_MODULE()' macro do?",
    "explanation": "Without this macro, React Native's bridge won't know the class exists at runtime.",
    "interviewTip": "You can pass an optional name to the macro (e.g., RCT_EXPORT_MODULE(MyCustomName)) to change how it appears in JS."
  },
  "nm-10": {
    "prompt": "What is 'Fabric' in the New Architecture and how does it differ from the legacy renderer?",
    "explanation": "The legacy renderer used an asynchronous bridge to send UI updates. Fabric uses JSI to communicate synchronously with the native UI thread, enabling features like priority-based rendering and layout animations.",
    "interviewTip": "Fabric is the 'React 18 Concurrent Mode' equivalent for the native side—it allows React Native to interrupt and prioritize UI updates."
  }
}
