{
  "ra-01": {
    "prompt": "What is a 'Worklet' in the context of React Native Reanimated?",
    "explanation": "Worklets are the core of Reanimated. They allow JavaScript code to be executed synchronously on the UI thread, bypassing the asynchronous bridge for immediate UI updates.",
    "interviewTip": "Mention that Reanimated 2+ uses a separate JS VM on the UI thread to execute these worklets."
  },
  "ra-02": {
    "prompt": "Which hook is used to create a mutable value that can be shared between the JS thread and the UI thread?",
    "explanation": "useSharedValue is the Reanimated version of state. When you change its '.value' property, it automatically triggers animations or updates style objects on the UI thread.",
    "interviewTip": "Unlike useState, changing a shared value does not trigger a React component re-render on the main JS thread."
  },
  "ra-03": {
    "prompt": "Analyze the code. What is the correct way to apply the shared value to a component's style?",
    "explanation": "useAnimatedStyle returns a style object that 'listens' to shared values. Whenever the shared value changes, the UI thread updates the view without a bridge round-trip.",
    "interviewTip": "Always ensure the component is an 'Animated' version (e.g., Animated.View) from the reanimated library."
  },
  "ra-04": {
    "prompt": "How do you smoothly animate a shared value to a new position using a spring physics model?",
    "explanation": "withSpring is a 'wrapper' function that describes how the transition to the new value should look. It uses spring physics (stiffness, damping) instead of time.",
    "interviewTip": "Unlike the standard Animated API, Reanimated allows you to set the new value directly: `val.value = withSpring(target)`."
  },
  "ra-05": {
    "prompt": "What is the purpose of 'useDerivedValue'?",
    "explanation": "useDerivedValue creates a read-only shared value that automatically updates whenever the dependencies inside its worklet change.",
    "interviewTip": "Think of this as the 'useMemo' of the UI thread."
  },
  "ra-06": {
    "prompt": "Which of these features were introduced in Reanimated 3?",
    "explanation": "Reanimated 3 focused heavily on compatibility with the New Architecture and robust Shared Element Transitions between navigation screens.",
    "interviewTip": "Shared Element Transitions make apps feel extremely high-end, similar to the App Store or Instagram."
  },
  "ra-07": {
    "prompt": "How do you run a piece of JavaScript code on the main JS thread after an animation finishes on the UI thread?",
    "explanation": "Since the completion callback runs on the UI thread, you must use runOnJS to 'call back' to the JavaScript thread for things like alerts or state updates.",
    "interviewTip": "Failing to use runOnJS inside a worklet when calling a JS function will cause a crash."
  },
  "ra-08": {
    "prompt": "What are 'Layout Animations' in Reanimated?",
    "explanation": "Layout animations provide a simple way to animate mounting/unmounting and layout shifts without managing complex shared values manually.",
    "interviewTip": "Use `Layout.springify()` to make list item shifts look bouncy and natural."
  },
  "ra-09": {
    "prompt": "What is the function of 'interpolateColor' in Reanimated?",
    "explanation": "Similar to standard interpolation, but specifically optimized for the UI thread to handle color transitions smoothly.",
    "interviewTip": "This is perfect for changing a header color from white to transparent as the user scrolls."
  },
  "ra-10": {
    "prompt": "Why is 'useAnimatedGestureHandler' (v2) or using gestures with Reanimated (v3) better than standard touch events?",
    "explanation": "By linking Gesture Handler with Reanimated, the 'translation' data from a finger swipe can update a shared value and move a View entirely on the UI thread.",
    "interviewTip": "This is the key to building 60/120 FPS 'pull-to-dismiss' or 'swipe-to-delete' interactions."
  }
}
