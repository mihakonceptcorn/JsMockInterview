{
  "vca-01": {
    "prompt": "What is the main technical difference between 'ref' and 'reactive' in Vue 3?",
    "explanation": "ref wraps any value in an object with a .value property. reactive uses Proxies directly on an object and does not work with primitives like strings or booleans.",
    "interviewTip": "When in doubt, use 'ref'. It is more consistent and makes it clear when you are dealing with reactive data versus plain variables.",
    "options": [
      "ref is only for strings, while reactive is for numbers.",
      "ref can take primitive values (like 0 or true) and objects, while reactive only accepts objects.",
      "reactive is faster than ref.",
      "ref works on the server side, reactive only on the client."
    ]
  },
  "vca-02": {
    "prompt": "Analyze the code. What will happen to reactivity when 'user' is destructured?",
    "explanation": "Destructuring a reactive object is like copying a property. To preserve reactivity while destructuring, you must use 'toRefs(user)'.",
    "interviewTip": "This is a frequent interview question. Use 'toRefs' or 'toRef' to safely unpack reactive objects into individual refs.",
    "options": [
      "The 'name' variable will update to 'John'.",
      "The 'name' variable will remain 'Alex' because destructuring reactive objects breaks the reactivity link.",
      "Vue will throw a warning about unsafe destructuring.",
      "Reactivity is preserved if you use 'let' instead of 'const'."
    ]
  },
  "vca-03": {
    "prompt": "Which compiler macro is used in <script setup> to make components, props, and variables automatically available to the template?",
    "explanation": "<script setup> is a compile-time transform that simplifies the Composition API by removing the need to manually return everything from a setup() function.",
    "interviewTip": "Mention that <script setup> leads to better runtime performance and smaller code bundles.",
    "options": [
      "defineComponent",
      "setup()",
      "<script setup> (it is the feature itself)",
      "export default"
    ]
  },
  "vca-04": {
    "prompt": "Analyze the code. How should you update the value of a 'ref' in the script block?",
    "explanation": "In the script block, you must access the '.value' property to read or write to a ref. In the template, Vue automatically unwraps it for you.",
    "interviewTip": "Losing the '.value' is the #1 bug for developers moving from Options API to Composition API.",
    "options": [
      "count",
      "count.value",
      "count()",
      "this.count"
    ]
  },
  "vca-05": {
    "prompt": "What is the purpose of the 'shallowRef()' function?",
    "explanation": "shallowRef is a performance optimization. It's useful when you have large objects or third-party library instances where you only care about replacing the entire object, not tracking every single nested key.",
    "interviewTip": "Mention this when asked how to optimize performance for large datasets that don't need deep reactivity.",
    "options": [
      "To create a ref that only works for one render.",
      "To create a ref where only the '.value' property is reactive, but internal properties of the object are not tracked.",
      "To create a ref with a lower memory footprint for numbers.",
      "To make a ref read-only."
    ]
  },
  "vca-06": {
    "prompt": "Which of these are valid reasons to prefer the Composition API over the Options API for large projects?",
    "explanation": "Composition API is designed for scalability. Options API often leads to 'fragmented' code where logic for one feature is scattered across data, computed, and methods.",
    "interviewTip": "A great keyword to use is 'Logical Concerns'â€”Composition API groups code by what it *does*, not what it *is*.",
    "options": [
      "Easier to extract and reuse logic via 'Composables'.",
      "Better TypeScript type inference and support.",
      "Groups code by logical concern (e.g., 'Search logic' together) rather than by option type.",
      "It completely removes the need for Virtual DOM."
    ]
  },
  "vca-07": {
    "prompt": "How do you provide a default value to props when using 'defineProps' in <script setup> with TypeScript?",
    "explanation": "When using type-only declarations in defineProps, you use the 'withDefaults' compiler macro to set default values.",
    "interviewTip": "This is the most 'professional' way to handle props in a TypeScript-based Vue 3 project.",
    "options": [
      "withDefaults(defineProps, { msg: 'hello' })",
      "defineProps({ msg: { default: 'hello' } })",
      "defineProps<Props>({ msg: 'hello' })",
      "assignProps({ msg: 'hello' })"
    ]
  },
  "vca-08": {
    "prompt": "What does 'unref()' do?",
    "explanation": "unref is a utility for writing flexible functions. It's shorthand for: `isRef(val) ? val.value : val`.",
    "interviewTip": "This is very useful inside 'Composables' where an input might be a ref or a plain value.",
    "options": [
      "It deletes the reactivity from an object permanently.",
      "It returns the inner value if the argument is a ref, otherwise it returns the argument itself.",
      "It converts a reactive object into a ref.",
      "It forces a component to re-render."
    ]
  },
  "vca-09": {
    "prompt": "How do you provide and inject dependencies in the Composition API?",
    "explanation": "provide() and inject() allow you to pass data down the component tree without props. This is Vue's dependency injection system.",
    "interviewTip": "Mention that inject() can take a default value as a second argument, and that provided values are not reactive unless you explicitly make them so.",
    "options": [
      "useInject",
      "inject",
      "getProvided",
      "consume"
    ]
  },
  "vca-10": {
    "prompt": "What is 'effectScope()' used for in Vue 3?",
    "explanation": "effectScope() is an advanced API that allows you to manually control when effects (watchers, computed, etc.) are created and destroyed. This is useful for plugin authors and advanced composables.",
    "interviewTip": "Mentioning effectScope shows deep knowledge of Vue's reactivity system and is rarely asked in junior interviews.",
    "options": [
      "To limit the scope of CSS styles.",
      "To create a scope that can collect and dispose of reactive effects together, useful for cleanup in composables.",
      "To improve the performance of computed properties.",
      "To define the scope of template variables."
    ]
  }
}