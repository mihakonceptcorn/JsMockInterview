{
  "as-01": {
    "prompt": "Which function is used to define a component that is loaded lazily from the server only when it is rendered?",
    "explanation": "defineAsyncComponent accepts a loader function that returns a Promise (usually a dynamic import). Vue handles the loading logic automatically.",
    "interviewTip": "Mention that this is a key technique for reducing the 'Initial Bundle Size' of your application."
  },
  "as-02": {
    "prompt": "Analyze the code. What will happen while 'AdminPanel' is downloading?",
    "explanation": "By default, an async component won't show anything during loading. You can provide a 'loadingComponent' option in defineAsyncComponent or wrap the usage in a <Suspense> tag.",
    "interviewTip": "Using a skeleton loader as the 'loadingComponent' provides a much better UX than a blank space."
  },
  "as-03": {
    "prompt": "What are the two 'slots' provided by the <Suspense> component?",
    "explanation": "The #default slot contains the content that might take time to load, and the #fallback slot contains what to show in the meantime (e.g., a spinner).",
    "interviewTip": "Note that as of Vue 3.x, <Suspense> is still technically an 'experimental' feature, though it is widely used."
  },
  "as-04": {
    "prompt": "Analyze the code. What makes this component 'async' and capable of triggering a <Suspense> boundary?",
    "explanation": "In Vue 3, if a <script setup> contains top-level 'await', the component automatically becomes an 'async dependency' and must be wrapped in <Suspense> by its parent.",
    "interviewTip": "This is a very elegant way to handle data fetching, as you don't need a separate 'loading' state ref inside the component."
  },
  "as-05": {
    "prompt": "How do you handle errors (like network failure) when an async component fails to load?",
    "explanation": "While defineAsyncComponent has an 'errorComponent' option, the standard way to catch errors from async dependencies in a tree is the onErrorCaptured hook.",
    "interviewTip": "You can also use the 'error' slot if your project uses a specialized wrapper, but onErrorCaptured is the official global/parent solution."
  },
  "as-06": {
    "prompt": "Which of these are valid options when configuring 'defineAsyncComponent'?",
    "explanation": "delay prevents 'flickering' for fast connections. timeout prevents users from waiting forever. suspensible (default: true) allows the component to control the parent Suspense state.",
    "interviewTip": "Set 'delay: 0' if you want the loading spinner to appear immediately, even for fast loads."
  },
  "as-07": {
    "prompt": "Can <Suspense> handle multiple nested async components simultaneously?",
    "explanation": "Suspense is designed to coordinate multiple async dependencies. The fallback stays visible until the entire tree of async components underneath is ready.",
    "interviewTip": "This prevents 'pop-in' effects where different parts of a page load at different times."
  },
  "as-08": {
    "prompt": "What is the purpose of the 'onError' retry function in defineAsyncComponent?",
    "explanation": "The 'retry' callback allows you to attempt to reload the component, which is useful for handling temporary network issues.",
    "interviewTip": "This is a great 'Senior' level feature to mention for building resilient applications."
  },
  "acs-09": {
    "prompt": "How do you define an async component in Vue 3?",
    "explanation": "defineAsyncComponent accepts a loader function that returns a Promise resolving to the component definition, enabling code splitting.",
    "interviewTip": "You can provide loading, error, delay, and timeout options for better UX."
  },
  "acs-10": {
    "prompt": "What is the purpose of the <Suspense> component?",
    "explanation": "Suspense allows you to show a loading state while async components or async setup() are resolving, providing a better user experience.",
    "interviewTip": "Suspense is still experimental in Vue 3 but is a core feature for async data fetching patterns."
  }
}
