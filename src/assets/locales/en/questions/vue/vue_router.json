{
  "vr-01": {
    "prompt": "How do you define a dynamic route segment that captures a specific value, like a user ID?",
    "explanation": "Colons denote dynamic segments. The value passed in the URL (e.g., /user/123) will be accessible via 'route.params.id'.",
    "interviewTip": "You can use Regex in paths for more strict matching, like /user/:id(\\\\d+).",
    "options": [
      ":id",
      "{id}",
      "*id",
      "?id"
    ]
  },
  "vr-02": {
    "prompt": "Analyze the code. What is the difference between these two navigation methods?",
    "explanation": "Replace is used when you don't want the user to be able to go 'back' to the previous screen (e.g., after a successful login).",
    "interviewTip": "Use 'replace' for redirects or transient states to keep the history stack clean.",
    "options": [
      "Option A is for external links; Option B is for internal.",
      "Option A adds a new entry to the history stack; Option B overwrites the current entry.",
      "Option B is faster than Option A.",
      "There is no difference."
    ]
  },
  "vr-03": {
    "prompt": "Which hook should you use inside a component to perform logic *before* a user leaves the current page?",
    "explanation": "onBeforeRouteLeave is a specialized router hook. It allows you to prevent navigation (e.g., if the user has unsaved changes in a form).",
    "interviewTip": "You can return 'false' from this hook to cancel the navigation.",
    "options": [
      "onUnmounted",
      "onBeforeRouteLeave",
      "onBeforeRouteUpdate",
      "watchEffect"
    ]
  },
  "vr-04": {
    "prompt": "What is the primary benefit of 'Lazy Loading' routes in the router configuration?",
    "explanation": "Dynamic imports () => import(...) create a separate bundle for that route, significantly improving the initial load time of the app.",
    "interviewTip": "For large enterprise apps, lazy loading every non-critical route is a mandatory performance optimization.",
    "options": [
      "It makes the components load more slowly.",
      "It splits the application into smaller chunks, only downloading the code for a page when the user actually visits it.",
      "It automatically compresses the images on that page.",
      "It allows the page to work offline."
    ]
  },
  "vr-05": {
    "prompt": "How do you access the current route's parameters inside a <script setup> block?",
    "explanation": "useRoute gives you access to the current state (params, query, path). useRouter gives you the ability to navigate (push, back).",
    "interviewTip": "Don't mix them up! UseRoute is for 'What is happening now'; UseRouter is for 'What should happen next'.",
    "options": [
      "useRouter",
      "useRoute",
      "getParams",
      "routeLink"
    ]
  },
  "vr-06": {
    "prompt": "Which of these are valid Global Navigation Guards?",
    "explanation": "Navigation guards are used to protect routes (e.g., checking for auth tokens).",
    "interviewTip": "Mention 'beforeEach' as the primary place for implementing authentication checks.",
    "options": [
      "router.beforeEach (runs before every navigation)",
      "router.afterEach (runs after navigation is complete)",
      "router.beforeResolve (runs before navigation is confirmed, after in-component guards)",
      "router.onMount (runs when the app starts)"
    ]
  },
  "vr-07": {
    "prompt": "What is the purpose of the <router-view> component?",
    "explanation": "RouterView is where the magic happens. Without it, you might change the URL, but the UI won't update to show the new component.",
    "interviewTip": "You can use multiple <router-view> components with names to create complex layouts.",
    "options": [
      "To show a list of all available routes.",
      "As a placeholder that renders the component matched by the current URL.",
      "To create a link to another page.",
      "To debug the routing state."
    ]
  },
  "vr-08": {
    "prompt": "Analyze the code. What is the value of 'props' being set to true?",
    "explanation": "Setting 'props: true' decouples the component from the router. The User component can declare 'props: ['id']' and use it without knowing about 'this.$route'.",
    "interviewTip": "This makes components much easier to unit test because they don't depend on the global router state.",
    "options": [
      "It allows the component to use CSS props.",
      "It passes the route parameters (like :id) directly as props to the component.",
      "It makes the route public.",
      "It automatically validates the data types."
    ]
  },
  "vr-09": {
    "prompt": "How do you programmatically navigate to a different route in Vue Router?",
    "explanation": "$router is the router instance with navigation methods. $route is the current route information object.",
    "interviewTip": "In Composition API, use useRouter() to access the router instance.",
    "options": [
      "this.$router.push('/path')",
      "this.$route.push('/path')",
      "router.navigate('/path')",
      "window.location = '/path'"
    ]
  },
  "vr-10": {
    "prompt": "What is the purpose of route guards in Vue Router?",
    "explanation": "Navigation guards (beforeEach, beforeEnter, beforeRouteEnter, etc.) allow you to implement authentication, authorization, and other navigation logic.",
    "interviewTip": "Global guards run for all routes, per-route guards run for specific routes, and in-component guards run within components.",
    "options": [
      "To protect routes from unauthorized access and control navigation flow.",
      "To guard against XSS attacks.",
      "To prevent route changes.",
      "To encrypt route parameters."
    ]
  }
}