{
  "perf-v-01": {
    "prompt": "Which directive should be used for content that never changes after the initial render to skip Virtual DOM tracking and patching?",
    "explanation": "v-once treats the element and its children as static content. Once rendered, Vue skips it entirely during update cycles, reducing the work of the Virtual DOM.",
    "interviewTip": "Use v-once for static help text or icons inside heavy components."
  },
  "perf-v-02": {
    "prompt": "Analyze the code. What is the benefit of using 'v-memo' here?",
    "explanation": "v-memo (Vue 3.2+) memoizes a sub-tree of the template. It only updates if the dependencies in the array change. This is a massive optimization for large lists where only one item changes at a time.",
    "interviewTip": "v-memo is essentially 'React.memo' but for a specific piece of a template."
  },
  "perf-v-03": {
    "prompt": "How does 'shallowRef' help with performance when dealing with massive objects (e.g., a huge JSON response)?",
    "explanation": "Standard 'ref' is deep. For a list of 10,000 items, Vue has to set up thousands of Proxies. 'shallowRef' avoids this overhead, only triggering an update if you replace the entire object.",
    "interviewTip": "This is the go-to solution for integrating large third-party instances (like OpenLayers or Three.js) into Vue."
  },
  "perf-v-04": {
    "prompt": "Analyze the code. Why might this 'computed' property cause performance issues?",
    "explanation": "Computed caching only works if the result is accessed again *without* the dependency changing. If the source data is a stream or updates rapidly, you are performing a heavy sort 60 times a second.",
    "interviewTip": "Consider debouncing the input data or moving the sort to a Web Worker if the calculation is too heavy."
  },
  "perf-v-05": {
    "prompt": "Which of the following are 'Tree Shaking' friendly practices in Vue 3?",
    "explanation": "Tree shaking allows the bundler to remove unused Vue features from your final JS file. Vue 3 was rewritten to be modular specifically for this reason.",
    "interviewTip": "Mention that Vue 3's core is 'tree-shakable,' meaning if you don't use `<Transition>`, it won't be in your final bundle."
  },
  "perf-v-06": {
    "prompt": "What is the purpose of the 'markRaw' utility?",
    "explanation": "Some objects (like complex class instances or React components being used inside Vue) should not be reactive. markRaw tags them so Vue ignores them, saving performance.",
    "interviewTip": "This is vital when wrapping external libraries that have their own internal state management."
  },
  "perf-v-07": {
    "prompt": "Analyze the code. Which directive is better for a component that toggles visibility 100 times per minute?",
    "explanation": "v-show only toggles CSS 'display: none'. v-if would destroy and re-create the component 100 times, which is very CPU intensive.",
    "interviewTip": "Always relate the choice to 'Initialization cost' vs 'Runtime cost'."
  },
  "perf-v-08": {
    "prompt": "What is 'Virtual List Rendering' (or Windowing)?",
    "explanation": "If you have 10,000 items, rendering 10,000 DOM nodes will crash the browser. Virtual lists only render the ~10 items the user actually sees.",
    "interviewTip": "Mention libraries like `vue-virtual-scroller` for high-performance lists."
  },
  "pov-09": {
    "prompt": "What is the purpose of v-memo directive in Vue 3?",
    "explanation": "v-memo is similar to React.memo but for templates. It's particularly useful for optimizing large v-for lists.",
    "interviewTip": "v-memo was introduced in Vue 3.2 and is most effective when combined with v-for."
  },
  "pov-10": {
    "prompt": "How can you reduce the bundle size of a Vue application?",
    "explanation": "Code splitting through dynamic imports allows you to load only the code needed for the current route, reducing initial bundle size.",
    "interviewTip": "Combine with tree-shaking, proper build configuration, and analyzing bundle size with tools like webpack-bundle-analyzer."
  }
}
