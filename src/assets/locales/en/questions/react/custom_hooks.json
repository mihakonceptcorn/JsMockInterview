{
  "ch-01": {
    "prompt": "What is the mandatory naming convention for custom hooks in React?",
    "explanation": "The 'use' prefix is essential because it allows React's linter to automatically check for violations of the Rules of Hooks.",
    "interviewTip": "If you don't start with 'use', React won't know it's a hook and won't be able to guarantee its call order stability.",
    "options": [
      "They must end with 'Hook' (e.g., useDataHook).",
      "They must start with the word 'use' (e.g., useFetch).",
      "They must be written in ALL_CAPS.",
      "There is no mandatory naming convention."
    ]
  },
  "ch-02": {
    "prompt": "What is the primary benefit of creating a custom hook?",
    "explanation": "Custom hooks let you hide complex logic (like data fetching, form handling, or event listeners) behind a simple API that multiple components can share.",
    "interviewTip": "Think of custom hooks as 'Logic Composition' rather than 'UI Composition'.",
    "options": [
      "To speed up the rendering of the Virtual DOM.",
      "To extract and reuse stateful logic between different components.",
      "To replace the need for the useEffect hook.",
      "To create a global variable that bypasses the props system."
    ]
  },
  "ch-03": {
    "prompt": "If two components use the same custom hook, do they share the same state?",
    "explanation": "Hooks are a way to reuse *logic*, not *data*. Every time you call a hook, all state and effects inside it are isolated to that specific caller.",
    "interviewTip": "If you need to share data, you still need Context or a state management library like Redux.",
    "options": [
      "Yes, custom hooks create a singleton state for that logic.",
      "No, each call to a custom hook creates a completely independent state for that component instance.",
      "Only if the hook is imported from a global file.",
      "Only if the components are siblings."
    ]
  },
  "ch-04": {
    "prompt": "What can you call inside a custom hook?",
    "explanation": "Custom hooks are essentially regular functions that have 'superpowers'—they can use any other React hooks inside them.",
    "interviewTip": "This is why custom hooks are so powerful; they are the glue that combines multiple built-in hooks into a single feature.",
    "options": [
      "Only standard JavaScript functions.",
      "Only other custom hooks.",
      "Other built-in React hooks (useState, useEffect, etc.) and even other custom hooks.",
      "Nothing; custom hooks must be pure functions without state."
    ]
  },
  "ch-05": {
    "prompt": "Analyze the custom hook below. What is its return type?",
    "explanation": "Custom hooks can return anything (arrays, objects, or even single values). Returning an array is a common pattern modeled after useState.",
    "interviewTip": "Returning an array is great for renaming values during destructuring. Returning an object is better if there are many return values.",
    "options": [
      "A single boolean value.",
      "An object { value, toggle }.",
      "An array [boolean, function].",
      "undefined"
    ]
  },
  "ch-06": {
    "prompt": "Which of the following are valid Rules of Hooks that apply to custom hooks?",
    "explanation": "Custom hooks are bound by the same rules as built-in hooks: they must be called at the top level and must not be conditional.",
    "interviewTip": "The call order must remain identical between every render for React to track state correctly.",
    "options": [
      "Hooks must be called only at the top level of the function.",
      "Hooks can be called inside event handlers within the custom hook.",
      "Hooks cannot be called inside loops or conditions.",
      "Custom hooks must return JSX."
    ]
  },
  "ch-07": {
    "prompt": "Identify the potential issue in this custom hook:",
    "explanation": "Side effects like event listeners must be inside a useEffect with a cleanup function to avoid adding thousands of listeners as the component re-renders.",
    "interviewTip": "Always pair 'add' with 'remove' in a cleanup function.",
    "options": [
      "The hook should return an object, not a number.",
      "It causes a memory leak because it adds a new listener on every render without removing it.",
      "window is not accessible in custom hooks.",
      "setSize should be called inside a loop."
    ]
  },
  "ch-08": {
    "prompt": "How do you pass parameters to a custom hook?",
    "explanation": "Since custom hooks are just functions, you can pass any data (strings, objects, or even other functions) as arguments.",
    "interviewTip": "If the arguments change, make sure the hooks *inside* your custom hook (like useEffect) react to those changes by adding them to dependency arrays.",
    "options": [
      "You can't; custom hooks don't accept arguments.",
      "Pass them as normal function parameters when calling the hook.",
      "By setting a global variable before the hook is called.",
      "Using a special 'useParams' prop."
    ]
  },
  "ch-09": {
    "prompt": "What is the main advantage of the following pattern?",
    "explanation": "This is a classic 'useForm' hook. Instead of every component writing its own handleChange logic, they just import this hook.",
    "interviewTip": "Standardizing common UI logic like forms or modals into custom hooks is a sign of a senior-level codebase.",
    "options": [
      "It allows any component to use the same form logic without rewriting the state and handlers.",
      "It automatically submits the data to a server.",
      "It makes the form run in the background.",
      "It validates the inputs using AI."
    ]
  },
  "ch-10": {
    "prompt": "Can a custom hook be called from inside another custom hook?",
    "explanation": "Hooks are composable. For example, a `useAuthenticatedFetch` hook might call a `useAuth` hook and a `useFetch` hook internally.",
    "interviewTip": "Composition is the 'secret sauce' of React's flexibility.",
    "options": [
      "No, that's nesting and is prohibited.",
      "Yes, this is a common way to build complex logic out of simpler hooks.",
      "Only if the parent hook is a class component.",
      "Only if you use the 'useCompose' utility."
    ]
  },
  "ch-11": {
    "prompt": "Why should you use 'useCallback' or 'useMemo' inside a custom hook that returns functions or objects?",
    "explanation": "If your hook returns a function like `() => {}`, that function is a new reference on every render. If that function is a dependency in a component's useEffect, the component will enter an infinite loop.",
    "interviewTip": "Providing 'referential stability' is a key responsibility of a well-written custom hook.",
    "options": [
      "To prevent the hook from ever re-running.",
      "To provide stable references so that components using the hook don't re-render unnecessarily.",
      "To encrypt the returned data.",
      "To make the code harder to reverse engineer."
    ]
  },
  "ch-12": {
    "prompt": "Which of these are good candidates for a custom hook?",
    "explanation": "Simple math is a regular function. Anything that requires 'State' or 'Lifecycle' (like online status, pagination, or IntersectionObserver) should be a custom hook.",
    "interviewTip": "If it doesn't use any React hooks (useState, useEffect, etc.), it probably shouldn't be a hook—just a regular utility function.",
    "options": [
      "A logic that tracks if the user is currently online/offline.",
      "A function that adds two numbers and returns the sum.",
      "A logic that handles pagination and sorting for a data table.",
      "A logic that checks if an element is currently visible in the viewport."
    ]
  },
  "ch-13": {
    "prompt": "What happens if you use a custom hook inside an 'if' statement?",
    "explanation": "React maps state to hooks based on their *index* in the call order. If you skip a hook because of a condition, the internal indexes shift, and the wrong state is assigned to the wrong hooks.",
    "interviewTip": "Remember: The order of hooks must be identical on every single render.",
    "options": [
      "The data is only fetched for logged-in users, saving bandwidth.",
      "It will work fine in development but fail in production.",
      "React will break because the order of hook calls changed, potentially causing a crash or state mismatch.",
      "The hook will be called once and then cached."
    ]
  }
}