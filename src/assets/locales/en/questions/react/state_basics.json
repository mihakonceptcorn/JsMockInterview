{
  "sb-01": {
    "prompt": "What happens when you update a React state variable using its setter function?",
    "explanation": "Calling a state setter notifies React that the underlying data has changed, triggering a re-render to synchronize the UI with the new data.",
    "interviewTip": "Remember that state updates are asynchronous and batched for performance."
  },
  "sb-02": {
    "prompt": "What is the correct way to initialize a state variable 'count' to 0?",
    "explanation": "useState returns an array where the first element is the current state and the second is the updater function. We use array destructuring to name them.",
    "interviewTip": "Always use 'const' for state variables because you should never mutate them directly; only the setter should change them."
  },
  "sb-03": {
    "prompt": "What will be the value of 'count' displayed in the UI after clicking the button once?",
    "explanation": "Because 'count' is captured from the current render's scope, all three calls see 'count' as 0. React batches these, and the result is 0 + 1.",
    "interviewTip": "This is a classic 'Stale Closure' example. To fix this, use the functional update pattern: setCount(prev => prev + 1)."
  },
  "sb-04": {
    "prompt": "Which of the following are true regarding the Rules of Hooks?",
    "explanation": "Hooks must follow a consistent call order. Placing them in loops or conditions breaks React's ability to track state correctly.",
    "interviewTip": "If you need a conditional hook, put the condition *inside* the hook (like useEffect) rather than wrapping the hook itself."
  },
  "sb-05": {
    "prompt": "How do you correctly update an object state while preserving existing fields?",
    "explanation": "The setter function replaces the state entirely. To update a field, you must spread the existing state and overwrite the target field.",
    "interviewTip": "Directly mutating 'user.age' fails because React uses Object.is to check for changes. If the object reference is the same, no render occurs."
  },
  "sb-06": {
    "prompt": "What is the primary benefit of the 'Lazy Initializer' pattern?",
    "explanation": "If you pass an initial value directly, it is calculated every render. If you pass a function, React only executes it during the first render.",
    "interviewTip": "Use this for expensive tasks like parsing large JSON from storage or complex mathematical computations."
  },
  "sb-07": {
    "prompt": "How do you access the value of an input field in a 'Controlled Component'?",
    "explanation": "React's synthetic event object 'e' contains a 'target' property pointing to the DOM element, which has the 'value' property.",
    "interviewTip": "In controlled components, the state is the 'single source of truth' for the input value."
  },
  "sb-08": {
    "prompt": "What is a 'SyntheticEvent' in React?",
    "explanation": "React creates these wrappers so that events behave identically across Chrome, Safari, Firefox, and Edge.",
    "interviewTip": "You can still access the native browser event via 'e.nativeEvent' if absolutely necessary."
  },
  "sb-09": {
    "prompt": "What will happen if you update state with the exact same value it currently holds?",
    "explanation": "React uses Object.is to compare the new state with the old. If they are identical, React avoids the unnecessary work of rendering.",
    "interviewTip": "This is why mutating an array and calling setState(sameArray) doesn't workâ€”the reference is identical."
  },
  "sb-10": {
    "prompt": "Analyze the code. What is the console output after the button is clicked?",
    "explanation": "Setting state is asynchronous. The 'val' variable belongs to the current execution frame and doesn't change until the next render.",
    "interviewTip": "If you need to perform an action after state updates, use the 'useEffect' hook."
  },
  "sb-11": {
    "prompt": "Which of these are valid ways to trigger a function when a user clicks a button?",
    "explanation": "Option A passes a reference. Option C creates an anonymous function. Option D is wrong because it executes the function *during* render.",
    "interviewTip": "Watch out for 'onClick={handleClick()}'; it will cause an infinite loop if handleClick updates state."
  },
  "sb-12": {
    "prompt": "How do you clear an interval created inside a component when using state timers?",
    "explanation": "To prevent memory leaks and unexpected behavior, you must clear side effects like intervals when a component unmounts.",
    "interviewTip": "This is a key part of the component lifecycle management."
  },
  "sb-13": {
    "prompt": "What is 'State Lifting'?",
    "explanation": "When two sibling components need to stay in sync, you move the state to their parent and pass it back down via props.",
    "interviewTip": "This is the standard way to share state without using Context."
  },
  "sb-14": {
    "prompt": "What is the default value of 'event.preventDefault()' in a form's 'onSubmit'?",
    "explanation": "By default, HTML forms reload the page. In React 'Single Page Apps', we prevent this to handle the submission via JS.",
    "interviewTip": "Always remember this in form handlers to avoid losing your application state."
  },
  "sb-15": {
    "prompt": "How do you correctly handle a state update that depends on the previous state?",
    "explanation": "Functional updates guarantee that you are working with the most recent state, even if multiple updates are queued.",
    "interviewTip": "This pattern is essential when state updates are triggered rapidly (like in an interval or during high-frequency events)."
  },
  "sb-16": {
    "prompt": "Where can you define state in a functional component?",
    "explanation": "According to the Rules of Hooks, they must be called at the very top of your component function.",
    "interviewTip": "React uses the call order to map state to the correct component instance."
  },
  "sb-17": {
    "prompt": "What is an 'Uncontrolled Component'?",
    "explanation": "In uncontrolled components, the form data is handled by the DOM itself. You use 'useRef' to pull values when needed.",
    "interviewTip": "Controlled components are usually preferred for complex forms, while uncontrolled are fine for simple, one-off inputs."
  }
}
